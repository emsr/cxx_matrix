// The template and inlines for the -*- C++ -*- non-owning container access.

// Copyright (C) 2018 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cpan
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_SPAN
#define _GLIBCXX_SPAN 1

#pragma GCC system_header

#if __cplusplus > 201703L

#include <cstdint>
#include <type_traits>
#include <array>
#include <iterator>

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // [views.constants], constants

  constexpr std::ptrdiff_t dynamic_extent = -1;

  // [span], class template span

  /**
   * 
   */
  template<typename _Tp, std::ptrdiff_t _Extent = dynamic_extent>
    class span
    {
    public:

      // constants and types

      using element_type = _Tp;
      using value_type = std::remove_cv_t<_Tp>;
      using index_type = std::ptrdiff_t;
      using difference_type = std::ptrdiff_t;
      using pointer = element_type*;
      using reference = element_type&;
      using iterator = pointer;
      using const_iterator = const pointer;
      using reverse_iterator = std::reverse_iterator<iterator>;
      using const_reverse_iterator = std::reverse_iterator<const_iterator>;

      constexpr static index_type extent = _Extent;

      // [span.cons], span constructors, copy, assignment, and destructor

      constexpr
      span() noexcept
      : _M_data{}, _M_size{}
      { }

      constexpr
      span(nullptr_t) noexcept
      { }

      constexpr
      span(pointer __ptr, index_type __count)
      : _M_data(__ptr), _M_size{__count}
      { }

      constexpr
      span(pointer __first, pointer __last)
      : _M_data(__first), _M_size(std::distance(__first, __last))
      { }

      template<size_t _Num>
	constexpr
	span(element_type (&__arr)[_Num])
	: _M_data(__arr), _M_size(_Num)
	{ /*Warn if extent > _Num*/ }

      template<size_t _Num>
	constexpr
	span(array<remove_const_t<element_type>, _Num>& __arr)
	: _M_data(__arr.data()), _M_size(_Num)
	{ /*Warn if extent > _Num*/ }

      // is_const_v<element_type>
      template<size_t _Num>
	constexpr
	span(const array<remove_const_t<element_type>, _Num>& __arr)
	: _M_data(__arr.data()), _M_size(__arr.size())
	{ /*Warn if extent > _Num*/ }

      template<typename _Container>
	constexpr
	span(_Container& __cont)
	: _M_data(__cont.data()), _M_size(__cont.size())
	{ }

      template<typename _Container>
	span(const _Container& __cont)
	: _M_data(__cont.data()), _M_size(__cont.size())
	{ }

      constexpr
      span(const span& __other) noexcept = default;

      constexpr
      span(span&& __other) noexcept = default;

      template<typename _ElementType2, std::ptrdiff_t _Extent2>
	constexpr
	span(const span<_ElementType2, _Extent2>& __other);

      template<typename _ElementType2, std::ptrdiff_t _Extent2>
	constexpr
	span(span<_ElementType2, _Extent2>&& __other);

      ~span() noexcept = default;

      constexpr span&
      operator=(const span& __other) noexcept = default;

      constexpr span&
      operator=(span&& __other) noexcept = default;

      // [span.sub], span subviews

      template <ptrdiff_t _Count>
	constexpr span<element_type, _Count>
	first() const
	{
	  using __span_t = span<element_type, _Count>;
	  return __span_t(this->data(), _Count);
	}

      template <ptrdiff_t _Count>
	constexpr span<element_type, _Count>
	last() const
	{
	  using __span_t = span<element_type, _Count>;
	  return __span_t(this->data() + (this->size() - _Count), _Count);
	}

      template <ptrdiff_t _Offset, std::ptrdiff_t _Count = dynamic_extent>
	constexpr span<element_type, _Count>
	subspan() const
	{
	  using __span_t = span<element_type, _Count>;
	  __span_t(this->data() + _Offset,
		   _Count == dynamic_extent
		   ? this->size() - _Offset
		   : _Count);
	}

      // count >= 0 && count <= size()
      constexpr span<element_type, dynamic_extent>
      first(index_type __count) const
      { return span<element_type>(this->data(), __count); }

      // count >= 0 && count <= size()
      constexpr span<element_type, dynamic_extent>
      last(index_type __count) const
      {
	using __span_t = span<element_type>;
	return __span_t(this->data() + (this->size() - __count), __count);
      }

      // (offset == 0 || offset > 0 && offset < size())
      // && (count == dynamic_extent || count >= 0 && offset + count <= size())
      constexpr span<element_type, dynamic_extent>
      subspan(index_type __offset, index_type __count = dynamic_extent) const
      {
	using __span_t = span<element_type>;
	return __span_t(this->data() + __offset,
			__count == dynamic_extent
			? this->size() - __offset
			: __count);
      }

      // [span.obs], span observers

      constexpr index_type
      length() const noexcept
      { return this->size(); }

      constexpr index_type
      size() const noexcept
      { return this->_M_size; }

      constexpr index_type
      length_bytes() const noexcept
      { return this->size_bytes(); }

      constexpr index_type
      size_bytes() const noexcept
      { return this->_M_size * sizeof(element_type); }

      constexpr bool
      empty() const noexcept
      { return this->_M_data == nullptr || this->_M_size == 0; }

      // [span.elem], span element access

      constexpr reference
      operator[](index_type __idx) const
      { return this->_M_data[__idx]; }

      constexpr reference
      operator()(index_type __idx) const
      { return this->_M_data[__idx]; }

      constexpr pointer
      data() const noexcept
      { return this->_M_data; }

      // [span.iter], span iterator support

      iterator
      begin() const noexcept
      { return this->_M_data; }

      iterator
      end() const noexcept
      { return this->_M_data + this->_M_size; }

      const_iterator
      cbegin() const noexcept
      { return this->_M_data; }

      const_iterator
      cend() const noexcept
      { return this->_M_data + this->_M_size; }

      reverse_iterator
      rbegin() const noexcept
      { return reverse_iterator(this->end()); }

      reverse_iterator
      rend() const noexcept
      { return reverse_iterator(this->begin()); }

      const_reverse_iterator
      crbegin() const noexcept
      { return reverse_iterator(this->cend()); }

      const_reverse_iterator
      crend() const noexcept
      { return reverse_iterator(this->cbegin()); }

    private:

      pointer _M_data = nullptr;

      index_type _M_size = 0;
  };

  // [span.objectrep], views of object representation

  template<typename _Tp, std::ptrdiff_t _Extent>
    span<const std::byte, ((_Extent == dynamic_extent)
		      ? dynamic_extent
		      : (sizeof(_Tp) * _Extent))>
    as_bytes(span<_Tp, _Extent> s) noexcept;

  template<typename _Tp, std::ptrdiff_t _Extent>
    span<std::byte, ((_Extent == dynamic_extent)
		? dynamic_extent
		:(sizeof(_Tp) * _Extent))>
    as_writeable_bytes(span<_Tp, _Extent>) noexcept;

  template<typename _Tp, std::size_t _Num>
    span(_Tp(&)[_Num])
    -> span<_Tp, _Num>;

  template<typename _Tp, std::size_t _Num>
    span(array<_Tp, _Num>&)
    -> span<_Tp, _Num>;

  template<typename _Tp, std::size_t _Num>
    span(const array<_Tp, _Num>&)
    -> span<const _Tp, _Num>;

  template<typename _Container>
    span(_Container&)
    -> span<typename _Container::value_type>;

  template<typename _Container>
    span(const _Container&)
    -> span<const typename _Container::value_type>;

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif // C++20

#endif  /* _GLIBCXX_SPAN */
