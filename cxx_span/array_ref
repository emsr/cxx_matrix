// P0009r2 : Polymorphic Multidimensional Array Reference

namespace std {
namespace experimental {

  template<typename DataType, typename... Properties>
    struct array_ref;

  template<typename DataType, typename... Properties, typename... SliceSpecifiers>
    array_ref</* deduced */>
    subarray(const array_ref<DataType, Properties...>&, SliceSpecifiers...) noexcept;

} // namespace experimental
} // namespace std


namespace std {
namespace experimental {
namespace array_property {

  template<typename>
    struct is_array_property : std::bool_constant<false>;

  template<typename T>
    using is_array_property_v = is_array_property<T>::value;

  // array dimension property
  template<typename IntegralType, IntegralType... Dims>
    struct dimension_typed;

  template<size_t... Dims>
    using dimension = dimension_typed<size_t, Dims...>;

  // array layout property
  struct layout_right;
  struct layout_left;
  struct layout_stride;

  // I'm specializing these.
  template<>
    struct is_array_property<layout_right> : std::bool_constant<true>;
  template<>
    struct is_array_property<layout_left> : std::bool_constant<true>;
  template<>
    struct is_array_property<layout_stride> : std::bool_constant<true>;

  template<typename T>
    struct is_layout;

  template<typename T>
    constexpr bool is_layout_v = is_layout<T>::value;

  // bounds checking property
  template<bool Enable>
    struct bounds_check_if;

  using bounds_check = bounds_check_if<true>;

  // Assignability property
  template<class array_ref_V, class array_ref_U>
    struct is_assignable : std::bool_constant<false> {};

  template<class array_ref_V, class array_ref_U>
    using is_assignable_v = is_assignable<array_ref_V, array_ref_U>::value;

  // subarray support
  struct all_type {};

  constexpr all_type all = all_type();

} // namespace array_property
} // namespace experimental
} // namespace std

namespace std {
namespace experimental {
namespace array_property {

  template<typename IntegralType, IntegralType... Dims>
    struct dimension_typed
    {
      // types
      using size_type  = std::size_t;
      using value_type = IntegralType;

      // constructors, copy, assignment, destructor

      constexpr dimension_typed() noexcept;

      template<typename... IntegralArgs>
	constexpr dimension_typed(IntegralArgs... dynamic_dims) noexcept;

      constexpr dimension_typed(dimension_typed&& rhs) noexcept;

      constexpr dimension_typed(dimension_typed const& rhs) noexcept;

      dimension_typed&
      operator=(dimension_typed&& rhs) noexcept;

      dimension_typed&
      operator=(const dimension_typed& rhs) noexcept;

      ~dimension();

      // observers

      static constexpr size_type
      rank() noexcept
      { return sizeof...(IntegralType); }

      static constexpr size_type
      rank_dynamic() noexcept
      { return (0 + (Dims == 0 ? 1 : 0)...); }

      template<size_type ith>
	static constexpr value_type
	static_extent() noexcept;

      constexpr value_type
      extent(size_type ith) const noexcept;

      constexpr value_type
      size() const noexcept;
    };

} // namespace array_property
} // namespace experimental
} // namespace std


struct /* layout_concept */ {

  template<typename DimensionType>
    struct mapping : DimensionType
    {

      // types and constants

      static constexpr bool is_always_unique     = /* layout specific */;
      static constexpr bool is_always_contiguous = /* layout specific */;
      static constexpr bool is_always_regular    = /* layout specific */;

      // constructors, copy, assignment, destructor

      constexpr mapping() noexcept;

      constexpr mapping(mapping &&) noexcept;

      constexpr mapping(mapping const &) noexcept;

      mapping&
      operator=(mapping&&) noexcept;

      mapping&
      operator=(mapping const&) noexcept;

      constexpr explicit
      mapping(layout_concept const&);

      template<typename... IntegralArgs>
	constexpr mapping(IntegralArgs ... dynamic_dimensions);

      // observers

      constexpr bool
      is_unique() const noexcept;

      constexpr bool
      is_contiguous() const noexcept;

      constexpr bool
      is_regular() noexcept;

      constexpr value_type
      span() const noexcept;

      constexpr value_type
      stride(size_type ith) const noexcept;

      // mapping operator

      template<typename... IntegralArgs>
        constexpr value_type
        operator()(IntegralArgs ... indices) const noexcept;
    };
};


namespace std {
namespace experimental {

  template<typename DataType, typename... Properties>
    struct array_ref
    {
      // types

      using layout     = /* deduced from Properties... */;
      using value_type = /* deduced from DataType */;
      using reference  = /* deduced from DataType and Properties... */;
      using pointer    = /* deduced from DataType */;
      using size_type  = /* implementation defined */;

      using iterator               = /* deduced from DataType */;
      using const_iterator         = /* deduced from DataType */;
      using reverse_iterator       = reverse_iterator<iterator>;
      using const_reverse_iterator = reverse_iterator<const_iterator>;

      // constructors, copy, assignment, and destructor

      constexpr
      array_ref() noexcept;

      constexpr
      array_ref(array_ref&& rhs) noexcept;

      constexpr
      array_ref(array_ref const& rhs) noexcept;

      array_ref&
      operator=(array_ref&& rhs) noexcept;

      array_ref&
      operator=(array_ref const& rhs) noexcept;

      template<typename... IntegralArgs>
	explicit constexpr
	array_ref(pointer p, IntegralArgs... dynamic_dims) noexcept;

      explicit constexpr
	array_ref(pointer p, layout const&) noexcept;

      template<typename UType, typename... UProperties>
	constexpr
	array_ref(array_ref<UType, UProperties...> const& rhs) noexcept;

      template<typename UType, typename... UProperties>
	array_ref&
	operator=(array_ref<UType, UProperties...> const& rhs) noexcept;

      ~array_ref() noexcept;

      // observers of domain index space

      static constexpr size_type
      rank() noexcept;

      static constexpr size_type
      rank_dynamic() noexcept;

      constexpr size_type
      size() const noexcept;

      constexpr size_type
      extent(size_type ith) const noexcept;

      // observers of mapping from domain index space to range value space

      static constexpr bool is_always_unique     = /* deduced */;
      static constexpr bool is_always_contiguous = /* deduced */;
      static constexpr bool is_always_regular    = /* deduced */;

      constexpr bool
      is_unique() const noexcept;

      constexpr bool
      is_contiguous() const noexcept;

      constexpr bool
      is_regular() noexcept;

      constexpr size_type
      stride(size_type rank) const noexcept;

      constexpr size_type
      span() const noexcept;

      template<typename... IntegralArgs>
	static constexpr size_type
	required_span(IntegralArgs... dynamic_dims) const noexcept;

      static constexpr size_type
      required_span(layout const&) const noexcept;

      // element and data access

      constexpr pointer
      data() const noexcept;

      template<typename... IntegralArgs>
        reference
        operator()(IntegralArgs... indices) const noexcept;

      reference
      operator[](size_type idx) const noexcept;

      // iterator support, requires is_contiguous

      constexpr iterator
      begin() const noexcept;

      constexpr iterator
      end() const noexcept;

      constexpr const_iterator
      cbegin() const noexcept;

      constexpr const_iterator
      cend() const noexcept;

      constexpr reverse_iterator
      rbegin() const noexcept;

      constexpr reverse_iterator
      rend() const noexcept;

      constexpr const_reverse_iterator
      crbegin() const noexcept;

      constexpr const_reverse_iterator
      crend() const noexcept;
    };

} // namespace experimental
} // namespace std

