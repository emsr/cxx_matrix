#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 01/09/1995 00:05 UTC by pozo@hemlock
# Source directory /tmp
#
# existing files will NOT be overwritten unless -c is specified
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   2888 -rw-rw---- mv/makefile
#   1943 -rw-rw---- mv/makefile.def
#   3334 -rw-rw---- mv/README
#    218 -rw-rw---- mv/lib/empty
#   3150 -rw-rw---- mv/include/mv_blas1.h
#    918 -rw-rw---- mv/include/mv_blas1_complex.h
#    889 -rw-rw---- mv/include/mv_blas1_double.h
#    860 -rw-rw---- mv/include/mv_blas1_float.h
#    802 -rw-rw---- mv/include/mv_blas1_int.h
#    831 -rw-rw---- mv/include/mv_blas1_type.h
#  10769 -rw-rw---- mv/include/mv_matrix.h
#    439 -rw-rw---- mv/include/mv_matrix_all.h
#   4853 -rw-rw---- mv/include/mv_matrix_complex.h
#   4795 -rw-rw---- mv/include/mv_matrix_double.h
#   4754 -rw-rw---- mv/include/mv_matrix_float.h
#   4672 -rw-rw---- mv/include/mv_matrix_int.h
#    477 -rw-rw---- mv/include/mv_matrix_ref.h
#   4717 -rw-rw---- mv/include/mv_matrix_type.h
#   4751 -rw-rw---- mv/include/mv_matrix_user_type.h
#   2039 -rw-rw---- mv/include/mv_vecindex.h
#  14554 -rw-rw---- mv/include/mv_vector.h
#    451 -rw-rw---- mv/include/mv_vector_all.h
#   7007 -rw-rw---- mv/include/mv_vector_complex.h
#   6947 -rw-rw---- mv/include/mv_vector_double.h
#   6912 -rw-rw---- mv/include/mv_vector_float.h
#   6834 -rw-rw---- mv/include/mv_vector_int.h
#    477 -rw-rw---- mv/include/mv_vector_ref.h
#   6873 -rw-rw---- mv/include/mv_vector_type.h
#   6907 -rw-rw---- mv/include/mv_vector_user_type.h
#    861 -rw-rw---- mv/include/vector_defs.h
#   3025 -rw-rw---- mv/src/mv_blas1_complex.cc
#   2992 -rw-rw---- mv/src/mv_blas1_double.cc
#   2959 -rw-rw---- mv/src/mv_blas1_float.cc
#   2893 -rw-rw---- mv/src/mv_blas1_int.cc
#   2926 -rw-rw---- mv/src/mv_blas1_type.cc
#   2942 -rw-rw---- mv/src/mv_blas1_user_type.cc
#   6013 -rw-rw---- mv/src/mv_matrix_complex.cc
#   5974 -rw-rw---- mv/src/mv_matrix_double.cc
#   5935 -rw-rw---- mv/src/mv_matrix_float.cc
#   5857 -rw-rw---- mv/src/mv_matrix_int.cc
#   5896 -rw-rw---- mv/src/mv_matrix_type.cc
#   6486 -rw-rw---- mv/src/mv_vector_complex.cc
#   6411 -rw-rw---- mv/src/mv_vector_double.cc
#   6344 -rw-rw---- mv/src/mv_vector_float.cc
#   6210 -rw-rw---- mv/src/mv_vector_int.cc
#   6277 -rw-rw---- mv/src/mv_vector_type.cc
#    448 -rw-rw---- mv/src/ostream_complex.cc
#   1057 -rw-r----- mv/src/makefile
#   1772 -rw-rw---- mv/testing/tblas1.cc
#   1777 -rw-rw---- mv/testing/tblas1_complex.cc
#   1772 -rw-rw---- mv/testing/tblas1_double.cc
#   1767 -rw-rw---- mv/testing/tblas1_float.cc
#   1757 -rw-rw---- mv/testing/tblas1_int.cc
#   1762 -rw-rw---- mv/testing/tblas1_type.cc
#   5418 -rw-rw---- mv/testing/tmat.cc
#   1814 -rw-rw---- mv/testing/tmat2.cc
#   5426 -rw-rw---- mv/testing/tmat_complex.cc
#   5402 -rw-rw---- mv/testing/tmat_double.cc
#   5378 -rw-rw---- mv/testing/tmat_float.cc
#   5330 -rw-rw---- mv/testing/tmat_int.cc
#   5354 -rw-rw---- mv/testing/tmat_type.cc
#   6143 -rw-rw---- mv/testing/tvec.cc
#   6435 -rw-rw---- mv/testing/tvec_complex.cc
#   6404 -rw-rw---- mv/testing/tvec_double.cc
#   6373 -rw-rw---- mv/testing/tvec_float.cc
#   6311 -rw-rw---- mv/testing/tvec_int.cc
#   6342 -rw-rw---- mv/testing/tvec_type.cc
#   2269 -rw-r----- mv/testing/makefile
#    558 -rw-r----- mv/testing/makefile.templated
#    222 -r-xr-x--- mv/testing/mv_test
#     40 -r-xr-x--- mv/testing/templated_mv_test
#  20392 -rw-rw---- mv/testing/mv_test.out
#
# ============= mv/makefile ==============
if test ! -d 'mv'; then
    echo 'x - creating directory mv'
    mkdir 'mv'
fi
if test -f 'mv/makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/makefile (File already exists)'
else
echo 'x - extracting mv/makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/makefile' &&
X
X
X
################################################################
#
# Subdirectories for building
#
################################################################
X
error:
X	@echo "+-----------------------------------------------------------------+"
X	@echo "|                                                                 |"
X	@echo "|              MV++ Matrix/Vector C++ Class Library               |"	
X	@echo "|                                                                 |"
X	@echo "| Usage: make all              install and test MV++              |"
X	@echo "|        make mv               install non-templated MV++ library |"
X	@echo "|        make test             run non-templated test suite       |"
X	@echo "|        make templated_test   run templated test suite           |"
X	@echo "|        make clean            clean *.o and test executables     |"
X	@echo "|                                                                 |"
X	@echo "|  Make sure the system-specific makefile.def has been edited     |"
X	@echo "|  to reflect your system configuration.                          |"
X	@echo "|                                                                 |"
X	@echo "+-----------------------------------------------------------------+"
X	
all: mv test clean  done
X
X
mv:
X	cd ./src; make;
X	
templated_test:
X	cd ./testing; make  -f makefile.templated;
X	cd ./testing; templated_mv_test > templated_mv_test.out;
X	cd ./testing; make clean;
X	@echo "  "
X	@echo " +---------------------------------------------------------------+"
X	@echo " |                                                               |"
X	@echo " | MV++ test results are in <mv++>/testing/templated_mv_test.out |"
X	@echo " |                                                               |"
X	@echo " +---------------------------------------------------------------+"
X	@echo "  "
X
test:
X	cd ./testing; make;
X	cd ./testing; mv_test > mv_test.out;
X	cd ./testing; make clean;
X	@echo "  "
X	@echo " +---------------------------------------------------------------+"
X	@echo " |                                                               |"
X	@echo " |      MV++ test results are in <mv++>/testing/mv_test.out      |"
X	@echo " |                                                               |"
X	@echo " +---------------------------------------------------------------+"
X	@echo "  "
X
clean:
X	cd ./src; make clean;
X	cd ./testing; make clean;
X
wipe:
X	cd ./src; make wipe;
X	cd ./testing; make wipe;
X
done:
X	@echo "  "
X	@echo " +---------------------------------------------------------------+"
X	@echo " |                                                               |"
X	@echo " |                     MV++ installed.                           |"
X	@echo " |                                                               |"
X	@echo " +---------------------------------------------------------------+"
X	@echo "  "
X	@echo "  "
SHAR_EOF
chmod 0660 mv/makefile ||
echo 'restore of mv/makefile failed'
Wc_c="`wc -c < 'mv/makefile'`"
test 2888 -eq "$Wc_c" ||
	echo 'mv/makefile: original size 2888, current size' "$Wc_c"
fi
# ============= mv/makefile.def ==============
if test -f 'mv/makefile.def' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/makefile.def (File already exists)'
else
echo 'x - extracting mv/makefile.def (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/makefile.def' &&
#***************************************************************************
#
#                    M V ++     M A K E F I L E . D E F
#
#    Compiler Specific Section:   Edit to reflect your environment
#---------------------------------------------------------------------------
#
#	Macro                 Significance
#
#   CCC                   C++ compiler
#   CCCFLAGS              flags to C++ compiler
#   CC                    C compiler
#   CFLAGS                flags to C compiler
#   LDFLAGS				  libraries 
#   HASRANLIB             't' if your system has ranlib, 'f' otherwise
#
#
# Some defaults are below for Sun C++, and GNU g++.  Uncomment the 
# relevant sections.
#
#
X
X
# Sun C++ 3.0.1 
#
CCC 			= CC
CC 				= acc	
CFLAGS 			= -O
CCCFLAGS		= -O
LDFLAGS			=  ../lib/mvlib.a -lm -lcomplex
X
# IBM xlC  v. 1.1
#
CCC 			= xlC
CC 				= xlc
CFLAGS 			= -O
CCCFLAGS		= -+ -O
LDFLAGS			= ../lib/mvlib.a -lm -lcomplex
X
# g++ v. 2.6.0
#
CCC 			= g++
CC 				= gcc	
CFLAGS 			= -O
CCCFLAGS		= -O  
LDFLAGS			=    ../lib/mvlib.a -lm
X
X
# ranlib available on this system? 't' or 'f'
HASRANLIB = t
X
X
X
################################################################
#                                                              #
#           Implicit rules: do not modfiy after here           #
#                                                              #
################################################################
X
X
MV_DIR 				= ..
MV_LIB_DIR			= $(MV_DIR)/lib
MV_INCLUDE_DIR		= $(MV_DIR)/include
X
EXENAME     = -o
OBJ_EXT     = o
LIB_EXT     = a
EXE_EXT     =
X
.SUFFIXES: .c .cc .$(OBJ_EXT) $(EXE_EXT)
X
OBJS            = $(SRCS:.cc=.$(OBJ_EXT))
X
EXECS           = $(SRCS:.cc=$(EXE_EXT))
X
.$(OBJ_EXT)$(EXE_EXT):
X	$(CCC) $(EXENAME)  $@$(EXE_EXT) $@.$(OBJ_EXT) \
X	$(LIBS)$(LDFLAGS)
X        
.cc.$(OBJ_EXT):
X	$(CCC) $(CCCFLAGS)  $(INCLUDES) -c $<
X
.c.$(OBJ_EXT):
X	$(CC) $(CFLAGS) $(INCLUDES) -c $<
X
.f.$(OBJ_EXT):
X	$(F77)  -c $<
X
X
SHAR_EOF
chmod 0660 mv/makefile.def ||
echo 'restore of mv/makefile.def failed'
Wc_c="`wc -c < 'mv/makefile.def'`"
test 1943 -eq "$Wc_c" ||
	echo 'mv/makefile.def: original size 1943, current size' "$Wc_c"
fi
# ============= mv/README ==============
if test -f 'mv/README' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/README (File already exists)'
else
echo 'x - extracting mv/README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/README' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
X
X         MV++ :  Numerical Matrix/Vector Classes in C++
X
X
MV++ is a small, efficient, set of concrete vector and simple matrix
classes for numerical computing.  It is not intended as a general
vector container class, but rather designed  specifically for optimized
numerical computations on RISC and pipelined architectures.  It is one
step above a C/C++ array, altough it supports subvector/matrix expressions.
X
It includes several of the computational kernels found in the 
Basic Linear Algebra Subprograms (BLAS), such as scalar updates,
vector sums, dot products and so on. 
X
These classes are the building blocks of larger user-level libraries such 
as SparseLib++ and Lapack++.
X
X
1) More About MV++
------------------
i) User's Guide and man-style pages are in  ./docs
ii) Code examples are in ./testing/*.cc
X
X
X
2a) Installating Non-tempated MV++ library (float, double, and complex)
------------------------------------------
X
i)   cd to root directory where MV++ is installed, <mv++>
ii)  edit makefile.def to specify your specify your particular C++ compiler
iii) type "make mv"; "make" by itself will provide a list of options.
X
X
X
2b) Installing Templated MV++ libraries
---------------------------------------
i) there's no library to build; they're all in header files.
X   **NOTE: Be aware that some compilers (particularly early ones) have 
X   difficulty with proper template instantiations. If you experience
X   problems, use the non-templated version. ***
X
X
X
3) Testing MV++
---------------
X
i) cd to <mv++>
iia) "make test" will run a test suites and leave their output in 
X	           	<mv++>/testing/mv_test.out.  
or
X
iib) "make templated_test" will run same test suites using the templated
X	version of MV++.  Output is in 
X			   <mv++>/testing/templated_mv_test.out
X
X
X
4) Using MV++
----------
X
i)   all MV++ include files are in <mv++>/include.
ii)  non-templated MV++ library is in <mv++>/lib/mvlib.a
iii) to extend non-templated MV++ for vector and matrices of user-defined 
X		classes, see mv_vector_type.h, mv_matrix_type.h in <mv++>/include.
X		These can easily modified with an editor, replacing "TYPE" with your
X		specific class name.
X
X
5) Help!
--------
X
Questions, comments, suggestions, etc. can be sent to pozo@cam.nist.gov.
X
X
X
Questions and Answers:
---------------------
X
o) What types does the non-templated MV++ classes support?
X
Float, double, int, and complex.
X
X
o) How do I extend the non-templated MV++ classes to my own data types?
X
Edit mv_vector_type.h in <mv++>/include and change every occurence of
"TYPE" to the name of your numerical class.  (Don't use cpp or m4
for this, as you'll need to change "TYPE" in word segments as well.)
One easy way is
X
X  sed '1,$s/TYPE/Large_Real/g' mv_vector_type.cc > mv_vector_Large_Real.cc
X
Do the same for mv_vector_type.cc in <mv++>/src.
For example, an arbitrary-precision numerical class, Large_Real, would
have MV++ classes MV_Vector_Large_Real, MV_ColMat_Large_Real, and so on.
X
X
X
o) what is the file "empty" in <mv++>/lib?
X
A dummy file; it was put there so our version of shar would
include the <mv++>/lib directory.  Otherwise, make reports an error
when trying to build mvlib.a , because the destination directory does not
exist.
X
X
SHAR_EOF
chmod 0660 mv/README ||
echo 'restore of mv/README failed'
Wc_c="`wc -c < 'mv/README'`"
test 3334 -eq "$Wc_c" ||
	echo 'mv/README: original size 3334, current size' "$Wc_c"
fi
# ============= mv/lib/empty ==============
if test ! -d 'mv/lib'; then
    echo 'x - creating directory mv/lib'
    mkdir 'mv/lib'
fi
if test -f 'mv/lib/empty' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/lib/empty (File already exists)'
else
echo 'x - extracting mv/lib/empty (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/lib/empty' &&
This is a dummy file; it was put there so our version of shar would
include the <mv++>/lib directory.  Otherwise, make reports an error
when trying to build mvlib.a , because the destination directory does not
exist.
X
SHAR_EOF
chmod 0660 mv/lib/empty ||
echo 'restore of mv/lib/empty failed'
Wc_c="`wc -c < 'mv/lib/empty'`"
test 218 -eq "$Wc_c" ||
	echo 'mv/lib/empty: original size 218, current size' "$Wc_c"
fi
# ============= mv/include/mv_blas1.h ==============
if test ! -d 'mv/include'; then
    echo 'x - creating directory mv/include'
    mkdir 'mv/include'
fi
if test -f 'mv/include/mv_blas1.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_blas1.h (File already exists)'
else
echo 'x - extracting mv/include/mv_blas1.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_blas1.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
#ifndef _MV_BLAS1_H_
#define _MV_BLAS1_H_
X
X
X
template <class TYPE>
MV_Vector<TYPE>& operator*=(MV_Vector<TYPE> &x, const TYPE &a)
{
X      int N = x.size();
X      for (int i=0;i<N;i++)
X         x(i) *= a;
X      return x;
}
X
template <class TYPE>
MV_Vector<TYPE> operator*(const TYPE &a, const MV_Vector<TYPE> &x)
{
X      int N = x.size();
X      MV_Vector<TYPE> result(N);
X      for (int i=0;i<N;i++)
X         result(i) = x(i)*a;
X      return result;
}
X
template <class TYPE>
MV_Vector<TYPE> operator*(const MV_Vector<TYPE> &x, const TYPE &a)
{
X    // This is the other commutative case of vector*scalar.
X    // It should be just defined to be
X    // "return operator*(a,x);"
X    // but some compilers (e.g. Turbo C++ v.3.0) have trouble
X    // determining the proper template match.  For the moment,
X    // we'll just duplicate the code in the scalar * MV_Vector 
X    // case above.
X
X      int N = x.size();
X      MV_Vector<TYPE> result(N);
X      for (int i=0;i<N;i++)
X         result(i) = x(i)*a;
X      return result;
X
}
X
template <class TYPE>
MV_Vector<TYPE> operator+(const MV_Vector<TYPE> &x, const MV_Vector<TYPE> &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in +." << endl;
X         exit(1);
X      }
X      
X      MV_Vector<TYPE> result(N);
X      for (int i=0;i<N; i++)
X         result(i) = x(i) + y(i);
X      return result;
}
X          
template <class TYPE>
MV_Vector<TYPE> operator-(const MV_Vector<TYPE> &x, const MV_Vector<TYPE> &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      MV_Vector<TYPE> result(N);
X      for (int i=0;i<N; i++)
X         result(i) = x(i) - y(i);
X      return result;
}
X          
X
template <class TYPE>
MV_Vector<TYPE>& operator+=(MV_Vector<TYPE> &x, const MV_Vector<TYPE> &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      for (int i=0;i<N; i++)
X         x(i) += y(i);
X      return x;
}
X          
X      
template <class TYPE>
MV_Vector<TYPE>& operator-=(MV_Vector<TYPE> &x, const MV_Vector<TYPE> &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      for (int i=0;i<N; i++)
X         x(i) -= y(i);
X      return x;
}
X          
X      
X
//  norm and dot product functions for the MV_Vector<> class
X
X
template <class TYPE>
TYPE dot(const MV_Vector<TYPE> &x, const MV_Vector<TYPE> &y)
{
X        
X  //  Check for compatible dimensions:
X  if (x.size() != y.size())
X      {
X         cout << "Incompatible dimensions in dot(). " << endl;
X         exit(1);
X      }
X
X      TYPE temp=0.0;
X      for (int i=0; i<x.size();i++)
X           temp += x(i)*y(i);
X      return temp;
}
X
template <class TYPE>
TYPE norm(const MV_Vector<TYPE> &x)
{
X      TYPE temp = dot(x,x);
X      return sqrt(temp);
}
X
#endif
// _MV_BLAS1_H_
SHAR_EOF
chmod 0660 mv/include/mv_blas1.h ||
echo 'restore of mv/include/mv_blas1.h failed'
Wc_c="`wc -c < 'mv/include/mv_blas1.h'`"
test 3150 -eq "$Wc_c" ||
	echo 'mv/include/mv_blas1.h: original size 3150, current size' "$Wc_c"
fi
# ============= mv/include/mv_blas1_complex.h ==============
if test -f 'mv/include/mv_blas1_complex.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_blas1_complex.h (File already exists)'
else
echo 'x - extracting mv/include/mv_blas1_complex.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_blas1_complex.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
#ifndef _MV_BLAS1_complex_H_
#define _MV_BLAS1_complex_H_
X
#include <math.h>
#include <stdlib.h>
X
X
MV_Vector_complex& operator*=(MV_Vector_complex &x, const complex &a);
MV_Vector_complex operator*(const complex &a, const MV_Vector_complex &x);
MV_Vector_complex operator*(const MV_Vector_complex &x, const complex &a);
MV_Vector_complex operator+(const MV_Vector_complex &x, 
X    const MV_Vector_complex &y);
MV_Vector_complex operator-(const MV_Vector_complex &x, 
X    const MV_Vector_complex &y);
MV_Vector_complex& operator+=(MV_Vector_complex &x, const MV_Vector_complex &y);
MV_Vector_complex& operator-=(MV_Vector_complex &x, const MV_Vector_complex &y);
X
complex dot(const MV_Vector_complex &x, const MV_Vector_complex &y);
complex norm(const MV_Vector_complex &x);
X
#endif
// _MV_BLAS1_complex_H_
SHAR_EOF
chmod 0660 mv/include/mv_blas1_complex.h ||
echo 'restore of mv/include/mv_blas1_complex.h failed'
Wc_c="`wc -c < 'mv/include/mv_blas1_complex.h'`"
test 918 -eq "$Wc_c" ||
	echo 'mv/include/mv_blas1_complex.h: original size 918, current size' "$Wc_c"
fi
# ============= mv/include/mv_blas1_double.h ==============
if test -f 'mv/include/mv_blas1_double.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_blas1_double.h (File already exists)'
else
echo 'x - extracting mv/include/mv_blas1_double.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_blas1_double.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
#ifndef _MV_BLAS1_double_H_
#define _MV_BLAS1_double_H_
X
#include <math.h>
#include <stdlib.h>
X
X
MV_Vector_double& operator*=(MV_Vector_double &x, const double &a);
MV_Vector_double operator*(const double &a, const MV_Vector_double &x);
MV_Vector_double operator*(const MV_Vector_double &x, const double &a);
MV_Vector_double operator+(const MV_Vector_double &x, 
X    const MV_Vector_double &y);
MV_Vector_double operator-(const MV_Vector_double &x, 
X    const MV_Vector_double &y);
MV_Vector_double& operator+=(MV_Vector_double &x, const MV_Vector_double &y);
MV_Vector_double& operator-=(MV_Vector_double &x, const MV_Vector_double &y);
X
double dot(const MV_Vector_double &x, const MV_Vector_double &y);
double norm(const MV_Vector_double &x);
X
#endif
// _MV_BLAS1_double_H_
SHAR_EOF
chmod 0660 mv/include/mv_blas1_double.h ||
echo 'restore of mv/include/mv_blas1_double.h failed'
Wc_c="`wc -c < 'mv/include/mv_blas1_double.h'`"
test 889 -eq "$Wc_c" ||
	echo 'mv/include/mv_blas1_double.h: original size 889, current size' "$Wc_c"
fi
# ============= mv/include/mv_blas1_float.h ==============
if test -f 'mv/include/mv_blas1_float.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_blas1_float.h (File already exists)'
else
echo 'x - extracting mv/include/mv_blas1_float.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_blas1_float.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
#ifndef _MV_BLAS1_float_H_
#define _MV_BLAS1_float_H_
X
#include <math.h>
#include <stdlib.h>
X
X
MV_Vector_float& operator*=(MV_Vector_float &x, const float &a);
MV_Vector_float operator*(const float &a, const MV_Vector_float &x);
MV_Vector_float operator*(const MV_Vector_float &x, const float &a);
MV_Vector_float operator+(const MV_Vector_float &x, 
X    const MV_Vector_float &y);
MV_Vector_float operator-(const MV_Vector_float &x, 
X    const MV_Vector_float &y);
MV_Vector_float& operator+=(MV_Vector_float &x, const MV_Vector_float &y);
MV_Vector_float& operator-=(MV_Vector_float &x, const MV_Vector_float &y);
X
float dot(const MV_Vector_float &x, const MV_Vector_float &y);
float norm(const MV_Vector_float &x);
X
#endif
// _MV_BLAS1_float_H_
SHAR_EOF
chmod 0660 mv/include/mv_blas1_float.h ||
echo 'restore of mv/include/mv_blas1_float.h failed'
Wc_c="`wc -c < 'mv/include/mv_blas1_float.h'`"
test 860 -eq "$Wc_c" ||
	echo 'mv/include/mv_blas1_float.h: original size 860, current size' "$Wc_c"
fi
# ============= mv/include/mv_blas1_int.h ==============
if test -f 'mv/include/mv_blas1_int.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_blas1_int.h (File already exists)'
else
echo 'x - extracting mv/include/mv_blas1_int.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_blas1_int.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
#ifndef _MV_BLAS1_int_H_
#define _MV_BLAS1_int_H_
X
#include <math.h>
#include <stdlib.h>
X
X
MV_Vector_int& operator*=(MV_Vector_int &x, const int &a);
MV_Vector_int operator*(const int &a, const MV_Vector_int &x);
MV_Vector_int operator*(const MV_Vector_int &x, const int &a);
MV_Vector_int operator+(const MV_Vector_int &x, 
X    const MV_Vector_int &y);
MV_Vector_int operator-(const MV_Vector_int &x, 
X    const MV_Vector_int &y);
MV_Vector_int& operator+=(MV_Vector_int &x, const MV_Vector_int &y);
MV_Vector_int& operator-=(MV_Vector_int &x, const MV_Vector_int &y);
X
int dot(const MV_Vector_int &x, const MV_Vector_int &y);
int norm(const MV_Vector_int &x);
X
#endif
// _MV_BLAS1_int_H_
SHAR_EOF
chmod 0660 mv/include/mv_blas1_int.h ||
echo 'restore of mv/include/mv_blas1_int.h failed'
Wc_c="`wc -c < 'mv/include/mv_blas1_int.h'`"
test 802 -eq "$Wc_c" ||
	echo 'mv/include/mv_blas1_int.h: original size 802, current size' "$Wc_c"
fi
# ============= mv/include/mv_blas1_type.h ==============
if test -f 'mv/include/mv_blas1_type.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_blas1_type.h (File already exists)'
else
echo 'x - extracting mv/include/mv_blas1_type.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_blas1_type.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
#ifndef _MV_BLAS1_TYPE_H_
#define _MV_BLAS1_TYPE_H_
X
#include <math.h>
#include <stdlib.h>
X
X
MV_Vector_TYPE& operator*=(MV_Vector_TYPE &x, const TYPE &a);
MV_Vector_TYPE operator*(const TYPE &a, const MV_Vector_TYPE &x);
MV_Vector_TYPE operator*(const MV_Vector_TYPE &x, const TYPE &a);
MV_Vector_TYPE operator+(const MV_Vector_TYPE &x, 
X    const MV_Vector_TYPE &y);
MV_Vector_TYPE operator-(const MV_Vector_TYPE &x, 
X    const MV_Vector_TYPE &y);
MV_Vector_TYPE& operator+=(MV_Vector_TYPE &x, const MV_Vector_TYPE &y);
MV_Vector_TYPE& operator-=(MV_Vector_TYPE &x, const MV_Vector_TYPE &y);
X
TYPE dot(const MV_Vector_TYPE &x, const MV_Vector_TYPE &y);
TYPE norm(const MV_Vector_TYPE &x);
X
#endif
// _MV_BLAS1_TYPE_H_
SHAR_EOF
chmod 0660 mv/include/mv_blas1_type.h ||
echo 'restore of mv/include/mv_blas1_type.h failed'
Wc_c="`wc -c < 'mv/include/mv_blas1_type.h'`"
test 831 -eq "$Wc_c" ||
	echo 'mv/include/mv_blas1_type.h: original size 831, current size' "$Wc_c"
fi
# ============= mv/include/mv_matrix.h ==============
if test -f 'mv/include/mv_matrix.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_matrix.h (File already exists)'
else
echo 'x - extracting mv/include/mv_matrix.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_matrix.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_matrix.h  : basic templated numerical matrix class, storage
//                  by columns (Fortran oriented.)
//
//
//
X
X
#ifndef _MV_MATRIX_H_
#define _MV_MATRIX_H_    
X
#include "mv_vector.h"
X
struct Matrix_ 
{
X    enum ref_type {  ref = 1 };
};
X
X
#include <iostream.h>       // for formatted printing of matrices
#ifdef MV_MATRIX_BOUNDS_CHECK
#   include <assert.h>
#endif
X
X
template <class TYPE>
class MV_ColMat
{                                                                      
X    private:                                                           
X           MV_Vector<TYPE> v_;
X           int dim0_;   // perferred to using dim_[2]. some compilers
X           int dim1_;   // refuse to initalize these in the constructor.
X           int lda_;
X           int ref_;   // true if this is declared as a reference vector,
X                        // i.e. it does not own the memory space, but 
X                        // rather it is a view to another vector or array.
X    public:                                                            
X                                                                       
X        /*::::::::::::::::::::::::::*/                                 
X        /* Constructors/Destructors */                                 
X        /*::::::::::::::::::::::::::*/                                 
X                                                                       
X            MV_ColMat();                             
X            MV_ColMat(unsigned int, unsigned int); 
X
X    // some compilers have difficulty with inlined 'for' statements.
X    MV_ColMat(unsigned int, unsigned int, const TYPE&);   
X
X    // usual copy by value
X    // (can't use default parameter lda=m, because m is not a constant...)
X    //
X    MV_ColMat(TYPE*, unsigned int m, unsigned int n);
X    MV_ColMat(TYPE*, unsigned int m, unsigned int n, unsigned int lda);
X
X    // the "reference" versions
X    //
X    //
X    MV_ColMat(TYPE*, unsigned int m, unsigned int n, Matrix_::ref_type i);
X    MV_ColMat(TYPE*, unsigned int m, unsigned int n, unsigned int lda,
X                Matrix_::ref_type i);
X
X    MV_ColMat(const MV_ColMat<TYPE>&); 
X    ~MV_ColMat();                              
X                                                                       
X        /*::::::::::::::::::::::::::::::::*/                           
X        /*  Indices and access operations */                           
X        /*::::::::::::::::::::::::::::::::*/                           
X                                                                       
X    inline TYPE&        operator()(unsigned int, unsigned int); 
X    inline const TYPE&  operator()(unsigned int, unsigned int) const; 
X    MV_ColMat<TYPE> operator()(const MV_VecIndex &I, const MV_VecIndex &J) ;
X    const MV_ColMat<TYPE> operator()(const MV_VecIndex &I, const MV_VecIndex &J) const;
X    unsigned int            size(int i) const; 
X    MV_ColMat<TYPE>&        newsize(unsigned int, unsigned int);
X    int ref() const { return ref_;}
X                                                                       
X        /*::::::::::::::*/                                             
X        /*  Assignment  */                                             
X        /*::::::::::::::*/                                             
X                                                                       
X    MV_ColMat<TYPE> & operator=(const MV_ColMat<TYPE>&);
X    MV_ColMat<TYPE> & operator=(const TYPE&);
X
X
X    friend ostream& operator<<(ostream &s, const MV_ColMat<TYPE> &A);
X
};                                                                     
X
X
X
template<class TYPE>
unsigned int MV_ColMat<TYPE>::size(int i) const 
{
X    if (i==0) return dim0_;
X    if (i==1) return dim1_;
X    else
X    {
X     cerr << "Called MV_ColMat::size(" << i << ")  must be 0 or 1 " << endl;
X     exit(1);
X    }
X
X    // never should be here, but many compilers warn about not
X    // returning a value
X    return 0;
}
X
// NOTE: null construct have ref_ flag turned OFF, otherwise, we can
//          never reset the size of matrix....
template <class TYPE>
MV_ColMat<TYPE>::MV_ColMat()  : v_(), dim0_(0), dim1_(0) , lda_(0), ref_(0){}
X                                                                
X
template <class TYPE>
MV_ColMat<TYPE>::MV_ColMat(unsigned int m, unsigned int n) : v_(m*n),
X        dim0_(m), dim1_(n), lda_(m), ref_(0) {}
X
template <class TYPE>
MV_ColMat<TYPE>::MV_ColMat(unsigned int m, unsigned int n, const TYPE &s) : v_(m*n),
X        dim0_(m), dim1_(n), lda_(m), ref_(0) 
{
X    operator=(s);
}
X
// operators and member functions
X
X
X
template <class TYPE>
inline TYPE& MV_ColMat<TYPE>::operator()(unsigned int i, unsigned int j)
{
#ifdef MV_MATRIX_BOUNDS_CHECK
X    assert(0<=i && i<size(0));
X    assert(0<=j && j<size(1));
#endif 
X    return v_(j*lda_ + i);      // could use indirect addressing
X                                // instead...
}
X
template <class TYPE>
inline const TYPE& MV_ColMat<TYPE>::operator()
X                    (unsigned int i, unsigned int j) const
{
#ifdef MV_MATRIX_BOUNDS_CHECK
X    assert(0<=i && i<size(0));
X    assert(0<=j && j<size(1));
#endif
X    return v_(j*lda_ + i);
}
X
X
template <class TYPE>
MV_ColMat<TYPE>& MV_ColMat<TYPE>::operator=(const TYPE & s) 
{
X    int M = size(0);
X    int N = size(1);
X
X    if (lda_ == M)      // if continuous, then just assign as a ?
X        v_ =  s;        // single long vector.
X
X    else
X    {
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X    //
X
X        MV_VecIndex I(0,M-1);
X        for (int j=0; j<N; j++)
X        {
X            v_(I) = s;
X            I += lda_;
X        }
X    }
X
X    return *this;
}
X
template <class TYPE>
MV_ColMat<TYPE>& MV_ColMat<TYPE>::newsize(unsigned int M, unsigned int N)
{
X    v_.newsize(M*N);
X    dim0_ = M;
X    dim1_ = N;
X    lda_ = M;
X
X    return *this;
}
X
template <class TYPE>
MV_ColMat<TYPE>& MV_ColMat<TYPE>::operator=(const MV_ColMat<TYPE> & m) 
{
X
X    int lM = dim0_;     // left hand arg  (this)
X    int lN = dim1_;
X
X    int rM = m.dim0_;   // right hand arg (m)
X    int rN = m.dim1_;
X
X
X    // if the left-hand side is a matrix reference, the we copy the
X    // elements of m *into* the region specfied by the reference.
X    // i.e. inject().
X
X    if (ref_)
X    {
X        // check conformance,       
X        if (lM != rM  || lN != rN)      
X        {
X            cerr << "MV_ColMatRef::operator=  non-conformant assignment.\n";
X            exit(1);
X        }
X    }
X    else
X    {
X        newsize(rM,rN);
X    }
X
X    // at this point the left hand and right hand sides are conformant
X
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X
X    // if both sides are contigous, then just copy as one vector
X    if ( lM == lda_ && rM == m.lda_)
X    {
X        MV_VecIndex I(0,rM*rN-1);
X        v_(I) = m.v_(I);
X    }
X    else
X    {
X        // slower way...
X
X        MV_VecIndex I(0,rM-1);
X        MV_VecIndex K(0,rM-1);
X        for (int j=0; j<rN; j++)
X        {
X            v_(I) = m.v_(K);
X            I += lda_;
X            K += m.lda_;
X        }
X    }
X
X    return *this;   
}
X
template <class TYPE>
MV_ColMat<TYPE>::MV_ColMat(const MV_ColMat<TYPE> & m) : 
X        v_(m.dim0_*m.dim1_), dim0_(m.dim0_),
X        dim1_(m.dim1_), ref_(0), lda_(m.dim0_)
{
X
X    int M = m.dim0_;
X    int N = m.dim1_;
X
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X
X    MV_VecIndex I(0,M-1);
X    MV_VecIndex K(0,M-1);
X    for (int j=0; j<N; j++)
X    {
X        v_(I) = m.v_(K);
X        I += lda_;
X        K += m.lda_;
X    }
}
X
X
template <class TYPE>
inline MV_ColMat<TYPE>::MV_ColMat(TYPE* d, unsigned int m, unsigned int n,
X        Matrix_::ref_type i ):
X            v_(d,m*n, MV_Vector_::ref), dim0_(m), dim1_(n), lda_(m), ref_(i) {}
X
template <class TYPE>
inline MV_ColMat<TYPE>::MV_ColMat(TYPE* d, unsigned int m, unsigned int n, 
X            unsigned int lda, Matrix_::ref_type i) : 
X            v_(d, lda*n, MV_Vector_::ref), dim0_(m), dim1_(n), lda_(lda), 
X            ref_(i) {}
X
template <class TYPE>
MV_ColMat<TYPE>::MV_ColMat(TYPE* d, unsigned int m, unsigned int n) :
X    v_(m*n), dim0_(m), dim1_(n), lda_(m), ref_(0)
{
X    int mn = m*n;
X
X    // d is contiguous, so just copy 1-d vector
X    for (int i=0; i< mn; i++)
X            v_[i] = d[i];
}
X
X
template <class TYPE>
MV_ColMat<TYPE>::MV_ColMat(TYPE* d, unsigned int m, unsigned int n, 
X        unsigned int lda) :
X    v_(m*n), dim0_(m), dim1_(n), lda_(lda), ref_(0)
{
X    for (int j=0; j< n; j++)
X        for (int i=0; i<m; i++)
X            operator()(i,j) = d[j*lda + i];   // could be made faster!!
}
X
X
template <class TYPE>
MV_ColMat<TYPE> MV_ColMat<TYPE>::operator()(const MV_VecIndex &I, const MV_VecIndex &J)
{
X    // check that index is not out of bounds
X    //
X    if (I.end() >= dim0_  || J.end() >= dim1_)
X    {
X        cerr << "Matrix index: (" << I.start() << ":" << I.end()  
X             << "," << J.start() << ":" << J.end()   
X             << ") not a subset of (0:" << dim0_ - 1 << ", 0:" 
X             << dim1_-1 << ") " << endl;
X        exit(1);
X    }
X
X    // this automatically returns a reference
X    // 
X    return MV_ColMat<TYPE>(&v_[J.start()*lda_ + I.start()], 
X            I.end() - I.start() + 1, 
X            J.end() - J.start() + 1, lda_, Matrix_::ref);
}
X
template <class TYPE>
const MV_ColMat<TYPE> MV_ColMat<TYPE>::operator()(const MV_VecIndex &I, 
X    const MV_VecIndex &J) const
{
X
X    cerr << "Const operator()(MV_VecIndex, MV_VecIndex) called " << endl;
X
X    // check that index is not out of bounds
X    //
X    if (I.end() >= dim0_  || J.end() >= dim1_)
X    {
X        cerr << "Matrix index: (" << I.start() << ":" << I.end()  
X             << "," << J.start() << ":" << J.end()   
X             << ") not a subset of (0:" << dim0_ - 1 << ", 0:" 
X             << dim1_-1 << ") " << endl;
X        exit(1);
X    }
X
X    // this automatically returns a reference.  we need to 
X    // "cast away" constness here, so the &v_[] arg will
X    // not cause a compiler error.
X    //
X    MV_ColMat<TYPE> *t =  (MV_ColMat<TYPE>*) this;
X    return MV_ColMat<TYPE>(&(t->v_[J.start()*lda_ + I.start()]), 
X            I.end() - I.start() + 1, 
X            J.end() - J.start() + 1, lda_, Matrix_::ref);
}
X
template <class TYPE>
MV_ColMat<TYPE>::~MV_ColMat() {}
X
template <class TYPE>
ostream&   operator<<(ostream& s, const MV_ColMat<TYPE>& V)
{
X    int M = V.size(0);
X    int N = V.size(1);
X
X    for (int i=0; i<M; i++)
X    {
X        for (int j=0; j<N; j++)
X            s << V(i,j) << " " ;
X        s << endl;
X    }
X    
X    return s;
}
X
X
#endif 
// _MV_MATRIX_H_
X
SHAR_EOF
chmod 0660 mv/include/mv_matrix.h ||
echo 'restore of mv/include/mv_matrix.h failed'
Wc_c="`wc -c < 'mv/include/mv_matrix.h'`"
test 10769 -eq "$Wc_c" ||
	echo 'mv/include/mv_matrix.h: original size 10769, current size' "$Wc_c"
fi
# ============= mv/include/mv_matrix_all.h ==============
if test -f 'mv/include/mv_matrix_all.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_matrix_all.h (File already exists)'
else
echo 'x - extracting mv/include/mv_matrix_all.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_matrix_all.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_matrix_all.h 
//
//      MV Matrix classes for double, float, int, and complex
//
X
#ifndef _MV_MATRIX_ALL_H_
#define _MV_MATRIX_ALL_H_    
X
#include "mv_matrix_ref.h"
#include "mv_matrix_double.h"
#include "mv_matrix_int.h"
#include "mv_matrix_float.h"
#include "mv_matrix_complex.h"
X
#endif
// _MV_MATRIX_ALL_H_
SHAR_EOF
chmod 0660 mv/include/mv_matrix_all.h ||
echo 'restore of mv/include/mv_matrix_all.h failed'
Wc_c="`wc -c < 'mv/include/mv_matrix_all.h'`"
test 439 -eq "$Wc_c" ||
	echo 'mv/include/mv_matrix_all.h: original size 439, current size' "$Wc_c"
fi
# ============= mv/include/mv_matrix_complex.h ==============
if test -f 'mv/include/mv_matrix_complex.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_matrix_complex.h (File already exists)'
else
echo 'x - extracting mv/include/mv_matrix_complex.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_matrix_complex.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_matrix.h  : basic templated numerical matrix class, storage
//                  by columns (Fortran oriented.)
//
//
//
X
X
#ifndef _MV_MATRIX_complex_H_
#define _MV_MATRIX_complex_H_    
X
#include "complex.h"
#include "mv_vector_complex.h"
#include "mv_matrix_ref.h"
X
X
X
#include <iostream.h>       // for formatted printing of matrices
#ifdef MV_MATRIX_BOUNDS_CHECK
#   include <assert.h>
#endif
X
X
class MV_ColMat_complex
{                                                                      
X    private:                                                           
X           MV_Vector_complex v_;
X           int dim0_;   // perferred to using dim_[2]. some compilers
X           int dim1_;   // refuse to initalize these in the constructor.
X           int lda_;
X           int ref_;   // true if this is declared as a reference vector,
X                        // i.e. it does not own the memory space, but 
X                        // rather it is a view to another vector or array.
X    public:                                                            
X                                                                       
X        /*::::::::::::::::::::::::::*/                                 
X        /* Constructors/Destructors */                                 
X        /*::::::::::::::::::::::::::*/                                 
X                                                                       
X            MV_ColMat_complex();                             
X            MV_ColMat_complex(unsigned int, unsigned int); 
X
X    // some compilers have difficulty with inlined 'for' statements.
X    MV_ColMat_complex(unsigned int, unsigned int, const complex&);   
X
X    // usual copy by value
X    // (can't use default parameter lda=m, because m is not a constant...)
X    //
X    MV_ColMat_complex(complex*, unsigned int m, unsigned int n);
X    MV_ColMat_complex(complex*, unsigned int m, unsigned int n, unsigned int lda);
X
X    // the "reference" versions
X    //
X    //
X    MV_ColMat_complex(complex*, unsigned int m, unsigned int n, MV_Matrix_::ref_type i);
X    MV_ColMat_complex(complex*, unsigned int m, unsigned int n, unsigned int lda,
X                MV_Matrix_::ref_type i);
X
X    MV_ColMat_complex(const MV_ColMat_complex&); 
X    ~MV_ColMat_complex();                              
X                                                                       
X        /*::::::::::::::::::::::::::::::::*/                           
X        /*  Indices and access operations */                           
X        /*::::::::::::::::::::::::::::::::*/                           
X                                                                       
X    inline complex&     operator()(unsigned int, unsigned int); 
X    inline const complex&   operator()(unsigned int, unsigned int) const; 
X    MV_ColMat_complex operator()(const MV_VecIndex &I, const MV_VecIndex &J) ;
X    const MV_ColMat_complex operator()(const MV_VecIndex &I, const MV_VecIndex &J) const;
X    unsigned int            size(int i) const; 
X    MV_ColMat_complex&      newsize(unsigned int, unsigned int);
X    int ref() const { return ref_;}
X                                                                       
X        /*::::::::::::::*/                                             
X        /*  Assignment  */                                             
X        /*::::::::::::::*/                                             
X                                                                       
X    MV_ColMat_complex & operator=(const MV_ColMat_complex&);
X    MV_ColMat_complex & operator=(const complex&);
X
X
X    friend ostream& operator<<(ostream &s, const MV_ColMat_complex &A);
X
};                                                                     
X
inline complex& MV_ColMat_complex::operator()(unsigned int i, unsigned int j)
{
#ifdef MV_MATRIX_BOUNDS_CHECK
X    assert(0<=i && i<size(0));
X    assert(0<=j && j<size(1));
#endif
X    return v_(j*lda_ + i);      // could use indirect addressing
X                                // instead...
}
X
inline const complex& MV_ColMat_complex::operator()
X                    (unsigned int i, unsigned int j) const
{
#ifdef MV_MATRIX_BOUNDS_CHECK
X    assert(0<=i && i<size(0));
X    assert(0<=j && j<size(1));
#endif
X    return v_(j*lda_ + i);
}
X
inline MV_ColMat_complex::MV_ColMat_complex(complex* d, unsigned int m, unsigned int n,
X        MV_Matrix_::ref_type i ):
X            v_(d,m*n, MV_Vector_::ref), dim0_(m), dim1_(n), lda_(m), ref_(i) {}
X 
inline MV_ColMat_complex::MV_ColMat_complex(complex* d, unsigned int m, unsigned int n,
X            unsigned int lda, MV_Matrix_::ref_type i) :
X            v_(d, lda*n, MV_Vector_::ref), dim0_(m), dim1_(n), lda_(lda),
X            ref_(i) {}
X
#endif
X
SHAR_EOF
chmod 0660 mv/include/mv_matrix_complex.h ||
echo 'restore of mv/include/mv_matrix_complex.h failed'
Wc_c="`wc -c < 'mv/include/mv_matrix_complex.h'`"
test 4853 -eq "$Wc_c" ||
	echo 'mv/include/mv_matrix_complex.h: original size 4853, current size' "$Wc_c"
fi
# ============= mv/include/mv_matrix_double.h ==============
if test -f 'mv/include/mv_matrix_double.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_matrix_double.h (File already exists)'
else
echo 'x - extracting mv/include/mv_matrix_double.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_matrix_double.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_matrix.h  : basic templated numerical matrix class, storage
//                  by columns (Fortran oriented.)
//
//
//
X
X
#ifndef _MV_MATRIX_double_H_
#define _MV_MATRIX_double_H_    
X
#include "mv_vector_double.h"
#include "mv_matrix_ref.h"
X
X
X
#include <iostream.h>       // for formatted printing of matrices
#ifdef MV_MATRIX_BOUNDS_CHECK
#   include <assert.h>
#endif
X
X
class MV_ColMat_double
{                                                                      
X    private:                                                           
X           MV_Vector_double v_;
X           int dim0_;   // perferred to using dim_[2]. some compilers
X           int dim1_;   // refuse to initalize these in the constructor.
X           int lda_;
X           int ref_;   // true if this is declared as a reference vector,
X                        // i.e. it does not own the memory space, but 
X                        // rather it is a view to another vector or array.
X    public:                                                            
X                                                                       
X        /*::::::::::::::::::::::::::*/                                 
X        /* Constructors/Destructors */                                 
X        /*::::::::::::::::::::::::::*/                                 
X                                                                       
X            MV_ColMat_double();                             
X            MV_ColMat_double(unsigned int, unsigned int); 
X
X    // some compilers have difficulty with inlined 'for' statements.
X    MV_ColMat_double(unsigned int, unsigned int, const double&);   
X
X    // usual copy by value
X    // (can't use default parameter lda=m, because m is not a constant...)
X    //
X    MV_ColMat_double(double*, unsigned int m, unsigned int n);
X    MV_ColMat_double(double*, unsigned int m, unsigned int n, unsigned int lda);
X
X    // the "reference" versions
X    //
X    //
X    MV_ColMat_double(double*, unsigned int m, unsigned int n, MV_Matrix_::ref_type i);
X    MV_ColMat_double(double*, unsigned int m, unsigned int n, unsigned int lda,
X                MV_Matrix_::ref_type i);
X
X    MV_ColMat_double(const MV_ColMat_double&); 
X    ~MV_ColMat_double();                              
X                                                                       
X        /*::::::::::::::::::::::::::::::::*/                           
X        /*  Indices and access operations */                           
X        /*::::::::::::::::::::::::::::::::*/                           
X                                                                       
X    inline double&      operator()(unsigned int, unsigned int); 
X    inline const double&    operator()(unsigned int, unsigned int) const; 
X    MV_ColMat_double operator()(const MV_VecIndex &I, const MV_VecIndex &J) ;
X    const MV_ColMat_double operator()(const MV_VecIndex &I, const MV_VecIndex &J) const;
X    unsigned int            size(int i) const; 
X    MV_ColMat_double&       newsize(unsigned int, unsigned int);
X    int ref() const { return ref_;}
X                                                                       
X        /*::::::::::::::*/                                             
X        /*  Assignment  */                                             
X        /*::::::::::::::*/                                             
X                                                                       
X    MV_ColMat_double & operator=(const MV_ColMat_double&);
X    MV_ColMat_double & operator=(const double&);
X
X
X    friend ostream& operator<<(ostream &s, const MV_ColMat_double &A);
X
};                                                                     
X
inline double& MV_ColMat_double::operator()(unsigned int i, unsigned int j)
{
#ifdef MV_MATRIX_BOUNDS_CHECK
X    assert(0<=i && i<size(0));
X    assert(0<=j && j<size(1));
#endif
X    return v_(j*lda_ + i);      // could use indirect addressing
X                                // instead...
}
X
inline const double& MV_ColMat_double::operator()
X                    (unsigned int i, unsigned int j) const
{
#ifdef MV_MATRIX_BOUNDS_CHECK
X    assert(0<=i && i<size(0));
X    assert(0<=j && j<size(1));
#endif
X    return v_(j*lda_ + i);
}
X
inline MV_ColMat_double::MV_ColMat_double(double* d, unsigned int m, unsigned int n,
X        MV_Matrix_::ref_type i ):
X            v_(d,m*n, MV_Vector_::ref), dim0_(m), dim1_(n), lda_(m), ref_(i) {}
X 
inline MV_ColMat_double::MV_ColMat_double(double* d, unsigned int m, unsigned int n,
X            unsigned int lda, MV_Matrix_::ref_type i) :
X            v_(d, lda*n, MV_Vector_::ref), dim0_(m), dim1_(n), lda_(lda),
X            ref_(i) {}
X
#endif
X
SHAR_EOF
chmod 0660 mv/include/mv_matrix_double.h ||
echo 'restore of mv/include/mv_matrix_double.h failed'
Wc_c="`wc -c < 'mv/include/mv_matrix_double.h'`"
test 4795 -eq "$Wc_c" ||
	echo 'mv/include/mv_matrix_double.h: original size 4795, current size' "$Wc_c"
fi
# ============= mv/include/mv_matrix_float.h ==============
if test -f 'mv/include/mv_matrix_float.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_matrix_float.h (File already exists)'
else
echo 'x - extracting mv/include/mv_matrix_float.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_matrix_float.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_matrix.h  : basic templated numerical matrix class, storage
//                  by columns (Fortran oriented.)
//
//
//
X
X
#ifndef _MV_MATRIX_float_H_
#define _MV_MATRIX_float_H_    
X
#include "mv_vector_float.h"
#include "mv_matrix_ref.h"
X
X
X
#include <iostream.h>       // for formatted printing of matrices
#ifdef MV_MATRIX_BOUNDS_CHECK
#   include <assert.h>
#endif
X
X
class MV_ColMat_float
{                                                                      
X    private:                                                           
X           MV_Vector_float v_;
X           int dim0_;   // perferred to using dim_[2]. some compilers
X           int dim1_;   // refuse to initalize these in the constructor.
X           int lda_;
X           int ref_;   // true if this is declared as a reference vector,
X                        // i.e. it does not own the memory space, but 
X                        // rather it is a view to another vector or array.
X    public:                                                            
X                                                                       
X        /*::::::::::::::::::::::::::*/                                 
X        /* Constructors/Destructors */                                 
X        /*::::::::::::::::::::::::::*/                                 
X                                                                       
X            MV_ColMat_float();                             
X            MV_ColMat_float(unsigned int, unsigned int); 
X
X    // some compilers have difficulty with inlined 'for' statements.
X    MV_ColMat_float(unsigned int, unsigned int, const float&);   
X
X    // usual copy by value
X    // (can't use default parameter lda=m, because m is not a constant...)
X    //
X    MV_ColMat_float(float*, unsigned int m, unsigned int n);
X    MV_ColMat_float(float*, unsigned int m, unsigned int n, unsigned int lda);
X
X    // the "reference" versions
X    //
X    //
X    MV_ColMat_float(float*, unsigned int m, unsigned int n, MV_Matrix_::ref_type i);
X    MV_ColMat_float(float*, unsigned int m, unsigned int n, unsigned int lda,
X                MV_Matrix_::ref_type i);
X
X    MV_ColMat_float(const MV_ColMat_float&); 
X    ~MV_ColMat_float();                              
X                                                                       
X        /*::::::::::::::::::::::::::::::::*/                           
X        /*  Indices and access operations */                           
X        /*::::::::::::::::::::::::::::::::*/                           
X                                                                       
X    inline float&       operator()(unsigned int, unsigned int); 
X    inline const float& operator()(unsigned int, unsigned int) const; 
X    MV_ColMat_float operator()(const MV_VecIndex &I, const MV_VecIndex &J) ;
X    const MV_ColMat_float operator()(const MV_VecIndex &I, const MV_VecIndex &J) const;
X    unsigned int            size(int i) const; 
X    MV_ColMat_float&        newsize(unsigned int, unsigned int);
X    int ref() const { return ref_;}
X                                                                       
X        /*::::::::::::::*/                                             
X        /*  Assignment  */                                             
X        /*::::::::::::::*/                                             
X                                                                       
X    MV_ColMat_float & operator=(const MV_ColMat_float&);
X    MV_ColMat_float & operator=(const float&);
X
X
X    friend ostream& operator<<(ostream &s, const MV_ColMat_float &A);
X
};                                                                     
X
inline float& MV_ColMat_float::operator()(unsigned int i, unsigned int j)
{
#ifdef MV_MATRIX_BOUNDS_CHECK
X    assert(0<=i && i<size(0));
X    assert(0<=j && j<size(1));
#endif
X    return v_(j*lda_ + i);      // could use indirect addressing
X                                // instead...
}
X
inline const float& MV_ColMat_float::operator()
X                    (unsigned int i, unsigned int j) const
{
#ifdef MV_MATRIX_BOUNDS_CHECK
X    assert(0<=i && i<size(0));
X    assert(0<=j && j<size(1));
#endif
X    return v_(j*lda_ + i);
}
X
inline MV_ColMat_float::MV_ColMat_float(float* d, unsigned int m, unsigned int n,
X        MV_Matrix_::ref_type i ):
X            v_(d,m*n, MV_Vector_::ref), dim0_(m), dim1_(n), lda_(m), ref_(i) {}
X 
inline MV_ColMat_float::MV_ColMat_float(float* d, unsigned int m, unsigned int n,
X            unsigned int lda, MV_Matrix_::ref_type i) :
X            v_(d, lda*n, MV_Vector_::ref), dim0_(m), dim1_(n), lda_(lda),
X            ref_(i) {}
X
#endif
X
SHAR_EOF
chmod 0660 mv/include/mv_matrix_float.h ||
echo 'restore of mv/include/mv_matrix_float.h failed'
Wc_c="`wc -c < 'mv/include/mv_matrix_float.h'`"
test 4754 -eq "$Wc_c" ||
	echo 'mv/include/mv_matrix_float.h: original size 4754, current size' "$Wc_c"
fi
# ============= mv/include/mv_matrix_int.h ==============
if test -f 'mv/include/mv_matrix_int.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_matrix_int.h (File already exists)'
else
echo 'x - extracting mv/include/mv_matrix_int.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_matrix_int.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_matrix.h  : basic templated numerical matrix class, storage
//                  by columns (Fortran oriented.)
//
//
//
X
X
#ifndef _MV_MATRIX_int_H_
#define _MV_MATRIX_int_H_    
X
#include "mv_vector_int.h"
#include "mv_matrix_ref.h"
X
X
X
#include <iostream.h>       // for formatted printing of matrices
#ifdef MV_MATRIX_BOUNDS_CHECK
#   include <assert.h>
#endif
X
X
class MV_ColMat_int
{                                                                      
X    private:                                                           
X           MV_Vector_int v_;
X           int dim0_;   // perferred to using dim_[2]. some compilers
X           int dim1_;   // refuse to initalize these in the constructor.
X           int lda_;
X           int ref_;   // true if this is declared as a reference vector,
X                        // i.e. it does not own the memory space, but 
X                        // rather it is a view to another vector or array.
X    public:                                                            
X                                                                       
X        /*::::::::::::::::::::::::::*/                                 
X        /* Constructors/Destructors */                                 
X        /*::::::::::::::::::::::::::*/                                 
X                                                                       
X            MV_ColMat_int();                             
X            MV_ColMat_int(unsigned int, unsigned int); 
X
X    // some compilers have difficulty with inlined 'for' statements.
X    MV_ColMat_int(unsigned int, unsigned int, const int&);   
X
X    // usual copy by value
X    // (can't use default parameter lda=m, because m is not a constant...)
X    //
X    MV_ColMat_int(int*, unsigned int m, unsigned int n);
X    MV_ColMat_int(int*, unsigned int m, unsigned int n, unsigned int lda);
X
X    // the "reference" versions
X    //
X    //
X    MV_ColMat_int(int*, unsigned int m, unsigned int n, MV_Matrix_::ref_type i);
X    MV_ColMat_int(int*, unsigned int m, unsigned int n, unsigned int lda,
X                MV_Matrix_::ref_type i);
X
X    MV_ColMat_int(const MV_ColMat_int&); 
X    ~MV_ColMat_int();                              
X                                                                       
X        /*::::::::::::::::::::::::::::::::*/                           
X        /*  Indices and access operations */                           
X        /*::::::::::::::::::::::::::::::::*/                           
X                                                                       
X    inline int&     operator()(unsigned int, unsigned int); 
X    inline const int&   operator()(unsigned int, unsigned int) const; 
X    MV_ColMat_int operator()(const MV_VecIndex &I, const MV_VecIndex &J) ;
X    const MV_ColMat_int operator()(const MV_VecIndex &I, const MV_VecIndex &J) const;
X    unsigned int            size(int i) const; 
X    MV_ColMat_int&      newsize(unsigned int, unsigned int);
X    int ref() const { return ref_;}
X                                                                       
X        /*::::::::::::::*/                                             
X        /*  Assignment  */                                             
X        /*::::::::::::::*/                                             
X                                                                       
X    MV_ColMat_int & operator=(const MV_ColMat_int&);
X    MV_ColMat_int & operator=(const int&);
X
X
X    friend ostream& operator<<(ostream &s, const MV_ColMat_int &A);
X
};                                                                     
X
inline int& MV_ColMat_int::operator()(unsigned int i, unsigned int j)
{
#ifdef MV_MATRIX_BOUNDS_CHECK
X    assert(0<=i && i<size(0));
X    assert(0<=j && j<size(1));
#endif
X    return v_(j*lda_ + i);      // could use indirect addressing
X                                // instead...
}
X
inline const int& MV_ColMat_int::operator()
X                    (unsigned int i, unsigned int j) const
{
#ifdef MV_MATRIX_BOUNDS_CHECK
X    assert(0<=i && i<size(0));
X    assert(0<=j && j<size(1));
#endif
X    return v_(j*lda_ + i);
}
X
inline MV_ColMat_int::MV_ColMat_int(int* d, unsigned int m, unsigned int n,
X        MV_Matrix_::ref_type i ):
X            v_(d,m*n, MV_Vector_::ref), dim0_(m), dim1_(n), lda_(m), ref_(i) {}
X 
inline MV_ColMat_int::MV_ColMat_int(int* d, unsigned int m, unsigned int n,
X            unsigned int lda, MV_Matrix_::ref_type i) :
X            v_(d, lda*n, MV_Vector_::ref), dim0_(m), dim1_(n), lda_(lda),
X            ref_(i) {}
X
#endif
X
SHAR_EOF
chmod 0660 mv/include/mv_matrix_int.h ||
echo 'restore of mv/include/mv_matrix_int.h failed'
Wc_c="`wc -c < 'mv/include/mv_matrix_int.h'`"
test 4672 -eq "$Wc_c" ||
	echo 'mv/include/mv_matrix_int.h: original size 4672, current size' "$Wc_c"
fi
# ============= mv/include/mv_matrix_ref.h ==============
if test -f 'mv/include/mv_matrix_ref.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_matrix_ref.h (File already exists)'
else
echo 'x - extracting mv/include/mv_matrix_ref.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_matrix_ref.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
X
// this is really used as a sort of global constant. The reason
// for creating its own type is that so it can be overloaded to perform
// a deep or shallow assignement.  (Any variable of type MV_Matrix_::ref_type
// has only one possible value: one.)
X
#ifndef _MV_MATRIX_REF_
#define _MV_MATRIX_REF_
struct MV_Matrix_
{
X    enum ref_type  { ref = 1};
} ;
# endif
SHAR_EOF
chmod 0660 mv/include/mv_matrix_ref.h ||
echo 'restore of mv/include/mv_matrix_ref.h failed'
Wc_c="`wc -c < 'mv/include/mv_matrix_ref.h'`"
test 477 -eq "$Wc_c" ||
	echo 'mv/include/mv_matrix_ref.h: original size 477, current size' "$Wc_c"
fi
# ============= mv/include/mv_matrix_type.h ==============
if test -f 'mv/include/mv_matrix_type.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_matrix_type.h (File already exists)'
else
echo 'x - extracting mv/include/mv_matrix_type.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_matrix_type.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_matrix.h  : basic templated numerical matrix class, storage
//                  by columns (Fortran oriented.)
//
//
//
X
X
#ifndef _MV_MATRIX_TYPE_H_
#define _MV_MATRIX_TYPE_H_    
X
#include "mv_vector_TYPE.h"
#include "mv_matrix_ref.h"
X
X
X
#include <iostream.h>       // for formatted printing of matrices
#ifdef MV_MATRIX_BOUNDS_CHECK
#   include <assert.h>
#endif
X
X
class MV_ColMat_TYPE
{                                                                      
X    private:                                                           
X           MV_Vector_TYPE v_;
X           int dim0_;   // perferred to using dim_[2]. some compilers
X           int dim1_;   // refuse to initalize these in the constructor.
X           int lda_;
X           int ref_;   // true if this is declared as a reference vector,
X                        // i.e. it does not own the memory space, but 
X                        // rather it is a view to another vector or array.
X    public:                                                            
X                                                                       
X        /*::::::::::::::::::::::::::*/                                 
X        /* Constructors/Destructors */                                 
X        /*::::::::::::::::::::::::::*/                                 
X                                                                       
X            MV_ColMat_TYPE();                             
X            MV_ColMat_TYPE(unsigned int, unsigned int); 
X
X    // some compilers have difficulty with inlined 'for' statements.
X    MV_ColMat_TYPE(unsigned int, unsigned int, const TYPE&);   
X
X    // usual copy by value
X    // (can't use default parameter lda=m, because m is not a constant...)
X    //
X    MV_ColMat_TYPE(TYPE*, unsigned int m, unsigned int n);
X    MV_ColMat_TYPE(TYPE*, unsigned int m, unsigned int n, unsigned int lda);
X
X    // the "reference" versions
X    //
X    //
X    MV_ColMat_TYPE(TYPE*, unsigned int m, unsigned int n, MV_Matrix_::ref_type i);
X    MV_ColMat_TYPE(TYPE*, unsigned int m, unsigned int n, unsigned int lda,
X                MV_Matrix_::ref_type i);
X
X    MV_ColMat_TYPE(const MV_ColMat_TYPE&); 
X    ~MV_ColMat_TYPE();                              
X                                                                       
X        /*::::::::::::::::::::::::::::::::*/                           
X        /*  Indices and access operations */                           
X        /*::::::::::::::::::::::::::::::::*/                           
X                                                                       
X    inline TYPE&        operator()(unsigned int, unsigned int); 
X    inline const TYPE&  operator()(unsigned int, unsigned int) const; 
X    MV_ColMat_TYPE operator()(const MV_VecIndex &I, const MV_VecIndex &J) ;
X    const MV_ColMat_TYPE operator()(const MV_VecIndex &I, const MV_VecIndex &J) const;
X    unsigned int            size(int i) const; 
X    MV_ColMat_TYPE&         newsize(unsigned int, unsigned int);
X    int ref() const { return ref_;}
X                                                                       
X        /*::::::::::::::*/                                             
X        /*  Assignment  */                                             
X        /*::::::::::::::*/                                             
X                                                                       
X    MV_ColMat_TYPE & operator=(const MV_ColMat_TYPE&);
X    MV_ColMat_TYPE & operator=(const TYPE&);
X
X
X    friend ostream& operator<<(ostream &s, const MV_ColMat_TYPE &A);
X
};                                                                     
X
inline TYPE& MV_ColMat_TYPE::operator()(unsigned int i, unsigned int j)
{
#ifdef MV_MATRIX_BOUNDS_CHECK
X    assert(0<=i && i<size(0));
X    assert(0<=j && j<size(1));
#endif
X    return v_(j*lda_ + i);      // could use indirect addressing
X                                // instead...
}
X
inline const TYPE& MV_ColMat_TYPE::operator()
X                    (unsigned int i, unsigned int j) const
{
#ifdef MV_MATRIX_BOUNDS_CHECK
X    assert(0<=i && i<size(0));
X    assert(0<=j && j<size(1));
#endif
X    return v_(j*lda_ + i);
}
X
inline MV_ColMat_TYPE::MV_ColMat_TYPE(TYPE* d, unsigned int m, unsigned int n,
X        MV_Matrix_::ref_type i ):
X            v_(d,m*n, MV_Vector_::ref), dim0_(m), dim1_(n), lda_(m), ref_(i) {}
X 
inline MV_ColMat_TYPE::MV_ColMat_TYPE(TYPE* d, unsigned int m, unsigned int n,
X            unsigned int lda, MV_Matrix_::ref_type i) :
X            v_(d, lda*n, MV_Vector_::ref), dim0_(m), dim1_(n), lda_(lda),
X            ref_(i) {}
X
#endif
X
SHAR_EOF
chmod 0660 mv/include/mv_matrix_type.h ||
echo 'restore of mv/include/mv_matrix_type.h failed'
Wc_c="`wc -c < 'mv/include/mv_matrix_type.h'`"
test 4717 -eq "$Wc_c" ||
	echo 'mv/include/mv_matrix_type.h: original size 4717, current size' "$Wc_c"
fi
# ============= mv/include/mv_matrix_user_type.h ==============
if test -f 'mv/include/mv_matrix_user_type.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_matrix_user_type.h (File already exists)'
else
echo 'x - extracting mv/include/mv_matrix_user_type.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_matrix_user_type.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_matrix.h  : basic templated numerical matrix class, storage
//                  by columns (Fortran oriented.)
//
//
//
X
X
#ifndef _MV_MATRIX_TYPE_H_
#define _MV_MATRIX_TYPE_H_    
X
#include "CLASS_INCLUDE_FILENAME"
#include "mv_vector_TYPE.h"
#include "mv_matrix_ref.h"
X
X
X
#include <iostream.h>       // for formatted printing of matrices
#ifdef MV_MATRIX_BOUNDS_CHECK
#   include <assert.h>
#endif
X
X
class MV_ColMat_TYPE
{                                                                      
X    private:                                                           
X           MV_Vector_TYPE v_;
X           int dim0_;   // perferred to using dim_[2]. some compilers
X           int dim1_;   // refuse to initalize these in the constructor.
X           int lda_;
X           int ref_;   // true if this is declared as a reference vector,
X                        // i.e. it does not own the memory space, but 
X                        // rather it is a view to another vector or array.
X    public:                                                            
X                                                                       
X        /*::::::::::::::::::::::::::*/                                 
X        /* Constructors/Destructors */                                 
X        /*::::::::::::::::::::::::::*/                                 
X                                                                       
X            MV_ColMat_TYPE();                             
X            MV_ColMat_TYPE(unsigned int, unsigned int); 
X
X    // some compilers have difficulty with inlined 'for' statements.
X    MV_ColMat_TYPE(unsigned int, unsigned int, const TYPE&);   
X
X    // usual copy by value
X    // (can't use default parameter lda=m, because m is not a constant...)
X    //
X    MV_ColMat_TYPE(TYPE*, unsigned int m, unsigned int n);
X    MV_ColMat_TYPE(TYPE*, unsigned int m, unsigned int n, unsigned int lda);
X
X    // the "reference" versions
X    //
X    //
X    MV_ColMat_TYPE(TYPE*, unsigned int m, unsigned int n, MV_Matrix_::ref_type i);
X    MV_ColMat_TYPE(TYPE*, unsigned int m, unsigned int n, unsigned int lda,
X                MV_Matrix_::ref_type i);
X
X    MV_ColMat_TYPE(const MV_ColMat_TYPE&); 
X    ~MV_ColMat_TYPE();                              
X                                                                       
X        /*::::::::::::::::::::::::::::::::*/                           
X        /*  Indices and access operations */                           
X        /*::::::::::::::::::::::::::::::::*/                           
X                                                                       
X    inline TYPE&        operator()(unsigned int, unsigned int); 
X    inline const TYPE&  operator()(unsigned int, unsigned int) const; 
X    MV_ColMat_TYPE operator()(const MV_VecIndex &I, const MV_VecIndex &J) ;
X    const MV_ColMat_TYPE operator()(const MV_VecIndex &I, const MV_VecIndex &J) const;
X    unsigned int            size(int i) const; 
X    MV_ColMat_TYPE&         newsize(unsigned int, unsigned int);
X    int ref() const { return ref_;}
X                                                                       
X        /*::::::::::::::*/                                             
X        /*  Assignment  */                                             
X        /*::::::::::::::*/                                             
X                                                                       
X    MV_ColMat_TYPE & operator=(const MV_ColMat_TYPE&);
X    MV_ColMat_TYPE & operator=(const TYPE&);
X
X
X    friend ostream& operator<<(ostream &s, const MV_ColMat_TYPE &A);
X
};                                                                     
X
inline TYPE& MV_ColMat_TYPE::operator()(unsigned int i, unsigned int j)
{
#ifdef MV_MATRIX_BOUNDS_CHECK
X    assert(0<=i && i<size(0));
X    assert(0<=j && j<size(1));
#endif
X    return v_(j*lda_ + i);      // could use indirect addressing
X                                // instead...
}
X
inline const TYPE& MV_ColMat_TYPE::operator()
X                    (unsigned int i, unsigned int j) const
{
#ifdef MV_MATRIX_BOUNDS_CHECK
X    assert(0<=i && i<size(0));
X    assert(0<=j && j<size(1));
#endif
X    return v_(j*lda_ + i);
}
X
inline MV_ColMat_TYPE::MV_ColMat_TYPE(TYPE* d, unsigned int m, unsigned int n,
X        MV_Matrix_::ref_type i ):
X            v_(d,m*n, MV_Vector_::ref), dim0_(m), dim1_(n), lda_(m), ref_(i) {}
X 
inline MV_ColMat_TYPE::MV_ColMat_TYPE(TYPE* d, unsigned int m, unsigned int n,
X            unsigned int lda, MV_Matrix_::ref_type i) :
X            v_(d, lda*n, MV_Vector_::ref), dim0_(m), dim1_(n), lda_(lda),
X            ref_(i) {}
X
#endif
X
SHAR_EOF
chmod 0660 mv/include/mv_matrix_user_type.h ||
echo 'restore of mv/include/mv_matrix_user_type.h failed'
Wc_c="`wc -c < 'mv/include/mv_matrix_user_type.h'`"
test 4751 -eq "$Wc_c" ||
	echo 'mv/include/mv_matrix_user_type.h: original size 4751, current size' "$Wc_c"
fi
# ============= mv/include/mv_vecindex.h ==============
if test -f 'mv/include/mv_vecindex.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_vecindex.h (File already exists)'
else
echo 'x - extracting mv/include/mv_vecindex.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_vecindex.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_vecindex.h       MV_Vector Index class
X
#ifndef _MV_VEC_INDEX_H_
#define _MV_VEC_INDEX_H_
X
// A MV_VecIndex is an ordered pair (start,end) denoting a subvector
//  region, similar to a Fortran 90 or Matlab colon notation.  For example, 
//
//  MV_Vector<double> A(10), B(20);
//  MV_VecIndex I(2,4);
//
//  A(I) = B(MV_VecIndex(0,2); 
//
//  sets the thrid through fifth elements of A to the first two elements
//  of B.  There is no stride argument, only contiguous regions are allowed.
//
X
#include <assert.h>
X
class MV_VecIndex
{
X    private:
X            unsigned int start_;
X            unsigned int end_;       
X            char all_;      // true if this index refers to the complete
X                            // vector range.  start_ and end_ are ignored.
X    public:
X        MV_VecIndex() : start_(0), end_(0), all_(1) {}
X        MV_VecIndex(unsigned int i1) :start_(i1), end_(i1), all_(0) {}
X        MV_VecIndex(unsigned int i1, unsigned int i2): start_(i1), end_(i2),
X            all_(0)
X        {
X            assert(i1 <= i2);
X        }
X        MV_VecIndex(const MV_VecIndex &s) : start_(s.start_), end_(s.end_), 
X            all_(s.all_){}
X
X
X        int start() const { return (all_==1) ? 0 : start_;}
X        int end() const { return (all_ ==1) ? 0 : end_;}
X        int length() const { 
X            return (all_==1) ? 0 : (end_-start_+1);}
X        int all() const { return all_; }
X        MV_VecIndex& operator=(const MV_VecIndex& I)
X            { start_=I.start_; end_ = I.end_; return *this;}
X        MV_VecIndex operator+(int i)
X            { return MV_VecIndex(start_ +i, end_ +i); }
X        MV_VecIndex& operator+=(int i)
X            { start_ += i; end_ += i; return *this; }
X        MV_VecIndex operator-(int i)
X            { return MV_VecIndex(start_ -i, end_ -i); }
X        MV_VecIndex& operator-=(int i)
X            { start_ -= i; end_ -= i; return *this; }
X
};
X
X
#endif  
//  _INDEX_H_
X
SHAR_EOF
chmod 0660 mv/include/mv_vecindex.h ||
echo 'restore of mv/include/mv_vecindex.h failed'
Wc_c="`wc -c < 'mv/include/mv_vecindex.h'`"
test 2039 -eq "$Wc_c" ||
	echo 'mv/include/mv_vecindex.h: original size 2039, current size' "$Wc_c"
fi
# ============= mv/include/mv_vector.h ==============
if test -f 'mv/include/mv_vector.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_vector.h (File already exists)'
else
echo 'x - extracting mv/include/mv_vector.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_vector.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_vector.h     Basic templated vector class
//
X
#ifndef _MV_VECTOR_H_
#define _MV_VECTOR_H_    
X
//
//      Key features:
//
//    o efficient indexing as fast as native C arrays 
//    o supports only unit strides (for efficient indexing)
//    o templated data elements
//    o copy-by-value semantics
//    o optional "share" semantics allows vectors to be constructed as
//          "views", or "references" of an existing memory, using 
//          MV_Vector_::ref modifier in the constuctor.  (see note below.)
//    o vector views can assign and references sections of vector, but
//          cannot modify their *size*.
//    o block-range indexing via MV_VecIndex class (e.g. A(I) = B; )
//          (note for the above to work, A(I) must return a vector view.)
//    o optional range checking (compile switch)
//    o fast copying (A=B) via loop unrolling
//    o (experimental derived FMV_Vector class) for even faster copying via 
//          memcpy() for data elements employing simple bit-wise copying (e.g.
//          float, complex, et.c)
//    o support for both [] and () style indexing  ([] not available 
//          for matrices.)
//
//  NOTES:
//
//      o  O(N) loops for copying and assigning scalars to vectors unroll
//      loops to a depth of 4.  Thus on some machines, it is faster
//      to execute A=scalar, than to manually assign a native C
//      array using an explicit for loop:
//      
//          for (i=0; i<N; d[i++] = scalar);
//
//      o   function code for the () and [] operators has been 
//      inlined into the class declaration, for compilers
//      (e.g. Turbo C++ v. 3.0) that refuse to inline otherwise.
//
//      o  The MV_Vector(*TYPE, int len) constructor is now a deep-copy to
//      match the MV_Vector(const &MV_Vector) constructor.  To create a view
//      (share semantics) use
//
//          MV_Vector<double> A( &d[0], n, MV_Vector_::ref );
//
//      This allows one to construct vectors as views of any contiguous C
//      array.  It will not destruct the memory space when the vector
//      is destroyed or goes out of scope.
//
X
X                                 
X
X
X
#include <iostream.h>       // for formatted printing of matrices
#ifdef MV_VECTOR_BOUNDS_CHECK
#   include <assert.h>
#endif
X
#include "mv_vecindex.h"
#include "mv_vector_ref.h"
X
template <class TYPE>
class MV_Vector
{                                                                      
X    protected:                                                           
X           TYPE *p_;
X           unsigned int dim_;
X           int ref_;  // 0 or 1; does this own its own memory space?
X    public:                                                            
X
X
X        /*::::::::::::::::::::::::::*/                                 
X        /* Constructors/Destructors */                                 
X        /*::::::::::::::::::::::::::*/                                 
X                                                                       
X    MV_Vector();                             
X    MV_Vector(unsigned int);                             
X    MV_Vector(unsigned int, const TYPE&);   // can't be inlined because of 'for'
X                                       // statement.
X    MV_Vector(TYPE*, unsigned int);     // new copy
X    MV_Vector(const TYPE*, unsigned int);       // new copy ???
X    
X    // reference of an exisiting data structure
X    //
X    MV_Vector(TYPE*, unsigned int, MV_Vector_::ref_type i); 
X    MV_Vector(const MV_Vector<TYPE>&); 
X    ~MV_Vector();                              
X                                                                       
X        /*::::::::::::::::::::::::::::::::*/                           
X        /*  Indices and access operations */                           
X        /*::::::::::::::::::::::::::::::::*/                           
X                                                                       
X
X    // code for operator() is defined here, otherwise some compilers 
X    // (e.g. Turbo C++ v 3.0) cannot inline them properly...
X    //
X    inline            TYPE&     operator()(unsigned int i)
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X    inline  const  TYPE&    operator()(unsigned int i) const 
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X
X    inline        TYPE&     operator[](unsigned int i)
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X    inline      const  TYPE&    operator[](unsigned int i) const 
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X
X
X
X    inline MV_Vector<TYPE> operator()(const MV_VecIndex &I) ;
X    inline MV_Vector<TYPE> operator()(void);
X    inline const MV_Vector<TYPE> operator()(void) const;
X    inline const MV_Vector<TYPE> operator()(const MV_VecIndex &I) const;
//
//   the following line causes ambiguatities with template instantiations
//   should be avoid.  Used &v(0) explicitly when converting to TYPE*.
//
//    inline                operator const  TYPE*() const {return p_;} 
X    inline unsigned int             size() const { return dim_;}
X    inline int                      ref() const { return  ref_;}
X    inline int                      null() const {return dim_== 0;}
X            //
X            // Create a new *uninitalized* vector of size N
X            MV_Vector<TYPE> & newsize(unsigned int );
X                                                                       
X        /*::::::::::::::*/                                             
X        /*  Assignment  */                                             
X        /*::::::::::::::*/                                             
X                                                                       
X            MV_Vector<TYPE> & operator=(const MV_Vector<TYPE>&);
X            MV_Vector<TYPE> & operator=(const TYPE&);
X
X
X    friend ostream& operator<<(ostream &s, const MV_Vector<TYPE> &A);
X
};                                                                     
X
X    
template <class TYPE>
MV_Vector<TYPE>::MV_Vector()  : p_(0), dim_(0) , ref_(0){};
X
template <class TYPE>
MV_Vector<TYPE>::MV_Vector(unsigned int n) : p_(new TYPE[n]), dim_(n), 
X            ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: NULL pointer in MV_Vector(int) constructor " << endl;
X        cerr << "       Most likely out of memory... " << endl;
X        exit(1);
X    }
}
X
template <class TYPE>
MV_Vector<TYPE>::MV_Vector(unsigned int n, const TYPE& v) : 
X        p_(new TYPE[n]), dim_(n), ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: NULL pointer in MV_Vector(int) constructor " << endl;
X        cerr << "       Most likely out of memory... " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = v;
}
X
// operators and member functions
//
X
X
X
X
template <class TYPE>
MV_Vector<TYPE>& MV_Vector<TYPE>::operator=(const TYPE & m) 
{
#ifdef TRACE_VEC
X    cout << "> MV_Vector<TYPE>::operator=(const TYPE & m)  " << endl;
#endif
X
X    // unroll loops to depth of length 4
X
X    int N = size();
X
X    int Nminus4 = N-4;
X    int i;
X
X    for (i=0; i<Nminus4; )
X    {
X        p_[i++] = m;
X        p_[i++] = m;
X        p_[i++] = m;
X        p_[i++] = m;
X    }
X
X    for (; i<N; p_[i++] = m);   // finish off last piece...
X
#ifdef TRACE_VEC
X    cout << "< MV_Vector<TYPE>::operator=(const TYPE & m)  " << endl;
#endif
X    return *this;
}
X
template <class TYPE>
MV_Vector<TYPE>& MV_Vector<TYPE>::newsize(unsigned int n)
{
#ifdef TRACE_VEC
X    cout << "> MV_Vector<TYPE>::newsize(unsigned int n) " << endl;
#endif
X    if (ref_ )                  // is this structure just a pointer?
X    {
X        {
X            cerr << "MV_Vector::newsize can't operator on references.\n";
X            exit(1);
X        }
X    }
X    else
X    if (dim_ != n )                     // only delete and new if
X    {                                   // the size of memory is really
X        if (p_) delete [] p_;           // changing, otherwise just
X        p_ = new TYPE[n];               // copy in place.
X        if (p_ == NULL)
X        {
X            cerr << "Error : NULL pointer in operator= " << endl;
X            exit(1);
X        }
X        dim_ = n;
X    }
X
#ifdef TRACE_VEC
X    cout << "< MV_Vector<TYPE>::newsize(unsigned int n) " << endl;
#endif
X
X    return *this;
}
X
X
X    
X
template <class TYPE>
MV_Vector<TYPE>& MV_Vector<TYPE>::operator=(const MV_Vector<TYPE> & m) 
{
X
X    int N = m.dim_;
X    int i;
X
X    if (ref_ )                  // is this structure just a pointer?
X    {
X        if (dim_ != m.dim_)     // check conformance,
X        {
X            cerr << "MV_VectorRef::operator=  non-conformant assignment.\n";
X            exit(1);
X        }
X
X        // handle overlapping matrix references
X        if ((m.p_ + m.dim_) >= p_)
X        {
X            // overlap case, copy backwards to avoid overwriting results
X            for (i= N-1; i>=0; i--)
X                p_[i] = m.p_[i];
X        }
X        else
X        {
X            for (i=0; i<N; i++)
X                p_[i] = m.p_[i];
X        }
X                
X    }
X    else
X    {
X        newsize(N);
X
X        // no need to test for overlap, since this region is new
X        for (i =0; i< N; i++)       // careful not to use bcopy()
X            p_[i] = m.p_[i];                // here, but TYPE::operator= TYPE.
X    }
X    return *this;   
}
X
template <class TYPE>
MV_Vector<TYPE>::MV_Vector(const MV_Vector<TYPE> & m) : p_(new TYPE[m.dim_]), 
X    dim_(m.dim_) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error:  Null pointer in MV_Vector(const MV_Vector&); " << endl;
X        exit(1);
X    }
X
X    int N = m.dim_;
X
X    for (int i=0; i<N; i++)
X        p_[i] = m.p_[i];
}
X
// note that ref() is initalized with i rather than 1.
// this is so compilers will not generate a warning that i was
// not used in the construction.  (MV_Vector::ref_type is an enum that
// can *only* have the value of 1.
//
template <class TYPE>
MV_Vector<TYPE>::MV_Vector(TYPE* d, unsigned int n, MV_Vector_::ref_type i) : 
X        p_(d), dim_(n) , ref_(i) {}
X
template <class TYPE>
MV_Vector<TYPE>::MV_Vector(TYPE* d, unsigned int n) : p_(new TYPE[n]), 
X      dim_(n) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: Null pointer in MV_Vector(TYPE*, int) " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = d[i];
X
}
X
X
template <class TYPE>
MV_Vector<TYPE>::MV_Vector(const TYPE* d, unsigned int n) : p_(new TYPE[n]), 
X      dim_(n) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: Null pointer in MV_Vector(TYPE*, int) " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = d[i];
X
}
X
template <class TYPE>
MV_Vector<TYPE> MV_Vector<TYPE>::operator()(void)
{
X    return MV_Vector<TYPE>(p_, dim_, MV_Vector_::ref);
}
X
template <class TYPE>
const MV_Vector<TYPE> MV_Vector<TYPE>::operator()(void) const
{
X    return MV_Vector<TYPE>(p_, dim_, MV_Vector_::ref);
}
X
template <class TYPE>
MV_Vector<TYPE> MV_Vector<TYPE>::operator()(const MV_VecIndex &I) 
{
X    // default parameters
X    if (I.all())
X        return MV_Vector<TYPE>(p_, dim_, MV_Vector_::ref);
X    else
X    {
X    // check that index is not out of bounds
X    //
X        if ( I.end() >= dim_)
X        {
X            cerr << "MV_VecIndex: (" << I.start() << ":" << I.end() << 
X                ") too big for matrix (0:" << dim_ - 1 << ") " << endl;
X            exit(1);
X        }
X        return MV_Vector<TYPE>(p_+ I.start(), I.end() - I.start() + 1,
X            MV_Vector_::ref);
X    }
}
X
template <class TYPE>
const MV_Vector<TYPE> MV_Vector<TYPE>::operator()(const MV_VecIndex &I) const
{
X    // check that index is not out of bounds
X    //
X    if ( I.end() >= dim_)
X    {
X        cerr << "MV_VecIndex: (" << I.start() << ":" << I.end() << 
X                ") too big for matrix (0:" << dim_ - 1 << ") " << endl;
X        exit(1);
X    }
X    return MV_Vector<TYPE>(p_+ I.start(), I.end() - I.start() + 1,
X            MV_Vector_::ref);
}
X
template <class TYPE>
MV_Vector<TYPE>::~MV_Vector()
{
X        if (p_ && !ref_ ) delete [] p_;
}
X
template <class TYPE>
ostream&   operator<<(ostream& s, const MV_Vector<TYPE>& V)
{
X    int N = V.size();
X
X    for (int i=0; i< N; i++)
X        s << V(i) << endl;
X    
X    return s;
}
X
X
template <class TYPE>
class FMV_Vector : public MV_Vector<TYPE>
{                                                                      
X    public:                                                            
X        FMV_Vector(unsigned int n) : MV_Vector<TYPE>(n) {}
X        FMV_Vector<TYPE>& operator=(const FMV_Vector<TYPE>& m);
X        FMV_Vector<TYPE>& operator=(const TYPE& m);
};
X
template <class TYPE>
FMV_Vector<TYPE>& FMV_Vector<TYPE>::operator=( const FMV_Vector<TYPE>& m)
{
X
#ifdef TRACE_VEC
X    cout << "> FMV_Vector<TYPE>::operator=( const FMV_Vector<TYPE>& m)" << endl;
#endif
X
X    int N = m.dim_;
X
X
X
X    if (ref_ )                  // is this structure just a pointer?
X    {
X        if (dim_ != m.dim_)     // check conformance,
X        {
X            cerr << "MV_VectorRef::operator=  non-conformant assignment.\n";
X            exit(1);
X        }
X    }
X    else if ( dim_ != m.dim_ )      // resize only if necessary
X        newsize(N);
X
X    memmove(p_, m.p_, N * sizeof(TYPE));
X
#ifdef TRACE_VEC
X    cout << "< FMV_Vector<TYPE>::operator=( const FMV_Vector<TYPE>& m)" << endl;
#endif
X
X    return *this;   
}
X
template <class TYPE>
FMV_Vector<TYPE>& FMV_Vector<TYPE>::operator=(const TYPE & m) 
{
#ifdef TRACE_VEC
X    cout << "> FMV_Vector<TYPE>::operator=(const TYPE & m)  " << endl;
#endif
X
X    // unroll loops to depth of length 4
X
X    int N = size();
X
X    int Nminus4 = N-4;
X    int i;
X
X    for (i=0; i<Nminus4; )
X    {
X        p_[i++] = m;
X        p_[i++] = m;
X        p_[i++] = m;
X        p_[i++] = m;
X    }
X
X    for (; i<N; p_[i++] = m);   // finish off last piece...
X
#ifdef TRACE_VEC
X    cout << "< FMV_Vector<TYPE>::operator=(const TYPE & m)  " << endl;
#endif
X    return *this;
}
X
#include "mv_blas1.h"
X
#endif 
// _MV_VECTOR_H_
X
SHAR_EOF
chmod 0660 mv/include/mv_vector.h ||
echo 'restore of mv/include/mv_vector.h failed'
Wc_c="`wc -c < 'mv/include/mv_vector.h'`"
test 14554 -eq "$Wc_c" ||
	echo 'mv/include/mv_vector.h: original size 14554, current size' "$Wc_c"
fi
# ============= mv/include/mv_vector_all.h ==============
if test -f 'mv/include/mv_vector_all.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_vector_all.h (File already exists)'
else
echo 'x - extracting mv/include/mv_vector_all.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_vector_all.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_vector_all.h 
//
//                  MV vector classes for double, float, int, and complex
//
X
#ifndef _MV_VECTOR_ALL_H_
#define _MV_VECTOR_ALL_H_    
X
#include "mv_vector_ref.h"
#include "mv_vector_double.h"
#include "mv_vector_int.h"
#include "mv_vector_float.h"
#include "mv_vector_complex.h"
X
#endif
// _MV_VECTOR_ALL_H_
SHAR_EOF
chmod 0660 mv/include/mv_vector_all.h ||
echo 'restore of mv/include/mv_vector_all.h failed'
Wc_c="`wc -c < 'mv/include/mv_vector_all.h'`"
test 451 -eq "$Wc_c" ||
	echo 'mv/include/mv_vector_all.h: original size 451, current size' "$Wc_c"
fi
# ============= mv/include/mv_vector_complex.h ==============
if test -f 'mv/include/mv_vector_complex.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_vector_complex.h (File already exists)'
else
echo 'x - extracting mv/include/mv_vector_complex.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_vector_complex.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_vector_complex.h     Basic vector class (complex precision)
//
X
#ifndef _MV_VECTOR_complex_H
#define _MV_VECTOR_complex_H    
X
//
//      Key features:
//
//    o efficient indexing as fast as native C arrays 
//    o supports only unit strides (for efficient indexing)
//    o copy-by-value semantics
//    o optional "share" semantics allows vectors to be constructed as
//          "views", or "references" of an existing memory, using 
//          MV_Vector_::ref modifier in the constuctor.  (see note below.)
//    o vector views can assign and references sections of vector, but
//          cannot modify their *size*.
//    o block-range indexing via MV_VecIndex class (e.g. A(I) = B; )
//          (note for the above to work, A(I) must return a vector view.)
//    o optional range checking (compile switch)
//    o fast copying (A=B) via loop unrolling
//    o (experimental derived FMV_Vector class) for even faster copying via 
//          memcpy() for data elements employing simple bit-wise copying (e.g.
//          float, complex, et.c)
//    o support for both [] and () style indexing  ([] not available 
//          for matrices.)
//
//  NOTES:
//
//      o  O(N) loops for copying and assigning scalars to vectors unroll
//      loops to a depth of 4.  Thus on some machines, it is faster
//      to execute A=scalar, than to manually assign a native C
//      array using an explicit for loop:
//      
//          for (i=0; i<N; d[i++] = scalar);
//
//      o   function code for the () and [] operators has been 
//      inlined into the class declaration, for compilers
//      (e.g. Turbo C++ v. 3.0) that refuse to inline otherwise.
//
//      o  The MV_Vector(*complex, int len) constructor is now a deep-copy to
//      match the MV_Vector(const &MV_Vector) constructor.  To create a view
//      (share semantics) use
//
//          MV_Vector_complex A( &d[0], n, MV_Vector_::ref );
//
//      This allows one to construct vectors as views of any contiguous C
//      array.  It will not destruct the memory space when the vector
//      is destroyed or goes out of scope.
//
X
X                                 
X
X
X
#include <iostream.h>       // for formatted printing of matrices
X
#ifdef MV_VECTOR_BOUNDS_CHECK
#   include <assert.h>
#endif
X
#include "complex.h"
#include "mv_vecindex.h"
X
// this is really used as a sort of global constant. The reason
// for creating its own type is that so it can be overloaded to perform
// a deep or shallow assignement.  (Any variable of type MV_Vector_::ref_type
// has only one possible value: one.)
X
#include "mv_vector_ref.h"
X
class MV_Vector_complex
{                                                                      
X    protected:                                                           
X           complex *p_;
X           unsigned int dim_;
X           int ref_;  // 0 or 1; does this own its own memory space?
X    public:                                                            
X
X
X        /*::::::::::::::::::::::::::*/                                 
X        /* Constructors/Destructors */                                 
X        /*::::::::::::::::::::::::::*/                                 
X                                                                       
X    MV_Vector_complex();                             
X    MV_Vector_complex(unsigned int);                             
X    MV_Vector_complex(unsigned int, const complex&);   // can't be inlined 
X                                                     //because of 'for'
X                                                    // statement.
X    MV_Vector_complex(complex*, unsigned int);      // new copy
X    MV_Vector_complex(const complex*, unsigned int);        // new copy ???
X    
X    // reference of an exisiting data structure
X    //
X    MV_Vector_complex(complex*, unsigned int, MV_Vector_::ref_type i);  
X    MV_Vector_complex(const MV_Vector_complex &); 
X    ~MV_Vector_complex();                              
X                                                                       
X        /*::::::::::::::::::::::::::::::::*/                           
X        /*  Indices and access operations */                           
X        /*::::::::::::::::::::::::::::::::*/                           
X                                                                       
X
X    // code for operator() is defined here, otherwise some compilers 
X    // (e.g. Turbo C++ v 3.0) cannot inline them properly...
X    //
X    complex&        operator()(unsigned int i)
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X    const  complex&     operator()(unsigned int i) const 
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X
X    complex&        operator[](unsigned int i)
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X    const  complex&     operator[](unsigned int i) const 
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X
X
X
X    MV_Vector_complex operator()(const MV_VecIndex &I) ;
X    MV_Vector_complex operator()(void);
X    const MV_Vector_complex operator()(void) const;
X    const MV_Vector_complex operator()(const MV_VecIndex &I) const;
//
//   the following line causes ambiguatities with template instantiations
//   should be avoid.  Used &v(0) explicitly when converting to complex*.
//
//    inline                operator const  complex*() const {return p_;} 
X    inline unsigned int             size() const { return dim_;}
X    inline int                      ref() const { return  ref_;}
X    inline int                      null() const {return dim_== 0;}
X            //
X            // Create a new *uninitalized* vector of size N
X            MV_Vector_complex & newsize(unsigned int );
X                                                                       
X        /*::::::::::::::*/                                             
X        /*  Assignment  */                                             
X        /*::::::::::::::*/                                             
X                                                                       
X            MV_Vector_complex & operator=(const MV_Vector_complex&);
X            MV_Vector_complex & operator=(const complex&);
X
X
X    friend ostream& operator<<(ostream &s, const MV_Vector_complex &A);
X
};                                                                     
X
#include "mv_blas1_complex.h"
X
#endif  
SHAR_EOF
chmod 0660 mv/include/mv_vector_complex.h ||
echo 'restore of mv/include/mv_vector_complex.h failed'
Wc_c="`wc -c < 'mv/include/mv_vector_complex.h'`"
test 7007 -eq "$Wc_c" ||
	echo 'mv/include/mv_vector_complex.h: original size 7007, current size' "$Wc_c"
fi
# ============= mv/include/mv_vector_double.h ==============
if test -f 'mv/include/mv_vector_double.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_vector_double.h (File already exists)'
else
echo 'x - extracting mv/include/mv_vector_double.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_vector_double.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_vector_double.h      Basic vector class (double precision)
//
X
#ifndef _MV_VECTOR_double_H
#define _MV_VECTOR_double_H    
X
//
//      Key features:
//
//    o efficient indexing as fast as native C arrays 
//    o supports only unit strides (for efficient indexing)
//    o copy-by-value semantics
//    o optional "share" semantics allows vectors to be constructed as
//          "views", or "references" of an existing memory, using 
//          MV_Vector_::ref modifier in the constuctor.  (see note below.)
//    o vector views can assign and references sections of vector, but
//          cannot modify their *size*.
//    o block-range indexing via MV_VecIndex class (e.g. A(I) = B; )
//          (note for the above to work, A(I) must return a vector view.)
//    o optional range checking (compile switch)
//    o fast copying (A=B) via loop unrolling
//    o (experimental derived FMV_Vector class) for even faster copying via 
//          memcpy() for data elements employing simple bit-wise copying (e.g.
//          float, complex, et.c)
//    o support for both [] and () style indexing  ([] not available 
//          for matrices.)
//
//  NOTES:
//
//      o  O(N) loops for copying and assigning scalars to vectors unroll
//      loops to a depth of 4.  Thus on some machines, it is faster
//      to execute A=scalar, than to manually assign a native C
//      array using an explicit for loop:
//      
//          for (i=0; i<N; d[i++] = scalar);
//
//      o   function code for the () and [] operators has been 
//      inlined into the class declaration, for compilers
//      (e.g. Turbo C++ v. 3.0) that refuse to inline otherwise.
//
//      o  The MV_Vector(*double, int len) constructor is now a deep-copy to
//      match the MV_Vector(const &MV_Vector) constructor.  To create a view
//      (share semantics) use
//
//          MV_Vector_double A( &d[0], n, MV_Vector_::ref );
//
//      This allows one to construct vectors as views of any contiguous C
//      array.  It will not destruct the memory space when the vector
//      is destroyed or goes out of scope.
//
X
X                                 
X
X
X
#include <iostream.h>       // for formatted printing of matrices
X
#ifdef MV_VECTOR_BOUNDS_CHECK
#   include <assert.h>
#endif
X
#include "mv_vecindex.h"
X
// this is really used as a sort of global constant. The reason
// for creating its own type is that so it can be overloaded to perform
// a deep or shallow assignement.  (Any variable of type MV_Vector_::ref_type
// has only one possible value: one.)
X
#include "mv_vector_ref.h"
X
class MV_Vector_double
{                                                                      
X    protected:                                                           
X           double *p_;
X           unsigned int dim_;
X           int ref_;  // 0 or 1; does this own its own memory space?
X    public:                                                            
X
X
X        /*::::::::::::::::::::::::::*/                                 
X        /* Constructors/Destructors */                                 
X        /*::::::::::::::::::::::::::*/                                 
X                                                                       
X    MV_Vector_double();                             
X    MV_Vector_double(unsigned int);                             
X    MV_Vector_double(unsigned int, const double&);   // can't be inlined 
X                                                     //because of 'for'
X                                                    // statement.
X    MV_Vector_double(double*, unsigned int);        // new copy
X    MV_Vector_double(const double*, unsigned int);      // new copy ???
X    
X    // reference of an exisiting data structure
X    //
X    MV_Vector_double(double*, unsigned int, MV_Vector_::ref_type i);    
X    MV_Vector_double(const MV_Vector_double &); 
X    ~MV_Vector_double();                              
X                                                                       
X        /*::::::::::::::::::::::::::::::::*/                           
X        /*  Indices and access operations */                           
X        /*::::::::::::::::::::::::::::::::*/                           
X                                                                       
X
X    // code for operator() is defined here, otherwise some compilers 
X    // (e.g. Turbo C++ v 3.0) cannot inline them properly...
X    //
X    double&     operator()(unsigned int i)
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X    const  double&      operator()(unsigned int i) const 
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X
X    double&     operator[](unsigned int i)
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X    const  double&      operator[](unsigned int i) const 
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X
X
X
X    MV_Vector_double operator()(const MV_VecIndex &I) ;
X    MV_Vector_double operator()(void);
X    const MV_Vector_double operator()(void) const;
X    const MV_Vector_double operator()(const MV_VecIndex &I) const;
//
//   the following line causes ambiguatities with template instantiations
//   should be avoid.  Used &v(0) explicitly when converting to double*.
//
//    inline                operator const  double*() const {return p_;} 
X    inline unsigned int             size() const { return dim_;}
X    inline int                      ref() const { return  ref_;}
X    inline int                      null() const {return dim_== 0;}
X            //
X            // Create a new *uninitalized* vector of size N
X            MV_Vector_double & newsize(unsigned int );
X                                                                       
X        /*::::::::::::::*/                                             
X        /*  Assignment  */                                             
X        /*::::::::::::::*/                                             
X                                                                       
X            MV_Vector_double & operator=(const MV_Vector_double&);
X            MV_Vector_double & operator=(const double&);
X
X
X    friend ostream& operator<<(ostream &s, const MV_Vector_double &A);
X
};                                                                     
X
#include "mv_blas1_double.h"
X
#endif  
SHAR_EOF
chmod 0660 mv/include/mv_vector_double.h ||
echo 'restore of mv/include/mv_vector_double.h failed'
Wc_c="`wc -c < 'mv/include/mv_vector_double.h'`"
test 6947 -eq "$Wc_c" ||
	echo 'mv/include/mv_vector_double.h: original size 6947, current size' "$Wc_c"
fi
# ============= mv/include/mv_vector_float.h ==============
if test -f 'mv/include/mv_vector_float.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_vector_float.h (File already exists)'
else
echo 'x - extracting mv/include/mv_vector_float.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_vector_float.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_vector_float.h       Basic vector class (float precision)
//
X
#ifndef _MV_VECTOR_float_H
#define _MV_VECTOR_float_H    
X
//
//      Key features:
//
//    o efficient indexing as fast as native C arrays 
//    o supports only unit strides (for efficient indexing)
//    o copy-by-value semantics
//    o optional "share" semantics allows vectors to be constructed as
//          "views", or "references" of an existing memory, using 
//          MV_Vector_::ref modifier in the constuctor.  (see note below.)
//    o vector views can assign and references sections of vector, but
//          cannot modify their *size*.
//    o block-range indexing via MV_VecIndex class (e.g. A(I) = B; )
//          (note for the above to work, A(I) must return a vector view.)
//    o optional range checking (compile switch)
//    o fast copying (A=B) via loop unrolling
//    o (experimental derived FMV_Vector class) for even faster copying via 
//          memcpy() for data elements employing simple bit-wise copying (e.g.
//          float, complex, et.c)
//    o support for both [] and () style indexing  ([] not available 
//          for matrices.)
//
//  NOTES:
//
//      o  O(N) loops for copying and assigning scalars to vectors unroll
//      loops to a depth of 4.  Thus on some machines, it is faster
//      to execute A=scalar, than to manually assign a native C
//      array using an explicit for loop:
//      
//          for (i=0; i<N; d[i++] = scalar);
//
//      o   function code for the () and [] operators has been 
//      inlined into the class declaration, for compilers
//      (e.g. Turbo C++ v. 3.0) that refuse to inline otherwise.
//
//      o  The MV_Vector(*float, int len) constructor is now a deep-copy to
//      match the MV_Vector(const &MV_Vector) constructor.  To create a view
//      (share semantics) use
//
//          MV_Vector_float A( &d[0], n, MV_Vector_::ref );
//
//      This allows one to construct vectors as views of any contiguous C
//      array.  It will not destruct the memory space when the vector
//      is destroyed or goes out of scope.
//
X
X                                 
X
X
X
#include <iostream.h>       // for formatted printing of matrices
X
#ifdef MV_VECTOR_BOUNDS_CHECK
#   include <assert.h>
#endif
X
#include "mv_vecindex.h"
X
// this is really used as a sort of global constant. The reason
// for creating its own type is that so it can be overloaded to perform
// a deep or shallow assignement.  (Any variable of type MV_Vector_::ref_type
// has only one possible value: one.)
X
#include "mv_vector_ref.h"
X
class MV_Vector_float
{                                                                      
X    protected:                                                           
X           float *p_;
X           unsigned int dim_;
X           int ref_;  // 0 or 1; does this own its own memory space?
X    public:                                                            
X
X
X        /*::::::::::::::::::::::::::*/                                 
X        /* Constructors/Destructors */                                 
X        /*::::::::::::::::::::::::::*/                                 
X                                                                       
X    MV_Vector_float();                             
X    MV_Vector_float(unsigned int);                             
X    MV_Vector_float(unsigned int, const float&);   // can't be inlined 
X                                                     //because of 'for'
X                                                    // statement.
X    MV_Vector_float(float*, unsigned int);      // new copy
X    MV_Vector_float(const float*, unsigned int);        // new copy ???
X    
X    // reference of an exisiting data structure
X    //
X    MV_Vector_float(float*, unsigned int, MV_Vector_::ref_type i);  
X    MV_Vector_float(const MV_Vector_float &); 
X    ~MV_Vector_float();                              
X                                                                       
X        /*::::::::::::::::::::::::::::::::*/                           
X        /*  Indices and access operations */                           
X        /*::::::::::::::::::::::::::::::::*/                           
X                                                                       
X
X    // code for operator() is defined here, otherwise some compilers 
X    // (e.g. Turbo C++ v 3.0) cannot inline them properly...
X    //
X    float&      operator()(unsigned int i)
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X    const  float&       operator()(unsigned int i) const 
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X
X    float&      operator[](unsigned int i)
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X    const  float&       operator[](unsigned int i) const 
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X
X
X
X    MV_Vector_float operator()(const MV_VecIndex &I) ;
X    MV_Vector_float operator()(void);
X    const MV_Vector_float operator()(void) const;
X    const MV_Vector_float operator()(const MV_VecIndex &I) const;
//
//   the following line causes ambiguatities with template instantiations
//   should be avoid.  Used &v(0) explicitly when converting to float*.
//
//    inline                operator const  float*() const {return p_;} 
X    inline unsigned int             size() const { return dim_;}
X    inline int                      ref() const { return  ref_;}
X    inline int                      null() const {return dim_== 0;}
X            //
X            // Create a new *uninitalized* vector of size N
X            MV_Vector_float & newsize(unsigned int );
X                                                                       
X        /*::::::::::::::*/                                             
X        /*  Assignment  */                                             
X        /*::::::::::::::*/                                             
X                                                                       
X            MV_Vector_float & operator=(const MV_Vector_float&);
X            MV_Vector_float & operator=(const float&);
X
X
X    friend ostream& operator<<(ostream &s, const MV_Vector_float &A);
X
};                                                                     
X
#include "mv_blas1_float.h"
X
#endif  
SHAR_EOF
chmod 0660 mv/include/mv_vector_float.h ||
echo 'restore of mv/include/mv_vector_float.h failed'
Wc_c="`wc -c < 'mv/include/mv_vector_float.h'`"
test 6912 -eq "$Wc_c" ||
	echo 'mv/include/mv_vector_float.h: original size 6912, current size' "$Wc_c"
fi
# ============= mv/include/mv_vector_int.h ==============
if test -f 'mv/include/mv_vector_int.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_vector_int.h (File already exists)'
else
echo 'x - extracting mv/include/mv_vector_int.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_vector_int.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_vector_int.h     Basic vector class (int precision)
//
X
#ifndef _MV_VECTOR_int_H
#define _MV_VECTOR_int_H    
X
//
//      Key features:
//
//    o efficient indexing as fast as native C arrays 
//    o supports only unit strides (for efficient indexing)
//    o copy-by-value semantics
//    o optional "share" semantics allows vectors to be constructed as
//          "views", or "references" of an existing memory, using 
//          MV_Vector_::ref modifier in the constuctor.  (see note below.)
//    o vector views can assign and references sections of vector, but
//          cannot modify their *size*.
//    o block-range indexing via MV_VecIndex class (e.g. A(I) = B; )
//          (note for the above to work, A(I) must return a vector view.)
//    o optional range checking (compile switch)
//    o fast copying (A=B) via loop unrolling
//    o (experimental derived FMV_Vector class) for even faster copying via 
//          memcpy() for data elements employing simple bit-wise copying (e.g.
//          float, complex, et.c)
//    o support for both [] and () style indexing  ([] not available 
//          for matrices.)
//
//  NOTES:
//
//      o  O(N) loops for copying and assigning scalars to vectors unroll
//      loops to a depth of 4.  Thus on some machines, it is faster
//      to execute A=scalar, than to manually assign a native C
//      array using an explicit for loop:
//      
//          for (i=0; i<N; d[i++] = scalar);
//
//      o   function code for the () and [] operators has been 
//      inlined into the class declaration, for compilers
//      (e.g. Turbo C++ v. 3.0) that refuse to inline otherwise.
//
//      o  The MV_Vector(*int, int len) constructor is now a deep-copy to
//      match the MV_Vector(const &MV_Vector) constructor.  To create a view
//      (share semantics) use
//
//          MV_Vector_int A( &d[0], n, MV_Vector_::ref );
//
//      This allows one to construct vectors as views of any contiguous C
//      array.  It will not destruct the memory space when the vector
//      is destroyed or goes out of scope.
//
X
X                                 
X
X
X
#include <iostream.h>       // for formatted printing of matrices
X
#ifdef MV_VECTOR_BOUNDS_CHECK
#   include <assert.h>
#endif
X
#include "mv_vecindex.h"
X
// this is really used as a sort of global constant. The reason
// for creating its own type is that so it can be overloaded to perform
// a deep or shallow assignement.  (Any variable of type MV_Vector_::ref_type
// has only one possible value: one.)
X
#include "mv_vector_ref.h"
X
class MV_Vector_int
{                                                                      
X    protected:                                                           
X           int *p_;
X           unsigned int dim_;
X           int ref_;  // 0 or 1; does this own its own memory space?
X    public:                                                            
X
X
X        /*::::::::::::::::::::::::::*/                                 
X        /* Constructors/Destructors */                                 
X        /*::::::::::::::::::::::::::*/                                 
X                                                                       
X    MV_Vector_int();                             
X    MV_Vector_int(unsigned int);                             
X    MV_Vector_int(unsigned int, const int&);   // can't be inlined 
X                                                     //because of 'for'
X                                                    // statement.
X    MV_Vector_int(int*, unsigned int);      // new copy
X    MV_Vector_int(const int*, unsigned int);        // new copy ???
X    
X    // reference of an exisiting data structure
X    //
X    MV_Vector_int(int*, unsigned int, MV_Vector_::ref_type i);  
X    MV_Vector_int(const MV_Vector_int &); 
X    ~MV_Vector_int();                              
X                                                                       
X        /*::::::::::::::::::::::::::::::::*/                           
X        /*  Indices and access operations */                           
X        /*::::::::::::::::::::::::::::::::*/                           
X                                                                       
X
X    // code for operator() is defined here, otherwise some compilers 
X    // (e.g. Turbo C++ v 3.0) cannot inline them properly...
X    //
X    int&        operator()(unsigned int i)
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X    const  int&     operator()(unsigned int i) const 
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X
X    int&        operator[](unsigned int i)
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X    const  int&     operator[](unsigned int i) const 
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X
X
X
X    MV_Vector_int operator()(const MV_VecIndex &I) ;
X    MV_Vector_int operator()(void);
X    const MV_Vector_int operator()(void) const;
X    const MV_Vector_int operator()(const MV_VecIndex &I) const;
//
//   the following line causes ambiguatities with template instantiations
//   should be avoid.  Used &v(0) explicitly when converting to int*.
//
//    inline                operator const  int*() const {return p_;} 
X    inline unsigned int             size() const { return dim_;}
X    inline int                      ref() const { return  ref_;}
X    inline int                      null() const {return dim_== 0;}
X            //
X            // Create a new *uninitalized* vector of size N
X            MV_Vector_int & newsize(unsigned int );
X                                                                       
X        /*::::::::::::::*/                                             
X        /*  Assignment  */                                             
X        /*::::::::::::::*/                                             
X                                                                       
X            MV_Vector_int & operator=(const MV_Vector_int&);
X            MV_Vector_int & operator=(const int&);
X
X
X    friend ostream& operator<<(ostream &s, const MV_Vector_int &A);
X
};                                                                     
X
#include "mv_blas1_int.h"
X
#endif  
SHAR_EOF
chmod 0660 mv/include/mv_vector_int.h ||
echo 'restore of mv/include/mv_vector_int.h failed'
Wc_c="`wc -c < 'mv/include/mv_vector_int.h'`"
test 6834 -eq "$Wc_c" ||
	echo 'mv/include/mv_vector_int.h: original size 6834, current size' "$Wc_c"
fi
# ============= mv/include/mv_vector_ref.h ==============
if test -f 'mv/include/mv_vector_ref.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_vector_ref.h (File already exists)'
else
echo 'x - extracting mv/include/mv_vector_ref.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_vector_ref.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
X
// this is really used as a sort of global constant. The reason
// for creating its own type is that so it can be overloaded to perform
// a deep or shallow assignement.  (Any variable of type MV_Vector_::ref_type
// has only one possible value: one.)
X
#ifndef _MV_VECTOR_REF_
#define _MV_VECTOR_REF_
struct MV_Vector_
{
X    enum ref_type  { ref = 1};
} ;
# endif
SHAR_EOF
chmod 0660 mv/include/mv_vector_ref.h ||
echo 'restore of mv/include/mv_vector_ref.h failed'
Wc_c="`wc -c < 'mv/include/mv_vector_ref.h'`"
test 477 -eq "$Wc_c" ||
	echo 'mv/include/mv_vector_ref.h: original size 477, current size' "$Wc_c"
fi
# ============= mv/include/mv_vector_type.h ==============
if test -f 'mv/include/mv_vector_type.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_vector_type.h (File already exists)'
else
echo 'x - extracting mv/include/mv_vector_type.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_vector_type.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_vector_TYPE.h        Basic vector class (TYPE precision)
//
X
#ifndef _MV_VECTOR_TYPE_H
#define _MV_VECTOR_TYPE_H    
X
//
//      Key features:
//
//    o efficient indexing as fast as native C arrays 
//    o supports only unit strides (for efficient indexing)
//    o copy-by-value semantics
//    o optional "share" semantics allows vectors to be constructed as
//          "views", or "references" of an existing memory, using 
//          MV_Vector_::ref modifier in the constuctor.  (see note below.)
//    o vector views can assign and references sections of vector, but
//          cannot modify their *size*.
//    o block-range indexing via MV_VecIndex class (e.g. A(I) = B; )
//          (note for the above to work, A(I) must return a vector view.)
//    o optional range checking (compile switch)
//    o fast copying (A=B) via loop unrolling
//    o (experimental derived FMV_Vector class) for even faster copying via 
//          memcpy() for data elements employing simple bit-wise copying (e.g.
//          float, complex, et.c)
//    o support for both [] and () style indexing  ([] not available 
//          for matrices.)
//
//  NOTES:
//
//      o  O(N) loops for copying and assigning scalars to vectors unroll
//      loops to a depth of 4.  Thus on some machines, it is faster
//      to execute A=scalar, than to manually assign a native C
//      array using an explicit for loop:
//      
//          for (i=0; i<N; d[i++] = scalar);
//
//      o   function code for the () and [] operators has been 
//      inlined into the class declaration, for compilers
//      (e.g. Turbo C++ v. 3.0) that refuse to inline otherwise.
//
//      o  The MV_Vector(*TYPE, int len) constructor is now a deep-copy to
//      match the MV_Vector(const &MV_Vector) constructor.  To create a view
//      (share semantics) use
//
//          MV_Vector_TYPE A( &d[0], n, MV_Vector_::ref );
//
//      This allows one to construct vectors as views of any contiguous C
//      array.  It will not destruct the memory space when the vector
//      is destroyed or goes out of scope.
//
X
X                                 
X
X
X
#include <iostream.h>       // for formatted printing of matrices
X
#ifdef MV_VECTOR_BOUNDS_CHECK
#   include <assert.h>
#endif
X
#include "mv_vecindex.h"
X
// this is really used as a sort of global constant. The reason
// for creating its own type is that so it can be overloaded to perform
// a deep or shallow assignement.  (Any variable of type MV_Vector_::ref_type
// has only one possible value: one.)
X
#include "mv_vector_ref.h"
X
class MV_Vector_TYPE
{                                                                      
X    protected:                                                           
X           TYPE *p_;
X           unsigned int dim_;
X           int ref_;  // 0 or 1; does this own its own memory space?
X    public:                                                            
X
X
X        /*::::::::::::::::::::::::::*/                                 
X        /* Constructors/Destructors */                                 
X        /*::::::::::::::::::::::::::*/                                 
X                                                                       
X    MV_Vector_TYPE();                             
X    MV_Vector_TYPE(unsigned int);                             
X    MV_Vector_TYPE(unsigned int, const TYPE&);   // can't be inlined 
X                                                     //because of 'for'
X                                                    // statement.
X    MV_Vector_TYPE(TYPE*, unsigned int);        // new copy
X    MV_Vector_TYPE(const TYPE*, unsigned int);      // new copy ???
X    
X    // reference of an exisiting data structure
X    //
X    MV_Vector_TYPE(TYPE*, unsigned int, MV_Vector_::ref_type i);    
X    MV_Vector_TYPE(const MV_Vector_TYPE &); 
X    ~MV_Vector_TYPE();                              
X                                                                       
X        /*::::::::::::::::::::::::::::::::*/                           
X        /*  Indices and access operations */                           
X        /*::::::::::::::::::::::::::::::::*/                           
X                                                                       
X
X    // code for operator() is defined here, otherwise some compilers 
X    // (e.g. Turbo C++ v 3.0) cannot inline them properly...
X    //
X    TYPE&       operator()(unsigned int i)
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X    const  TYPE&    operator()(unsigned int i) const 
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X
X    TYPE&       operator[](unsigned int i)
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X    const  TYPE&    operator[](unsigned int i) const 
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X
X
X
X    MV_Vector_TYPE operator()(const MV_VecIndex &I) ;
X    MV_Vector_TYPE operator()(void);
X    const MV_Vector_TYPE operator()(void) const;
X    const MV_Vector_TYPE operator()(const MV_VecIndex &I) const;
//
//   the following line causes ambiguatities with template instantiations
//   should be avoid.  Used &v(0) explicitly when converting to TYPE*.
//
//    inline                operator const  TYPE*() const {return p_;} 
X    inline unsigned int             size() const { return dim_;}
X    inline int                      ref() const { return  ref_;}
X    inline int                      null() const {return dim_== 0;}
X            //
X            // Create a new *uninitalized* vector of size N
X            MV_Vector_TYPE & newsize(unsigned int );
X                                                                       
X        /*::::::::::::::*/                                             
X        /*  Assignment  */                                             
X        /*::::::::::::::*/                                             
X                                                                       
X            MV_Vector_TYPE & operator=(const MV_Vector_TYPE&);
X            MV_Vector_TYPE & operator=(const TYPE&);
X
X
X    friend ostream& operator<<(ostream &s, const MV_Vector_TYPE &A);
X
};                                                                     
X
#include "mv_blas1_TYPE.h"
X
#endif  
SHAR_EOF
chmod 0660 mv/include/mv_vector_type.h ||
echo 'restore of mv/include/mv_vector_type.h failed'
Wc_c="`wc -c < 'mv/include/mv_vector_type.h'`"
test 6873 -eq "$Wc_c" ||
	echo 'mv/include/mv_vector_type.h: original size 6873, current size' "$Wc_c"
fi
# ============= mv/include/mv_vector_user_type.h ==============
if test -f 'mv/include/mv_vector_user_type.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/mv_vector_user_type.h (File already exists)'
else
echo 'x - extracting mv/include/mv_vector_user_type.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/mv_vector_user_type.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_vector_TYPE.h        Basic vector class (TYPE precision)
//
X
#ifndef _MV_VECTOR_TYPE_H
#define _MV_VECTOR_TYPE_H    
X
//
//      Key features:
//
//    o efficient indexing as fast as native C arrays 
//    o supports only unit strides (for efficient indexing)
//    o copy-by-value semantics
//    o optional "share" semantics allows vectors to be constructed as
//          "views", or "references" of an existing memory, using 
//          MV_Vector_::ref modifier in the constuctor.  (see note below.)
//    o vector views can assign and references sections of vector, but
//          cannot modify their *size*.
//    o block-range indexing via MV_VecIndex class (e.g. A(I) = B; )
//          (note for the above to work, A(I) must return a vector view.)
//    o optional range checking (compile switch)
//    o fast copying (A=B) via loop unrolling
//    o (experimental derived FMV_Vector class) for even faster copying via 
//          memcpy() for data elements employing simple bit-wise copying (e.g.
//          float, complex, et.c)
//    o support for both [] and () style indexing  ([] not available 
//          for matrices.)
//
//  NOTES:
//
//      o  O(N) loops for copying and assigning scalars to vectors unroll
//      loops to a depth of 4.  Thus on some machines, it is faster
//      to execute A=scalar, than to manually assign a native C
//      array using an explicit for loop:
//      
//          for (i=0; i<N; d[i++] = scalar);
//
//      o   function code for the () and [] operators has been 
//      inlined into the class declaration, for compilers
//      (e.g. Turbo C++ v. 3.0) that refuse to inline otherwise.
//
//      o  The MV_Vector(*TYPE, int len) constructor is now a deep-copy to
//      match the MV_Vector(const &MV_Vector) constructor.  To create a view
//      (share semantics) use
//
//          MV_Vector_TYPE A( &d[0], n, MV_Vector_::ref );
//
//      This allows one to construct vectors as views of any contiguous C
//      array.  It will not destruct the memory space when the vector
//      is destroyed or goes out of scope.
//
X
X                                 
X
X
X
#include <iostream.h>       // for formatted printing of matrices
X
#ifdef MV_VECTOR_BOUNDS_CHECK
#   include <assert.h>
#endif
X
#include "CLASS_INCLUDE_FILENAME"
#include "mv_vecindex.h"
X
// this is really used as a sort of global constant. The reason
// for creating its own type is that so it can be overloaded to perform
// a deep or shallow assignement.  (Any variable of type MV_Vector_::ref_type
// has only one possible value: one.)
X
#include "mv_vector_ref.h"
X
class MV_Vector_TYPE
{                                                                      
X    protected:                                                           
X           TYPE *p_;
X           unsigned int dim_;
X           int ref_;  // 0 or 1; does this own its own memory space?
X    public:                                                            
X
X
X        /*::::::::::::::::::::::::::*/                                 
X        /* Constructors/Destructors */                                 
X        /*::::::::::::::::::::::::::*/                                 
X                                                                       
X    MV_Vector_TYPE();                             
X    MV_Vector_TYPE(unsigned int);                             
X    MV_Vector_TYPE(unsigned int, const TYPE&);   // can't be inlined 
X                                                     //because of 'for'
X                                                    // statement.
X    MV_Vector_TYPE(TYPE*, unsigned int);        // new copy
X    MV_Vector_TYPE(const TYPE*, unsigned int);      // new copy ???
X    
X    // reference of an exisiting data structure
X    //
X    MV_Vector_TYPE(TYPE*, unsigned int, MV_Vector_::ref_type i);    
X    MV_Vector_TYPE(const MV_Vector_TYPE &); 
X    ~MV_Vector_TYPE();                              
X                                                                       
X        /*::::::::::::::::::::::::::::::::*/                           
X        /*  Indices and access operations */                           
X        /*::::::::::::::::::::::::::::::::*/                           
X                                                                       
X
X    // code for operator() is defined here, otherwise some compilers 
X    // (e.g. Turbo C++ v 3.0) cannot inline them properly...
X    //
X    TYPE&       operator()(unsigned int i)
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X    const  TYPE&    operator()(unsigned int i) const 
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X
X    TYPE&       operator[](unsigned int i)
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X    const  TYPE&    operator[](unsigned int i) const 
X                  {
#                   ifdef MV_VECTOR_BOUNDS_CHECK
X                    assert(i < dim_);
#                   endif
X                    return p_[i];
X                  }
X
X
X
X    MV_Vector_TYPE operator()(const MV_VecIndex &I) ;
X    MV_Vector_TYPE operator()(void);
X    const MV_Vector_TYPE operator()(void) const;
X    const MV_Vector_TYPE operator()(const MV_VecIndex &I) const;
//
//   the following line causes ambiguatities with template instantiations
//   should be avoid.  Used &v(0) explicitly when converting to TYPE*.
//
//    inline                operator const  TYPE*() const {return p_;} 
X    inline unsigned int             size() const { return dim_;}
X    inline int                      ref() const { return  ref_;}
X    inline int                      null() const {return dim_== 0;}
X            //
X            // Create a new *uninitalized* vector of size N
X            MV_Vector_TYPE & newsize(unsigned int );
X                                                                       
X        /*::::::::::::::*/                                             
X        /*  Assignment  */                                             
X        /*::::::::::::::*/                                             
X                                                                       
X            MV_Vector_TYPE & operator=(const MV_Vector_TYPE&);
X            MV_Vector_TYPE & operator=(const TYPE&);
X
X
X    friend ostream& operator<<(ostream &s, const MV_Vector_TYPE &A);
X
};                                                                     
X
#include "mv_blas1_TYPE.h"
X
#endif  
SHAR_EOF
chmod 0660 mv/include/mv_vector_user_type.h ||
echo 'restore of mv/include/mv_vector_user_type.h failed'
Wc_c="`wc -c < 'mv/include/mv_vector_user_type.h'`"
test 6907 -eq "$Wc_c" ||
	echo 'mv/include/mv_vector_user_type.h: original size 6907, current size' "$Wc_c"
fi
# ============= mv/include/vector_defs.h ==============
if test -f 'mv/include/vector_defs.h' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/include/vector_defs.h (File already exists)'
else
echo 'x - extracting mv/include/vector_defs.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/include/vector_defs.h' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/*      Which dense vector/matrix classes to build SparseLib++ from      */
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
X
X
#ifndef vector_defs_H
#define vector_defs_H
X
#define VECTOR_H              "mv_vector_all.h"
#define VECTOR_double         MV_Vector_double
#define VECTOR_float          MV_Vector_float
#define VECTOR_int            MV_Vector_int
#define VECTOR_complex        MV_Vector_complex
#define MATRIX_H              "mv_matrix_all.h"
#define MATRIX_double         MV_ColMat_double
#define MATRIX_float          MV_ColMat_float
#define MATRIX_int            MV_ColMat_int
#define MATRIX_complex        MV_ColMat_complex
X
#endif
SHAR_EOF
chmod 0660 mv/include/vector_defs.h ||
echo 'restore of mv/include/vector_defs.h failed'
Wc_c="`wc -c < 'mv/include/vector_defs.h'`"
test 861 -eq "$Wc_c" ||
	echo 'mv/include/vector_defs.h: original size 861, current size' "$Wc_c"
fi
# ============= mv/src/mv_blas1_complex.cc ==============
if test ! -d 'mv/src'; then
    echo 'x - creating directory mv/src'
    mkdir 'mv/src'
fi
if test -f 'mv/src/mv_blas1_complex.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_blas1_complex.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_blas1_complex.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_blas1_complex.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
X
#include <math.h>
#include <stdlib.h>
X
#include "mv_vector_complex.h"
X
MV_Vector_complex& operator*=(MV_Vector_complex &x, const complex &a)
{
X      int N = x.size();
X      for (int i=0;i<N;i++)
X         x(i) *= a;
X      return x;
}
X
MV_Vector_complex operator*(const complex &a, const MV_Vector_complex &x)
{
X      int N = x.size();
X      MV_Vector_complex result(N);
X      for (int i=0;i<N;i++)
X         result(i) = x(i)*a;
X      return result;
}
X
MV_Vector_complex operator*(const MV_Vector_complex &x, const complex &a)
{
X    // This is the other commutative case of vector*scalar.
X    // It should be just defined to be
X    // "return operator*(a,x);"
X    // but some compilers (e.g. Turbo C++ v.3.0) have trouble
X    // determining the proper template match.  For the moment,
X    // we'll just duplicate the code in the scalar * vector 
X    // case above.
X
X      int N = x.size();
X      MV_Vector_complex result(N);
X      for (int i=0;i<N;i++)
X         result(i) = x(i)*a;
X      return result;
X
}
X
MV_Vector_complex operator+(const MV_Vector_complex &x, const MV_Vector_complex &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in +." << endl;
X         exit(1);
X      }
X      
X      MV_Vector_complex result(N);
X      for (int i=0;i<N; i++)
X         result(i) = x(i) + y(i);
X      return result;
}
X          
MV_Vector_complex operator-(const MV_Vector_complex &x, const MV_Vector_complex &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      MV_Vector_complex result(N);
X      for (int i=0;i<N; i++)
X         result(i) = x(i) - y(i);
X      return result;
}
X          
X
MV_Vector_complex& operator+=(MV_Vector_complex &x, const MV_Vector_complex &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      for (int i=0;i<N; i++)
X         x(i) += y(i);
X      return x;
}
X          
X      
MV_Vector_complex& operator-=(MV_Vector_complex &x, const MV_Vector_complex &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      for (int i=0;i<N; i++)
X         x(i) -= y(i);
X      return x;
}
X          
X      
X
//  norm and dot product functions for the MV_Vector<> class
X
X
complex dot(const MV_Vector_complex &x, const MV_Vector_complex &y)
{
X        
X  //  Check for compatible dimensions:
X  if (x.size() != y.size())
X      {
X         cout << "Incompatible dimensions in dot(). " << endl;
X         exit(1);
X      }
X
X      complex temp =  0;
X      for (int i=0; i<x.size();i++)
X           temp += x(i)*y(i);
X      return temp;
}
X
complex norm(const MV_Vector_complex &x)
{
X      complex temp = dot(x,x);
X      return sqrt(temp);
}
X
SHAR_EOF
chmod 0660 mv/src/mv_blas1_complex.cc ||
echo 'restore of mv/src/mv_blas1_complex.cc failed'
Wc_c="`wc -c < 'mv/src/mv_blas1_complex.cc'`"
test 3025 -eq "$Wc_c" ||
	echo 'mv/src/mv_blas1_complex.cc: original size 3025, current size' "$Wc_c"
fi
# ============= mv/src/mv_blas1_double.cc ==============
if test -f 'mv/src/mv_blas1_double.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_blas1_double.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_blas1_double.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_blas1_double.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
X
#include <math.h>
#include <stdlib.h>
X
#include "mv_vector_double.h"
X
MV_Vector_double& operator*=(MV_Vector_double &x, const double &a)
{
X      int N = x.size();
X      for (int i=0;i<N;i++)
X         x(i) *= a;
X      return x;
}
X
MV_Vector_double operator*(const double &a, const MV_Vector_double &x)
{
X      int N = x.size();
X      MV_Vector_double result(N);
X      for (int i=0;i<N;i++)
X         result(i) = x(i)*a;
X      return result;
}
X
MV_Vector_double operator*(const MV_Vector_double &x, const double &a)
{
X    // This is the other commutative case of vector*scalar.
X    // It should be just defined to be
X    // "return operator*(a,x);"
X    // but some compilers (e.g. Turbo C++ v.3.0) have trouble
X    // determining the proper template match.  For the moment,
X    // we'll just duplicate the code in the scalar * vector 
X    // case above.
X
X      int N = x.size();
X      MV_Vector_double result(N);
X      for (int i=0;i<N;i++)
X         result(i) = x(i)*a;
X      return result;
X
}
X
MV_Vector_double operator+(const MV_Vector_double &x, const MV_Vector_double &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in +." << endl;
X         exit(1);
X      }
X      
X      MV_Vector_double result(N);
X      for (int i=0;i<N; i++)
X         result(i) = x(i) + y(i);
X      return result;
}
X          
MV_Vector_double operator-(const MV_Vector_double &x, const MV_Vector_double &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      MV_Vector_double result(N);
X      for (int i=0;i<N; i++)
X         result(i) = x(i) - y(i);
X      return result;
}
X          
X
MV_Vector_double& operator+=(MV_Vector_double &x, const MV_Vector_double &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      for (int i=0;i<N; i++)
X         x(i) += y(i);
X      return x;
}
X          
X      
MV_Vector_double& operator-=(MV_Vector_double &x, const MV_Vector_double &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      for (int i=0;i<N; i++)
X         x(i) -= y(i);
X      return x;
}
X          
X      
X
//  norm and dot product functions for the MV_Vector<> class
X
X
double dot(const MV_Vector_double &x, const MV_Vector_double &y)
{
X        
X  //  Check for compatible dimensions:
X  if (x.size() != y.size())
X      {
X         cout << "Incompatible dimensions in dot(). " << endl;
X         exit(1);
X      }
X
X      double temp =  0;
X      for (int i=0; i<x.size();i++)
X           temp += x(i)*y(i);
X      return temp;
}
X
double norm(const MV_Vector_double &x)
{
X      double temp = dot(x,x);
X      return sqrt(temp);
}
X
SHAR_EOF
chmod 0660 mv/src/mv_blas1_double.cc ||
echo 'restore of mv/src/mv_blas1_double.cc failed'
Wc_c="`wc -c < 'mv/src/mv_blas1_double.cc'`"
test 2992 -eq "$Wc_c" ||
	echo 'mv/src/mv_blas1_double.cc: original size 2992, current size' "$Wc_c"
fi
# ============= mv/src/mv_blas1_float.cc ==============
if test -f 'mv/src/mv_blas1_float.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_blas1_float.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_blas1_float.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_blas1_float.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
X
#include <math.h>
#include <stdlib.h>
X
#include "mv_vector_float.h"
X
MV_Vector_float& operator*=(MV_Vector_float &x, const float &a)
{
X      int N = x.size();
X      for (int i=0;i<N;i++)
X         x(i) *= a;
X      return x;
}
X
MV_Vector_float operator*(const float &a, const MV_Vector_float &x)
{
X      int N = x.size();
X      MV_Vector_float result(N);
X      for (int i=0;i<N;i++)
X         result(i) = x(i)*a;
X      return result;
}
X
MV_Vector_float operator*(const MV_Vector_float &x, const float &a)
{
X    // This is the other commutative case of vector*scalar.
X    // It should be just defined to be
X    // "return operator*(a,x);"
X    // but some compilers (e.g. Turbo C++ v.3.0) have trouble
X    // determining the proper template match.  For the moment,
X    // we'll just duplicate the code in the scalar * vector 
X    // case above.
X
X      int N = x.size();
X      MV_Vector_float result(N);
X      for (int i=0;i<N;i++)
X         result(i) = x(i)*a;
X      return result;
X
}
X
MV_Vector_float operator+(const MV_Vector_float &x, const MV_Vector_float &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in +." << endl;
X         exit(1);
X      }
X      
X      MV_Vector_float result(N);
X      for (int i=0;i<N; i++)
X         result(i) = x(i) + y(i);
X      return result;
}
X          
MV_Vector_float operator-(const MV_Vector_float &x, const MV_Vector_float &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      MV_Vector_float result(N);
X      for (int i=0;i<N; i++)
X         result(i) = x(i) - y(i);
X      return result;
}
X          
X
MV_Vector_float& operator+=(MV_Vector_float &x, const MV_Vector_float &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      for (int i=0;i<N; i++)
X         x(i) += y(i);
X      return x;
}
X          
X      
MV_Vector_float& operator-=(MV_Vector_float &x, const MV_Vector_float &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      for (int i=0;i<N; i++)
X         x(i) -= y(i);
X      return x;
}
X          
X      
X
//  norm and dot product functions for the MV_Vector<> class
X
X
float dot(const MV_Vector_float &x, const MV_Vector_float &y)
{
X        
X  //  Check for compatible dimensions:
X  if (x.size() != y.size())
X      {
X         cout << "Incompatible dimensions in dot(). " << endl;
X         exit(1);
X      }
X
X      float temp =  0;
X      for (int i=0; i<x.size();i++)
X           temp += x(i)*y(i);
X      return temp;
}
X
float norm(const MV_Vector_float &x)
{
X      float temp = dot(x,x);
X      return sqrt(temp);
}
X
SHAR_EOF
chmod 0660 mv/src/mv_blas1_float.cc ||
echo 'restore of mv/src/mv_blas1_float.cc failed'
Wc_c="`wc -c < 'mv/src/mv_blas1_float.cc'`"
test 2959 -eq "$Wc_c" ||
	echo 'mv/src/mv_blas1_float.cc: original size 2959, current size' "$Wc_c"
fi
# ============= mv/src/mv_blas1_int.cc ==============
if test -f 'mv/src/mv_blas1_int.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_blas1_int.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_blas1_int.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_blas1_int.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
X
#include <math.h>
#include <stdlib.h>
X
#include "mv_vector_int.h"
X
MV_Vector_int& operator*=(MV_Vector_int &x, const int &a)
{
X      int N = x.size();
X      for (int i=0;i<N;i++)
X         x(i) *= a;
X      return x;
}
X
MV_Vector_int operator*(const int &a, const MV_Vector_int &x)
{
X      int N = x.size();
X      MV_Vector_int result(N);
X      for (int i=0;i<N;i++)
X         result(i) = x(i)*a;
X      return result;
}
X
MV_Vector_int operator*(const MV_Vector_int &x, const int &a)
{
X    // This is the other commutative case of vector*scalar.
X    // It should be just defined to be
X    // "return operator*(a,x);"
X    // but some compilers (e.g. Turbo C++ v.3.0) have trouble
X    // determining the proper template match.  For the moment,
X    // we'll just duplicate the code in the scalar * vector 
X    // case above.
X
X      int N = x.size();
X      MV_Vector_int result(N);
X      for (int i=0;i<N;i++)
X         result(i) = x(i)*a;
X      return result;
X
}
X
MV_Vector_int operator+(const MV_Vector_int &x, const MV_Vector_int &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in +." << endl;
X         exit(1);
X      }
X      
X      MV_Vector_int result(N);
X      for (int i=0;i<N; i++)
X         result(i) = x(i) + y(i);
X      return result;
}
X          
MV_Vector_int operator-(const MV_Vector_int &x, const MV_Vector_int &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      MV_Vector_int result(N);
X      for (int i=0;i<N; i++)
X         result(i) = x(i) - y(i);
X      return result;
}
X          
X
MV_Vector_int& operator+=(MV_Vector_int &x, const MV_Vector_int &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      for (int i=0;i<N; i++)
X         x(i) += y(i);
X      return x;
}
X          
X      
MV_Vector_int& operator-=(MV_Vector_int &x, const MV_Vector_int &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      for (int i=0;i<N; i++)
X         x(i) -= y(i);
X      return x;
}
X          
X      
X
//  norm and dot product functions for the MV_Vector<> class
X
X
int dot(const MV_Vector_int &x, const MV_Vector_int &y)
{
X        
X  //  Check for compatible dimensions:
X  if (x.size() != y.size())
X      {
X         cout << "Incompatible dimensions in dot(). " << endl;
X         exit(1);
X      }
X
X      int temp =  0;
X      for (int i=0; i<x.size();i++)
X           temp += x(i)*y(i);
X      return temp;
}
X
int norm(const MV_Vector_int &x)
{
X      int temp = dot(x,x);
X      return sqrt(temp);
}
X
SHAR_EOF
chmod 0660 mv/src/mv_blas1_int.cc ||
echo 'restore of mv/src/mv_blas1_int.cc failed'
Wc_c="`wc -c < 'mv/src/mv_blas1_int.cc'`"
test 2893 -eq "$Wc_c" ||
	echo 'mv/src/mv_blas1_int.cc: original size 2893, current size' "$Wc_c"
fi
# ============= mv/src/mv_blas1_type.cc ==============
if test -f 'mv/src/mv_blas1_type.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_blas1_type.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_blas1_type.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_blas1_type.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
X
#include <math.h>
#include <stdlib.h>
X
#include "mv_vector_TYPE.h"
X
MV_Vector_TYPE& operator*=(MV_Vector_TYPE &x, const TYPE &a)
{
X      int N = x.size();
X      for (int i=0;i<N;i++)
X         x(i) *= a;
X      return x;
}
X
MV_Vector_TYPE operator*(const TYPE &a, const MV_Vector_TYPE &x)
{
X      int N = x.size();
X      MV_Vector_TYPE result(N);
X      for (int i=0;i<N;i++)
X         result(i) = x(i)*a;
X      return result;
}
X
MV_Vector_TYPE operator*(const MV_Vector_TYPE &x, const TYPE &a)
{
X    // This is the other commutative case of vector*scalar.
X    // It should be just defined to be
X    // "return operator*(a,x);"
X    // but some compilers (e.g. Turbo C++ v.3.0) have trouble
X    // determining the proper template match.  For the moment,
X    // we'll just duplicate the code in the scalar * vector 
X    // case above.
X
X      int N = x.size();
X      MV_Vector_TYPE result(N);
X      for (int i=0;i<N;i++)
X         result(i) = x(i)*a;
X      return result;
X
}
X
MV_Vector_TYPE operator+(const MV_Vector_TYPE &x, const MV_Vector_TYPE &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in +." << endl;
X         exit(1);
X      }
X      
X      MV_Vector_TYPE result(N);
X      for (int i=0;i<N; i++)
X         result(i) = x(i) + y(i);
X      return result;
}
X          
MV_Vector_TYPE operator-(const MV_Vector_TYPE &x, const MV_Vector_TYPE &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      MV_Vector_TYPE result(N);
X      for (int i=0;i<N; i++)
X         result(i) = x(i) - y(i);
X      return result;
}
X          
X
MV_Vector_TYPE& operator+=(MV_Vector_TYPE &x, const MV_Vector_TYPE &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      for (int i=0;i<N; i++)
X         x(i) += y(i);
X      return x;
}
X          
X      
MV_Vector_TYPE& operator-=(MV_Vector_TYPE &x, const MV_Vector_TYPE &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      for (int i=0;i<N; i++)
X         x(i) -= y(i);
X      return x;
}
X          
X      
X
//  norm and dot product functions for the MV_Vector<> class
X
X
TYPE dot(const MV_Vector_TYPE &x, const MV_Vector_TYPE &y)
{
X        
X  //  Check for compatible dimensions:
X  if (x.size() != y.size())
X      {
X         cout << "Incompatible dimensions in dot(). " << endl;
X         exit(1);
X      }
X
X      TYPE temp =  0;
X      for (int i=0; i<x.size();i++)
X           temp += x(i)*y(i);
X      return temp;
}
X
TYPE norm(const MV_Vector_TYPE &x)
{
X      TYPE temp = dot(x,x);
X      return sqrt(temp);
}
X
SHAR_EOF
chmod 0660 mv/src/mv_blas1_type.cc ||
echo 'restore of mv/src/mv_blas1_type.cc failed'
Wc_c="`wc -c < 'mv/src/mv_blas1_type.cc'`"
test 2926 -eq "$Wc_c" ||
	echo 'mv/src/mv_blas1_type.cc: original size 2926, current size' "$Wc_c"
fi
# ============= mv/src/mv_blas1_user_type.cc ==============
if test -f 'mv/src/mv_blas1_user_type.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_blas1_user_type.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_blas1_user_type.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_blas1_user_type.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
X
#include <math.h>
#include <stdlib.h>
X
#include "TYPE.h"
#include "mv_blas1_TYPE.h"
X
MV_Vector_TYPE& operator*=(MV_Vector_TYPE &x, const TYPE &a)
{
X      int N = x.size();
X      for (int i=0;i<N;i++)
X         x(i) *= a;
X      return x;
}
X
MV_Vector_TYPE operator*(const TYPE &a, const MV_Vector_TYPE &x)
{
X      int N = x.size();
X      MV_Vector_TYPE result(N);
X      for (int i=0;i<N;i++)
X         result(i) = x(i)*a;
X      return result;
}
X
MV_Vector_TYPE operator*(const MV_Vector_TYPE &x, const TYPE &a)
{
X    // This is the other commutative case of vector*scalar.
X    // It should be just defined to be
X    // "return operator*(a,x);"
X    // but some compilers (e.g. Turbo C++ v.3.0) have trouble
X    // determining the proper template match.  For the moment,
X    // we'll just duplicate the code in the scalar * vector 
X    // case above.
X
X      int N = x.size();
X      MV_Vector_TYPE result(N);
X      for (int i=0;i<N;i++)
X         result(i) = x(i)*a;
X      return result;
X
}
X
MV_Vector_TYPE operator+(const MV_Vector_TYPE &x, const MV_Vector_TYPE &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in +." << endl;
X         exit(1);
X      }
X      
X      MV_Vector_TYPE result(N);
X      for (int i=0;i<N; i++)
X         result(i) = x(i) + y(i);
X      return result;
}
X          
MV_Vector_TYPE operator-(const MV_Vector_TYPE &x, const MV_Vector_TYPE &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      MV_Vector_TYPE result(N);
X      for (int i=0;i<N; i++)
X         result(i) = x(i) - y(i);
X      return result;
}
X          
X
MV_Vector_TYPE& operator+=(MV_Vector_TYPE &x, const MV_Vector_TYPE &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      for (int i=0;i<N; i++)
X         x(i) += y(i);
X      return x;
}
X          
X      
MV_Vector_TYPE& operator-=(MV_Vector_TYPE &x, const MV_Vector_TYPE &y)
{
X      int N = x.size();
X      if (N != y.size())
X      {
X         cout << "Incompatible vector lengths in -." << endl;
X         exit(1);
X      }
X      
X      for (int i=0;i<N; i++)
X         x(i) -= y(i);
X      return x;
}
X          
X      
X
//  norm and dot product functions for the MV_Vector<> class
X
X
TYPE dot(const MV_Vector_TYPE &x, const MV_Vector_TYPE &y)
{
X        
X  //  Check for compatible dimensions:
X  if (x.size() != y.size())
X      {
X         cout << "Incompatible dimensions in dot(). " << endl;
X         exit(1);
X      }
X
X      TYPE temp=0.0;
X      for (int i=0; i<x.size();i++)
X           temp += x(i)*y(i);
X      return temp;
}
X
TYPE norm(const MV_Vector_TYPE &x)
{
X      TYPE temp = dot(x,x);
X      return sqrt(temp);
}
X
SHAR_EOF
chmod 0660 mv/src/mv_blas1_user_type.cc ||
echo 'restore of mv/src/mv_blas1_user_type.cc failed'
Wc_c="`wc -c < 'mv/src/mv_blas1_user_type.cc'`"
test 2942 -eq "$Wc_c" ||
	echo 'mv/src/mv_blas1_user_type.cc: original size 2942, current size' "$Wc_c"
fi
# ============= mv/src/mv_matrix_complex.cc ==============
if test -f 'mv/src/mv_matrix_complex.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_matrix_complex.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_matrix_complex.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_matrix_complex.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_matrix_complex.cc      Basic vector class (complex precision)
//
X
#include "mv_matrix_complex.h"
X
unsigned int MV_ColMat_complex::size(int i) const 
{
X    if (i==0) return dim0_;
X    if (i==1) return dim1_;
X    else
X    {
X     cerr << "Called MV_ColMat::size(" << i << ")  must be 0 or 1 " << endl;
X     exit(1);
X    }
X
X    // never should be here, but many compilers warn about not
X    // returning a value
X    return 0;
}
X
// NOTE: null construct have ref_ flag turned OFF, otherwise, we can
//          never reset the size of matrix....
MV_ColMat_complex::MV_ColMat_complex()  : v_(), dim0_(0), dim1_(0) , lda_(0), ref_(0){}
X                                                                
X
MV_ColMat_complex::MV_ColMat_complex(unsigned int m, unsigned int n) : v_(m*n),
X        dim0_(m), dim1_(n), lda_(m), ref_(0) {}
X
MV_ColMat_complex::MV_ColMat_complex(unsigned int m, unsigned int n, const complex &s) : v_(m*n),
X        dim0_(m), dim1_(n), lda_(m), ref_(0) 
{
X    operator=(s);
}
X
// operators and member functions
X
X
X
X
X
X
MV_ColMat_complex& MV_ColMat_complex::operator=(const complex & s) 
{
X    int M = size(0);
X    int N = size(1);
X
X    if (lda_ == M)      // if continuous, then just assign as a ?
X        v_ =  s;        // single long vector.
X
X    else
X    {
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X    //
X
X        MV_VecIndex I(0,M-1);
X        for (int j=0; j<N; j++)
X        {
X            v_(I) = s;
X            I += lda_;
X        }
X    }
X
X    return *this;
}
X
MV_ColMat_complex& MV_ColMat_complex::newsize(unsigned int M, unsigned int N)
{
X    v_.newsize(M*N);
X    dim0_ = M;
X    dim1_ = N;
X    lda_ = M;
X
X    return *this;
}
X
MV_ColMat_complex& MV_ColMat_complex::operator=(const MV_ColMat_complex & m) 
{
X
X    int lM = dim0_;     // left hand arg  (this)
X    int lN = dim1_;
X
X    int rM = m.dim0_;   // right hand arg (m)
X    int rN = m.dim1_;
X
X
X    // if the left-hand side is a matrix reference, the we copy the
X    // elements of m *into* the region specfied by the reference.
X    // i.e. inject().
X
X    if (ref_)
X    {
X        // check conformance,       
X        if (lM != rM  || lN != rN)      
X        {
X            cerr << "MV_ColMatRef::operator=  non-conformant assignment.\n";
X            exit(1);
X        }
X    }
X    else
X    {
X        newsize(rM,rN);
X    }
X
X    // at this point the left hand and right hand sides are conformant
X
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X
X    // if both sides are contigous, then just copy as one vector
X    if ( lM == lda_ && rM == m.lda_)
X    {
X        MV_VecIndex I(0,rM*rN-1);
X        v_(I) = m.v_(I);
X    }
X    else
X    {
X        // slower way...
X
X        MV_VecIndex I(0,rM-1);
X        MV_VecIndex K(0,rM-1);
X        for (int j=0; j<rN; j++)
X        {
X            v_(I) = m.v_(K);
X            I += lda_;
X            K += m.lda_;
X        }
X    }
X
X    return *this;   
}
X
MV_ColMat_complex::MV_ColMat_complex(const MV_ColMat_complex & m) : 
X        v_(m.dim0_*m.dim1_), dim0_(m.dim0_),
X        dim1_(m.dim1_), ref_(0), lda_(m.dim0_)
{
X
X    int M = m.dim0_;
X    int N = m.dim1_;
X
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X
X    MV_VecIndex I(0,M-1);
X    MV_VecIndex K(0,M-1);
X    for (int j=0; j<N; j++)
X    {
X        v_(I) = m.v_(K);
X        I += lda_;
X        K += m.lda_;
X    }
}
X
X
X
MV_ColMat_complex::MV_ColMat_complex(complex* d, unsigned int m, unsigned int n) :
X    v_(m*n), dim0_(m), dim1_(n), lda_(m), ref_(0)
{
X    int mn = m*n;
X
X    // d is contiguous, so just copy 1-d vector
X    for (int i=0; i< mn; i++)
X            v_[i] = d[i];
}
X
X
MV_ColMat_complex::MV_ColMat_complex(complex* d, unsigned int m, unsigned int n, 
X        unsigned int lda) :
X    v_(m*n), dim0_(m), dim1_(n), lda_(lda), ref_(0)
{
X    for (int j=0; j< n; j++)
X        for (int i=0; i<m; i++)
X            operator()(i,j) = d[j*lda + i];   // could be made faster!!
}
X
X
MV_ColMat_complex MV_ColMat_complex::operator()(const MV_VecIndex &I, const MV_VecIndex &J)
{
X    // check that index is not out of bounds
X    //
X    if (I.end() >= dim0_  || J.end() >= dim1_)
X    {
X        cerr << "Matrix index: (" << I.start() << ":" << I.end()  
X             << "," << J.start() << ":" << J.end()   
X             << ") not a subset of (0:" << dim0_ - 1 << ", 0:" 
X             << dim1_-1 << ") " << endl;
X        exit(1);
X    }
X
X    // this automatically returns a reference
X    // 
X    return MV_ColMat_complex(&v_[J.start()*lda_ + I.start()], 
X            I.end() - I.start() + 1, 
X            J.end() - J.start() + 1, lda_, MV_Matrix_::ref);
}
X
const MV_ColMat_complex MV_ColMat_complex::operator()(const MV_VecIndex &I, 
X    const MV_VecIndex &J) const
{
X
X    cerr << "Const operator()(MV_VecIndex, MV_VecIndex) called " << endl;
X
X    // check that index is not out of bounds
X    //
X    if (I.end() >= dim0_  || J.end() >= dim1_)
X    {
X        cerr << "Matrix index: (" << I.start() << ":" << I.end()  
X             << "," << J.start() << ":" << J.end()   
X             << ") not a subset of (0:" << dim0_ - 1 << ", 0:" 
X             << dim1_-1 << ") " << endl;
X        exit(1);
X    }
X
X    // this automatically returns a reference.  we need to 
X    // "cast away" constness here, so the &v_[] arg will
X    // not cause a compiler error.
X    //
X    MV_ColMat_complex *t =  (MV_ColMat_complex*) this;
X    return MV_ColMat_complex(&(t->v_[J.start()*lda_ + I.start()]), 
X            I.end() - I.start() + 1, 
X            J.end() - J.start() + 1, lda_, MV_Matrix_::ref);
}
X
MV_ColMat_complex::~MV_ColMat_complex() {}
X
ostream&   operator<<(ostream& s, const MV_ColMat_complex& V)
{
X    int M = V.size(0);
X    int N = V.size(1);
X
X    for (int i=0; i<M; i++)
X    {
X        for (int j=0; j<N; j++)
X            s << V(i,j) << " " ;
X        s << endl;
X    }
X    
X    return s;
}
X
X
X
SHAR_EOF
chmod 0660 mv/src/mv_matrix_complex.cc ||
echo 'restore of mv/src/mv_matrix_complex.cc failed'
Wc_c="`wc -c < 'mv/src/mv_matrix_complex.cc'`"
test 6013 -eq "$Wc_c" ||
	echo 'mv/src/mv_matrix_complex.cc: original size 6013, current size' "$Wc_c"
fi
# ============= mv/src/mv_matrix_double.cc ==============
if test -f 'mv/src/mv_matrix_double.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_matrix_double.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_matrix_double.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_matrix_double.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_matrix_double.cc      Basic vector class (double precision)
//
X
#include "mv_matrix_double.h"
X
unsigned int MV_ColMat_double::size(int i) const 
{
X    if (i==0) return dim0_;
X    if (i==1) return dim1_;
X    else
X    {
X     cerr << "Called MV_ColMat::size(" << i << ")  must be 0 or 1 " << endl;
X     exit(1);
X    }
X
X    // never should be here, but many compilers warn about not
X    // returning a value
X    return 0;
}
X
// NOTE: null construct have ref_ flag turned OFF, otherwise, we can
//          never reset the size of matrix....
MV_ColMat_double::MV_ColMat_double()  : v_(), dim0_(0), dim1_(0) , lda_(0), ref_(0){}
X                                                                
X
MV_ColMat_double::MV_ColMat_double(unsigned int m, unsigned int n) : v_(m*n),
X        dim0_(m), dim1_(n), lda_(m), ref_(0) {}
X
MV_ColMat_double::MV_ColMat_double(unsigned int m, unsigned int n, const double &s) : v_(m*n),
X        dim0_(m), dim1_(n), lda_(m), ref_(0) 
{
X    operator=(s);
}
X
// operators and member functions
X
X
X
X
X
X
MV_ColMat_double& MV_ColMat_double::operator=(const double & s) 
{
X    int M = size(0);
X    int N = size(1);
X
X    if (lda_ == M)      // if continuous, then just assign as a ?
X        v_ =  s;        // single long vector.
X
X    else
X    {
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X    //
X
X        MV_VecIndex I(0,M-1);
X        for (int j=0; j<N; j++)
X        {
X            v_(I) = s;
X            I += lda_;
X        }
X    }
X
X    return *this;
}
X
MV_ColMat_double& MV_ColMat_double::newsize(unsigned int M, unsigned int N)
{
X    v_.newsize(M*N);
X    dim0_ = M;
X    dim1_ = N;
X    lda_ = M;
X
X    return *this;
}
X
MV_ColMat_double& MV_ColMat_double::operator=(const MV_ColMat_double & m) 
{
X
X    int lM = dim0_;     // left hand arg  (this)
X    int lN = dim1_;
X
X    int rM = m.dim0_;   // right hand arg (m)
X    int rN = m.dim1_;
X
X
X    // if the left-hand side is a matrix reference, the we copy the
X    // elements of m *into* the region specfied by the reference.
X    // i.e. inject().
X
X    if (ref_)
X    {
X        // check conformance,       
X        if (lM != rM  || lN != rN)      
X        {
X            cerr << "MV_ColMatRef::operator=  non-conformant assignment.\n";
X            exit(1);
X        }
X    }
X    else
X    {
X        newsize(rM,rN);
X    }
X
X    // at this point the left hand and right hand sides are conformant
X
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X
X    // if both sides are contigous, then just copy as one vector
X    if ( lM == lda_ && rM == m.lda_)
X    {
X        MV_VecIndex I(0,rM*rN-1);
X        v_(I) = m.v_(I);
X    }
X    else
X    {
X        // slower way...
X
X        MV_VecIndex I(0,rM-1);
X        MV_VecIndex K(0,rM-1);
X        for (int j=0; j<rN; j++)
X        {
X            v_(I) = m.v_(K);
X            I += lda_;
X            K += m.lda_;
X        }
X    }
X
X    return *this;   
}
X
MV_ColMat_double::MV_ColMat_double(const MV_ColMat_double & m) : 
X        v_(m.dim0_*m.dim1_), dim0_(m.dim0_),
X        dim1_(m.dim1_), ref_(0), lda_(m.dim0_)
{
X
X    int M = m.dim0_;
X    int N = m.dim1_;
X
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X
X    MV_VecIndex I(0,M-1);
X    MV_VecIndex K(0,M-1);
X    for (int j=0; j<N; j++)
X    {
X        v_(I) = m.v_(K);
X        I += lda_;
X        K += m.lda_;
X    }
}
X
X
X
MV_ColMat_double::MV_ColMat_double(double* d, unsigned int m, unsigned int n) :
X    v_(m*n), dim0_(m), dim1_(n), lda_(m), ref_(0)
{
X    int mn = m*n;
X
X    // d is contiguous, so just copy 1-d vector
X    for (int i=0; i< mn; i++)
X            v_[i] = d[i];
}
X
X
MV_ColMat_double::MV_ColMat_double(double* d, unsigned int m, unsigned int n, 
X        unsigned int lda) :
X    v_(m*n), dim0_(m), dim1_(n), lda_(lda), ref_(0)
{
X    for (int j=0; j< n; j++)
X        for (int i=0; i<m; i++)
X            operator()(i,j) = d[j*lda + i];   // could be made faster!!
}
X
X
MV_ColMat_double MV_ColMat_double::operator()(const MV_VecIndex &I, const MV_VecIndex &J)
{
X    // check that index is not out of bounds
X    //
X    if (I.end() >= dim0_  || J.end() >= dim1_)
X    {
X        cerr << "Matrix index: (" << I.start() << ":" << I.end()  
X             << "," << J.start() << ":" << J.end()   
X             << ") not a subset of (0:" << dim0_ - 1 << ", 0:" 
X             << dim1_-1 << ") " << endl;
X        exit(1);
X    }
X
X    // this automatically returns a reference
X    // 
X    return MV_ColMat_double(&v_[J.start()*lda_ + I.start()], 
X            I.end() - I.start() + 1, 
X            J.end() - J.start() + 1, lda_, MV_Matrix_::ref);
}
X
const MV_ColMat_double MV_ColMat_double::operator()(const MV_VecIndex &I, 
X    const MV_VecIndex &J) const
{
X
X    cerr << "Const operator()(MV_VecIndex, MV_VecIndex) called " << endl;
X
X    // check that index is not out of bounds
X    //
X    if (I.end() >= dim0_  || J.end() >= dim1_)
X    {
X        cerr << "Matrix index: (" << I.start() << ":" << I.end()  
X             << "," << J.start() << ":" << J.end()   
X             << ") not a subset of (0:" << dim0_ - 1 << ", 0:" 
X             << dim1_-1 << ") " << endl;
X        exit(1);
X    }
X
X    // this automatically returns a reference.  we need to 
X    // "cast away" constness here, so the &v_[] arg will
X    // not cause a compiler error.
X    //
X    MV_ColMat_double *t =  (MV_ColMat_double*) this;
X    return MV_ColMat_double(&(t->v_[J.start()*lda_ + I.start()]), 
X            I.end() - I.start() + 1, 
X            J.end() - J.start() + 1, lda_, MV_Matrix_::ref);
}
X
MV_ColMat_double::~MV_ColMat_double() {}
X
ostream&   operator<<(ostream& s, const MV_ColMat_double& V)
{
X    int M = V.size(0);
X    int N = V.size(1);
X
X    for (int i=0; i<M; i++)
X    {
X        for (int j=0; j<N; j++)
X            s << V(i,j) << " " ;
X        s << endl;
X    }
X    
X    return s;
}
X
X
X
SHAR_EOF
chmod 0660 mv/src/mv_matrix_double.cc ||
echo 'restore of mv/src/mv_matrix_double.cc failed'
Wc_c="`wc -c < 'mv/src/mv_matrix_double.cc'`"
test 5974 -eq "$Wc_c" ||
	echo 'mv/src/mv_matrix_double.cc: original size 5974, current size' "$Wc_c"
fi
# ============= mv/src/mv_matrix_float.cc ==============
if test -f 'mv/src/mv_matrix_float.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_matrix_float.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_matrix_float.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_matrix_float.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_matrix_float.cc      Basic vector class (float precision)
//
X
#include "mv_matrix_float.h"
X
unsigned int MV_ColMat_float::size(int i) const 
{
X    if (i==0) return dim0_;
X    if (i==1) return dim1_;
X    else
X    {
X     cerr << "Called MV_ColMat::size(" << i << ")  must be 0 or 1 " << endl;
X     exit(1);
X    }
X
X    // never should be here, but many compilers warn about not
X    // returning a value
X    return 0;
}
X
// NOTE: null construct have ref_ flag turned OFF, otherwise, we can
//          never reset the size of matrix....
MV_ColMat_float::MV_ColMat_float()  : v_(), dim0_(0), dim1_(0) , lda_(0), ref_(0){}
X                                                                
X
MV_ColMat_float::MV_ColMat_float(unsigned int m, unsigned int n) : v_(m*n),
X        dim0_(m), dim1_(n), lda_(m), ref_(0) {}
X
MV_ColMat_float::MV_ColMat_float(unsigned int m, unsigned int n, const float &s) : v_(m*n),
X        dim0_(m), dim1_(n), lda_(m), ref_(0) 
{
X    operator=(s);
}
X
// operators and member functions
X
X
X
X
X
X
MV_ColMat_float& MV_ColMat_float::operator=(const float & s) 
{
X    int M = size(0);
X    int N = size(1);
X
X    if (lda_ == M)      // if continuous, then just assign as a ?
X        v_ =  s;        // single long vector.
X
X    else
X    {
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X    //
X
X        MV_VecIndex I(0,M-1);
X        for (int j=0; j<N; j++)
X        {
X            v_(I) = s;
X            I += lda_;
X        }
X    }
X
X    return *this;
}
X
MV_ColMat_float& MV_ColMat_float::newsize(unsigned int M, unsigned int N)
{
X    v_.newsize(M*N);
X    dim0_ = M;
X    dim1_ = N;
X    lda_ = M;
X
X    return *this;
}
X
MV_ColMat_float& MV_ColMat_float::operator=(const MV_ColMat_float & m) 
{
X
X    int lM = dim0_;     // left hand arg  (this)
X    int lN = dim1_;
X
X    int rM = m.dim0_;   // right hand arg (m)
X    int rN = m.dim1_;
X
X
X    // if the left-hand side is a matrix reference, the we copy the
X    // elements of m *into* the region specfied by the reference.
X    // i.e. inject().
X
X    if (ref_)
X    {
X        // check conformance,       
X        if (lM != rM  || lN != rN)      
X        {
X            cerr << "MV_ColMatRef::operator=  non-conformant assignment.\n";
X            exit(1);
X        }
X    }
X    else
X    {
X        newsize(rM,rN);
X    }
X
X    // at this point the left hand and right hand sides are conformant
X
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X
X    // if both sides are contigous, then just copy as one vector
X    if ( lM == lda_ && rM == m.lda_)
X    {
X        MV_VecIndex I(0,rM*rN-1);
X        v_(I) = m.v_(I);
X    }
X    else
X    {
X        // slower way...
X
X        MV_VecIndex I(0,rM-1);
X        MV_VecIndex K(0,rM-1);
X        for (int j=0; j<rN; j++)
X        {
X            v_(I) = m.v_(K);
X            I += lda_;
X            K += m.lda_;
X        }
X    }
X
X    return *this;   
}
X
MV_ColMat_float::MV_ColMat_float(const MV_ColMat_float & m) : 
X        v_(m.dim0_*m.dim1_), dim0_(m.dim0_),
X        dim1_(m.dim1_), ref_(0), lda_(m.dim0_)
{
X
X    int M = m.dim0_;
X    int N = m.dim1_;
X
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X
X    MV_VecIndex I(0,M-1);
X    MV_VecIndex K(0,M-1);
X    for (int j=0; j<N; j++)
X    {
X        v_(I) = m.v_(K);
X        I += lda_;
X        K += m.lda_;
X    }
}
X
X
X
MV_ColMat_float::MV_ColMat_float(float* d, unsigned int m, unsigned int n) :
X    v_(m*n), dim0_(m), dim1_(n), lda_(m), ref_(0)
{
X    int mn = m*n;
X
X    // d is contiguous, so just copy 1-d vector
X    for (int i=0; i< mn; i++)
X            v_[i] = d[i];
}
X
X
MV_ColMat_float::MV_ColMat_float(float* d, unsigned int m, unsigned int n, 
X        unsigned int lda) :
X    v_(m*n), dim0_(m), dim1_(n), lda_(lda), ref_(0)
{
X    for (int j=0; j< n; j++)
X        for (int i=0; i<m; i++)
X            operator()(i,j) = d[j*lda + i];   // could be made faster!!
}
X
X
MV_ColMat_float MV_ColMat_float::operator()(const MV_VecIndex &I, const MV_VecIndex &J)
{
X    // check that index is not out of bounds
X    //
X    if (I.end() >= dim0_  || J.end() >= dim1_)
X    {
X        cerr << "Matrix index: (" << I.start() << ":" << I.end()  
X             << "," << J.start() << ":" << J.end()   
X             << ") not a subset of (0:" << dim0_ - 1 << ", 0:" 
X             << dim1_-1 << ") " << endl;
X        exit(1);
X    }
X
X    // this automatically returns a reference
X    // 
X    return MV_ColMat_float(&v_[J.start()*lda_ + I.start()], 
X            I.end() - I.start() + 1, 
X            J.end() - J.start() + 1, lda_, MV_Matrix_::ref);
}
X
const MV_ColMat_float MV_ColMat_float::operator()(const MV_VecIndex &I, 
X    const MV_VecIndex &J) const
{
X
X    cerr << "Const operator()(MV_VecIndex, MV_VecIndex) called " << endl;
X
X    // check that index is not out of bounds
X    //
X    if (I.end() >= dim0_  || J.end() >= dim1_)
X    {
X        cerr << "Matrix index: (" << I.start() << ":" << I.end()  
X             << "," << J.start() << ":" << J.end()   
X             << ") not a subset of (0:" << dim0_ - 1 << ", 0:" 
X             << dim1_-1 << ") " << endl;
X        exit(1);
X    }
X
X    // this automatically returns a reference.  we need to 
X    // "cast away" constness here, so the &v_[] arg will
X    // not cause a compiler error.
X    //
X    MV_ColMat_float *t =  (MV_ColMat_float*) this;
X    return MV_ColMat_float(&(t->v_[J.start()*lda_ + I.start()]), 
X            I.end() - I.start() + 1, 
X            J.end() - J.start() + 1, lda_, MV_Matrix_::ref);
}
X
MV_ColMat_float::~MV_ColMat_float() {}
X
ostream&   operator<<(ostream& s, const MV_ColMat_float& V)
{
X    int M = V.size(0);
X    int N = V.size(1);
X
X    for (int i=0; i<M; i++)
X    {
X        for (int j=0; j<N; j++)
X            s << V(i,j) << " " ;
X        s << endl;
X    }
X    
X    return s;
}
X
X
X
SHAR_EOF
chmod 0660 mv/src/mv_matrix_float.cc ||
echo 'restore of mv/src/mv_matrix_float.cc failed'
Wc_c="`wc -c < 'mv/src/mv_matrix_float.cc'`"
test 5935 -eq "$Wc_c" ||
	echo 'mv/src/mv_matrix_float.cc: original size 5935, current size' "$Wc_c"
fi
# ============= mv/src/mv_matrix_int.cc ==============
if test -f 'mv/src/mv_matrix_int.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_matrix_int.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_matrix_int.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_matrix_int.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_matrix_int.cc      Basic vector class (int precision)
//
X
#include "mv_matrix_int.h"
X
unsigned int MV_ColMat_int::size(int i) const 
{
X    if (i==0) return dim0_;
X    if (i==1) return dim1_;
X    else
X    {
X     cerr << "Called MV_ColMat::size(" << i << ")  must be 0 or 1 " << endl;
X     exit(1);
X    }
X
X    // never should be here, but many compilers warn about not
X    // returning a value
X    return 0;
}
X
// NOTE: null construct have ref_ flag turned OFF, otherwise, we can
//          never reset the size of matrix....
MV_ColMat_int::MV_ColMat_int()  : v_(), dim0_(0), dim1_(0) , lda_(0), ref_(0){}
X                                                                
X
MV_ColMat_int::MV_ColMat_int(unsigned int m, unsigned int n) : v_(m*n),
X        dim0_(m), dim1_(n), lda_(m), ref_(0) {}
X
MV_ColMat_int::MV_ColMat_int(unsigned int m, unsigned int n, const int &s) : v_(m*n),
X        dim0_(m), dim1_(n), lda_(m), ref_(0) 
{
X    operator=(s);
}
X
// operators and member functions
X
X
X
X
X
X
MV_ColMat_int& MV_ColMat_int::operator=(const int & s) 
{
X    int M = size(0);
X    int N = size(1);
X
X    if (lda_ == M)      // if continuous, then just assign as a ?
X        v_ =  s;        // single long vector.
X
X    else
X    {
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X    //
X
X        MV_VecIndex I(0,M-1);
X        for (int j=0; j<N; j++)
X        {
X            v_(I) = s;
X            I += lda_;
X        }
X    }
X
X    return *this;
}
X
MV_ColMat_int& MV_ColMat_int::newsize(unsigned int M, unsigned int N)
{
X    v_.newsize(M*N);
X    dim0_ = M;
X    dim1_ = N;
X    lda_ = M;
X
X    return *this;
}
X
MV_ColMat_int& MV_ColMat_int::operator=(const MV_ColMat_int & m) 
{
X
X    int lM = dim0_;     // left hand arg  (this)
X    int lN = dim1_;
X
X    int rM = m.dim0_;   // right hand arg (m)
X    int rN = m.dim1_;
X
X
X    // if the left-hand side is a matrix reference, the we copy the
X    // elements of m *into* the region specfied by the reference.
X    // i.e. inject().
X
X    if (ref_)
X    {
X        // check conformance,       
X        if (lM != rM  || lN != rN)      
X        {
X            cerr << "MV_ColMatRef::operator=  non-conformant assignment.\n";
X            exit(1);
X        }
X    }
X    else
X    {
X        newsize(rM,rN);
X    }
X
X    // at this point the left hand and right hand sides are conformant
X
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X
X    // if both sides are contigous, then just copy as one vector
X    if ( lM == lda_ && rM == m.lda_)
X    {
X        MV_VecIndex I(0,rM*rN-1);
X        v_(I) = m.v_(I);
X    }
X    else
X    {
X        // slower way...
X
X        MV_VecIndex I(0,rM-1);
X        MV_VecIndex K(0,rM-1);
X        for (int j=0; j<rN; j++)
X        {
X            v_(I) = m.v_(K);
X            I += lda_;
X            K += m.lda_;
X        }
X    }
X
X    return *this;   
}
X
MV_ColMat_int::MV_ColMat_int(const MV_ColMat_int & m) : 
X        v_(m.dim0_*m.dim1_), dim0_(m.dim0_),
X        dim1_(m.dim1_), ref_(0), lda_(m.dim0_)
{
X
X    int M = m.dim0_;
X    int N = m.dim1_;
X
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X
X    MV_VecIndex I(0,M-1);
X    MV_VecIndex K(0,M-1);
X    for (int j=0; j<N; j++)
X    {
X        v_(I) = m.v_(K);
X        I += lda_;
X        K += m.lda_;
X    }
}
X
X
X
MV_ColMat_int::MV_ColMat_int(int* d, unsigned int m, unsigned int n) :
X    v_(m*n), dim0_(m), dim1_(n), lda_(m), ref_(0)
{
X    int mn = m*n;
X
X    // d is contiguous, so just copy 1-d vector
X    for (int i=0; i< mn; i++)
X            v_[i] = d[i];
}
X
X
MV_ColMat_int::MV_ColMat_int(int* d, unsigned int m, unsigned int n, 
X        unsigned int lda) :
X    v_(m*n), dim0_(m), dim1_(n), lda_(lda), ref_(0)
{
X    for (int j=0; j< n; j++)
X        for (int i=0; i<m; i++)
X            operator()(i,j) = d[j*lda + i];   // could be made faster!!
}
X
X
MV_ColMat_int MV_ColMat_int::operator()(const MV_VecIndex &I, const MV_VecIndex &J)
{
X    // check that index is not out of bounds
X    //
X    if (I.end() >= dim0_  || J.end() >= dim1_)
X    {
X        cerr << "Matrix index: (" << I.start() << ":" << I.end()  
X             << "," << J.start() << ":" << J.end()   
X             << ") not a subset of (0:" << dim0_ - 1 << ", 0:" 
X             << dim1_-1 << ") " << endl;
X        exit(1);
X    }
X
X    // this automatically returns a reference
X    // 
X    return MV_ColMat_int(&v_[J.start()*lda_ + I.start()], 
X            I.end() - I.start() + 1, 
X            J.end() - J.start() + 1, lda_, MV_Matrix_::ref);
}
X
const MV_ColMat_int MV_ColMat_int::operator()(const MV_VecIndex &I, 
X    const MV_VecIndex &J) const
{
X
X    cerr << "Const operator()(MV_VecIndex, MV_VecIndex) called " << endl;
X
X    // check that index is not out of bounds
X    //
X    if (I.end() >= dim0_  || J.end() >= dim1_)
X    {
X        cerr << "Matrix index: (" << I.start() << ":" << I.end()  
X             << "," << J.start() << ":" << J.end()   
X             << ") not a subset of (0:" << dim0_ - 1 << ", 0:" 
X             << dim1_-1 << ") " << endl;
X        exit(1);
X    }
X
X    // this automatically returns a reference.  we need to 
X    // "cast away" constness here, so the &v_[] arg will
X    // not cause a compiler error.
X    //
X    MV_ColMat_int *t =  (MV_ColMat_int*) this;
X    return MV_ColMat_int(&(t->v_[J.start()*lda_ + I.start()]), 
X            I.end() - I.start() + 1, 
X            J.end() - J.start() + 1, lda_, MV_Matrix_::ref);
}
X
MV_ColMat_int::~MV_ColMat_int() {}
X
ostream&   operator<<(ostream& s, const MV_ColMat_int& V)
{
X    int M = V.size(0);
X    int N = V.size(1);
X
X    for (int i=0; i<M; i++)
X    {
X        for (int j=0; j<N; j++)
X            s << V(i,j) << " " ;
X        s << endl;
X    }
X    
X    return s;
}
X
X
X
SHAR_EOF
chmod 0660 mv/src/mv_matrix_int.cc ||
echo 'restore of mv/src/mv_matrix_int.cc failed'
Wc_c="`wc -c < 'mv/src/mv_matrix_int.cc'`"
test 5857 -eq "$Wc_c" ||
	echo 'mv/src/mv_matrix_int.cc: original size 5857, current size' "$Wc_c"
fi
# ============= mv/src/mv_matrix_type.cc ==============
if test -f 'mv/src/mv_matrix_type.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_matrix_type.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_matrix_type.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_matrix_type.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_matrix_TYPE.cc      Basic vector class (TYPE precision)
//
X
#include "mv_matrix_TYPE.h"
X
unsigned int MV_ColMat_TYPE::size(int i) const 
{
X    if (i==0) return dim0_;
X    if (i==1) return dim1_;
X    else
X    {
X     cerr << "Called MV_ColMat::size(" << i << ")  must be 0 or 1 " << endl;
X     exit(1);
X    }
X
X    // never should be here, but many compilers warn about not
X    // returning a value
X    return 0;
}
X
// NOTE: null construct have ref_ flag turned OFF, otherwise, we can
//          never reset the size of matrix....
MV_ColMat_TYPE::MV_ColMat_TYPE()  : v_(), dim0_(0), dim1_(0) , lda_(0), ref_(0){}
X                                                                
X
MV_ColMat_TYPE::MV_ColMat_TYPE(unsigned int m, unsigned int n) : v_(m*n),
X        dim0_(m), dim1_(n), lda_(m), ref_(0) {}
X
MV_ColMat_TYPE::MV_ColMat_TYPE(unsigned int m, unsigned int n, const TYPE &s) : v_(m*n),
X        dim0_(m), dim1_(n), lda_(m), ref_(0) 
{
X    operator=(s);
}
X
// operators and member functions
X
X
X
X
X
X
MV_ColMat_TYPE& MV_ColMat_TYPE::operator=(const TYPE & s) 
{
X    int M = size(0);
X    int N = size(1);
X
X    if (lda_ == M)      // if continuous, then just assign as a ?
X        v_ =  s;        // single long vector.
X
X    else
X    {
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X    //
X
X        MV_VecIndex I(0,M-1);
X        for (int j=0; j<N; j++)
X        {
X            v_(I) = s;
X            I += lda_;
X        }
X    }
X
X    return *this;
}
X
MV_ColMat_TYPE& MV_ColMat_TYPE::newsize(unsigned int M, unsigned int N)
{
X    v_.newsize(M*N);
X    dim0_ = M;
X    dim1_ = N;
X    lda_ = M;
X
X    return *this;
}
X
MV_ColMat_TYPE& MV_ColMat_TYPE::operator=(const MV_ColMat_TYPE & m) 
{
X
X    int lM = dim0_;     // left hand arg  (this)
X    int lN = dim1_;
X
X    int rM = m.dim0_;   // right hand arg (m)
X    int rN = m.dim1_;
X
X
X    // if the left-hand side is a matrix reference, the we copy the
X    // elements of m *into* the region specfied by the reference.
X    // i.e. inject().
X
X    if (ref_)
X    {
X        // check conformance,       
X        if (lM != rM  || lN != rN)      
X        {
X            cerr << "MV_ColMatRef::operator=  non-conformant assignment.\n";
X            exit(1);
X        }
X    }
X    else
X    {
X        newsize(rM,rN);
X    }
X
X    // at this point the left hand and right hand sides are conformant
X
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X
X    // if both sides are contigous, then just copy as one vector
X    if ( lM == lda_ && rM == m.lda_)
X    {
X        MV_VecIndex I(0,rM*rN-1);
X        v_(I) = m.v_(I);
X    }
X    else
X    {
X        // slower way...
X
X        MV_VecIndex I(0,rM-1);
X        MV_VecIndex K(0,rM-1);
X        for (int j=0; j<rN; j++)
X        {
X            v_(I) = m.v_(K);
X            I += lda_;
X            K += m.lda_;
X        }
X    }
X
X    return *this;   
}
X
MV_ColMat_TYPE::MV_ColMat_TYPE(const MV_ColMat_TYPE & m) : 
X        v_(m.dim0_*m.dim1_), dim0_(m.dim0_),
X        dim1_(m.dim1_), ref_(0), lda_(m.dim0_)
{
X
X    int M = m.dim0_;
X    int N = m.dim1_;
X
X    // this should run much faster than the just accessing each (i,j)
X    // element individually 
X
X    MV_VecIndex I(0,M-1);
X    MV_VecIndex K(0,M-1);
X    for (int j=0; j<N; j++)
X    {
X        v_(I) = m.v_(K);
X        I += lda_;
X        K += m.lda_;
X    }
}
X
X
X
MV_ColMat_TYPE::MV_ColMat_TYPE(TYPE* d, unsigned int m, unsigned int n) :
X    v_(m*n), dim0_(m), dim1_(n), lda_(m), ref_(0)
{
X    int mn = m*n;
X
X    // d is contiguous, so just copy 1-d vector
X    for (int i=0; i< mn; i++)
X            v_[i] = d[i];
}
X
X
MV_ColMat_TYPE::MV_ColMat_TYPE(TYPE* d, unsigned int m, unsigned int n, 
X        unsigned int lda) :
X    v_(m*n), dim0_(m), dim1_(n), lda_(lda), ref_(0)
{
X    for (int j=0; j< n; j++)
X        for (int i=0; i<m; i++)
X            operator()(i,j) = d[j*lda + i];   // could be made faster!!
}
X
X
MV_ColMat_TYPE MV_ColMat_TYPE::operator()(const MV_VecIndex &I, const MV_VecIndex &J)
{
X    // check that index is not out of bounds
X    //
X    if (I.end() >= dim0_  || J.end() >= dim1_)
X    {
X        cerr << "Matrix index: (" << I.start() << ":" << I.end()  
X             << "," << J.start() << ":" << J.end()   
X             << ") not a subset of (0:" << dim0_ - 1 << ", 0:" 
X             << dim1_-1 << ") " << endl;
X        exit(1);
X    }
X
X    // this automatically returns a reference
X    // 
X    return MV_ColMat_TYPE(&v_[J.start()*lda_ + I.start()], 
X            I.end() - I.start() + 1, 
X            J.end() - J.start() + 1, lda_, MV_Matrix_::ref);
}
X
const MV_ColMat_TYPE MV_ColMat_TYPE::operator()(const MV_VecIndex &I, 
X    const MV_VecIndex &J) const
{
X
X    cerr << "Const operator()(MV_VecIndex, MV_VecIndex) called " << endl;
X
X    // check that index is not out of bounds
X    //
X    if (I.end() >= dim0_  || J.end() >= dim1_)
X    {
X        cerr << "Matrix index: (" << I.start() << ":" << I.end()  
X             << "," << J.start() << ":" << J.end()   
X             << ") not a subset of (0:" << dim0_ - 1 << ", 0:" 
X             << dim1_-1 << ") " << endl;
X        exit(1);
X    }
X
X    // this automatically returns a reference.  we need to 
X    // "cast away" constness here, so the &v_[] arg will
X    // not cause a compiler error.
X    //
X    MV_ColMat_TYPE *t =  (MV_ColMat_TYPE*) this;
X    return MV_ColMat_TYPE(&(t->v_[J.start()*lda_ + I.start()]), 
X            I.end() - I.start() + 1, 
X            J.end() - J.start() + 1, lda_, MV_Matrix_::ref);
}
X
MV_ColMat_TYPE::~MV_ColMat_TYPE() {}
X
ostream&   operator<<(ostream& s, const MV_ColMat_TYPE& V)
{
X    int M = V.size(0);
X    int N = V.size(1);
X
X    for (int i=0; i<M; i++)
X    {
X        for (int j=0; j<N; j++)
X            s << V(i,j) << " " ;
X        s << endl;
X    }
X    
X    return s;
}
X
X
X
SHAR_EOF
chmod 0660 mv/src/mv_matrix_type.cc ||
echo 'restore of mv/src/mv_matrix_type.cc failed'
Wc_c="`wc -c < 'mv/src/mv_matrix_type.cc'`"
test 5896 -eq "$Wc_c" ||
	echo 'mv/src/mv_matrix_type.cc: original size 5896, current size' "$Wc_c"
fi
# ============= mv/src/mv_vector_complex.cc ==============
if test -f 'mv/src/mv_vector_complex.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_vector_complex.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_vector_complex.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_vector_complex.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_vector_complex.cc        Basic vector class (complex precision)
//
//      Replace the string "complex " with any data type., e.g.
//          sed '1,$s/complex/double/g' > mv_vector_double.cc
X
X
X                                 
#include "mv_vector_complex.h"
X
X
MV_Vector_complex::MV_Vector_complex()  : p_(0), dim_(0) , ref_(0){};
X
MV_Vector_complex::MV_Vector_complex(unsigned int n) : p_(new complex[n]), dim_(n), 
X            ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: NULL pointer in MV_Vector_complex(int) constructor " << endl;
X        cerr << "       Most likely out of memory... " << endl;
X        exit(1);
X    }
}
X
X
MV_Vector_complex::MV_Vector_complex(unsigned int n, const complex& v) : 
X        p_(new complex[n]), dim_(n), ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: NULL pointer in MV_Vector_complex(int) constructor " << endl;
X        cerr << "       Most likely out of memory... " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = v;
}
X
// operators and member functions
//
X
X
MV_Vector_complex& MV_Vector_complex::operator=(const complex & m) 
{
#ifdef TRACE_VEC
X    cout << "> MV_Vector_complex::operator=(const complex & m)  " << endl;
#endif
X
X    // unroll loops to depth of length 4
X
X    int N = size();
X
X    int Nminus4 = N-4;
X    int i;
X
X    for (i=0; i<Nminus4; )
X    {
X        p_[i++] = m;
X        p_[i++] = m;
X        p_[i++] = m;
X        p_[i++] = m;
X    }
X
X    for (; i<N; p_[i++] = m);   // finish off last piece...
X
#ifdef TRACE_VEC
X    cout << "< MV_Vector_complex::operator=(const complex & m)  " << endl;
#endif
X    return *this;
}
X
X
MV_Vector_complex& MV_Vector_complex::newsize(unsigned int n)
{
#ifdef TRACE_VEC
X    cout << "> MV_Vector_complex::newsize(unsigned int n) " << endl;
#endif
X    if (ref_ )                  // is this structure just a pointer?
X    {
X        {
X            cerr << "MV_Vector::newsize can't operator on references.\n";
X            exit(1);
X        }
X    }
X    else
X    if (dim_ != n )                     // only delete and new if
X    {                                   // the size of memory is really
X        if (p_) delete [] p_;           // changing, otherwise just
X        p_ = new complex[n];                // copy in place.
X        if (p_ == NULL)
X        {
X            cerr << "Error : NULL pointer in operator= " << endl;
X            exit(1);
X        }
X        dim_ = n;
X    }
X
#ifdef TRACE_VEC
X    cout << "< MV_Vector_complex::newsize(unsigned int n) " << endl;
#endif
X
X    return *this;
}
X
X
X    
X
X
MV_Vector_complex& MV_Vector_complex::operator=(const MV_Vector_complex & m) 
{
X
X    int N = m.dim_;
X    int i;
X
X    if (ref_ )                  // is this structure just a pointer?
X    {
X        if (dim_ != m.dim_)     // check conformance,
X        {
X            cerr << "MV_VectorRef::operator=  non-conformant assignment.\n";
X            exit(1);
X        }
X
X        // handle overlapping matrix references
X        if ((m.p_ + m.dim_) >= p_)
X        {
X            // overlap case, copy backwards to avoid overwriting results
X            for (i= N-1; i>=0; i--)
X                p_[i] = m.p_[i];
X        }
X        else
X        {
X            for (i=0; i<N; i++)
X                p_[i] = m.p_[i];
X        }
X                
X    }
X    else
X    {
X        newsize(N);
X
X        // no need to test for overlap, since this region is new
X        for (i =0; i< N; i++)       // careful not to use bcopy()
X            p_[i] = m.p_[i];                // here, but complex::operator= complex.
X    }
X    return *this;   
}
X
X
MV_Vector_complex::MV_Vector_complex(const MV_Vector_complex & m) : p_(new complex[m.dim_]), 
X    dim_(m.dim_) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error:  Null pointer in MV_Vector_complex(const MV_Vector&); " << endl;
X        exit(1);
X    }
X
X    int N = m.dim_;
X
X    for (int i=0; i<N; i++)
X        p_[i] = m.p_[i];
}
X
// note that ref() is initalized with i rather than 1.
// this is so compilers will not generate a warning that i was
// not used in the construction.  (MV_Vector::ref_type is an enum that
// can *only* have the value of 1.
//
X
MV_Vector_complex::MV_Vector_complex(complex* d, unsigned int n, MV_Vector_::ref_type i) : 
X        p_(d), dim_(n) , ref_(i) {}
X
X
MV_Vector_complex::MV_Vector_complex(complex* d, unsigned int n) : p_(new complex[n]), 
X      dim_(n) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: Null pointer in MV_Vector_complex(complex*, int) " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = d[i];
X
}
X
X
X
MV_Vector_complex::MV_Vector_complex(const complex* d, unsigned int n) : p_(new complex[n]), 
X      dim_(n) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: Null pointer in MV_Vector_complex(complex*, int) " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = d[i];
X
}
X
X
MV_Vector_complex MV_Vector_complex::operator()(void)
{
X    return MV_Vector_complex(p_, dim_, MV_Vector_::ref);
}
X
X
const MV_Vector_complex MV_Vector_complex::operator()(void) const
{
X    return MV_Vector_complex(p_, dim_, MV_Vector_::ref);
}
X
X
MV_Vector_complex MV_Vector_complex::operator()(const MV_VecIndex &I) 
{
X    // default parameters
X    if (I.all())
X        return MV_Vector_complex(p_, dim_, MV_Vector_::ref);
X    else
X    {
X    // check that index is not out of bounds
X    //
X        if ( I.end() >= dim_)
X        {
X            cerr << "MV_VecIndex: (" << I.start() << ":" << I.end() << 
X                ") too big for matrix (0:" << dim_ - 1 << ") " << endl;
X            exit(1);
X        }
X        return MV_Vector_complex(p_+ I.start(), I.end() - I.start() + 1,
X            MV_Vector_::ref);
X    }
}
X
X
const MV_Vector_complex MV_Vector_complex::operator()(const MV_VecIndex &I) const
{
X    // check that index is not out of bounds
X    //
X    if ( I.end() >= dim_)
X    {
X        cerr << "MV_VecIndex: (" << I.start() << ":" << I.end() << 
X                ") too big for matrix (0:" << dim_ - 1 << ") " << endl;
X        exit(1);
X    }
X    return MV_Vector_complex(p_+ I.start(), I.end() - I.start() + 1,
X            MV_Vector_::ref);
}
X
X
MV_Vector_complex::~MV_Vector_complex()
{
X        if (p_ && !ref_ ) delete [] p_;
}
X
X
ostream&   operator<<(ostream& s, const MV_Vector_complex& V)
{
X    int N = V.size();
X
X    for (int i=0; i< N; i++)
X        s << V(i) << endl;
X    
X    return s;
}
X
X
X
X
X
SHAR_EOF
chmod 0660 mv/src/mv_vector_complex.cc ||
echo 'restore of mv/src/mv_vector_complex.cc failed'
Wc_c="`wc -c < 'mv/src/mv_vector_complex.cc'`"
test 6486 -eq "$Wc_c" ||
	echo 'mv/src/mv_vector_complex.cc: original size 6486, current size' "$Wc_c"
fi
# ============= mv/src/mv_vector_double.cc ==============
if test -f 'mv/src/mv_vector_double.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_vector_double.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_vector_double.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_vector_double.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_vector_double.cc     Basic vector class (double precision)
//
//      Replace the string "double " with any data type., e.g.
//          sed '1,$s/double/double/g' > mv_vector_double.cc
X
X
X                                 
#include "mv_vector_double.h"
X
X
MV_Vector_double::MV_Vector_double()  : p_(0), dim_(0) , ref_(0){};
X
MV_Vector_double::MV_Vector_double(unsigned int n) : p_(new double[n]), dim_(n), 
X            ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: NULL pointer in MV_Vector_double(int) constructor " << endl;
X        cerr << "       Most likely out of memory... " << endl;
X        exit(1);
X    }
}
X
X
MV_Vector_double::MV_Vector_double(unsigned int n, const double& v) : 
X        p_(new double[n]), dim_(n), ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: NULL pointer in MV_Vector_double(int) constructor " << endl;
X        cerr << "       Most likely out of memory... " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = v;
}
X
// operators and member functions
//
X
X
MV_Vector_double& MV_Vector_double::operator=(const double & m) 
{
#ifdef TRACE_VEC
X    cout << "> MV_Vector_double::operator=(const double & m)  " << endl;
#endif
X
X    // unroll loops to depth of length 4
X
X    int N = size();
X
X    int Nminus4 = N-4;
X    int i;
X
X    for (i=0; i<Nminus4; )
X    {
X        p_[i++] = m;
X        p_[i++] = m;
X        p_[i++] = m;
X        p_[i++] = m;
X    }
X
X    for (; i<N; p_[i++] = m);   // finish off last piece...
X
#ifdef TRACE_VEC
X    cout << "< MV_Vector_double::operator=(const double & m)  " << endl;
#endif
X    return *this;
}
X
X
MV_Vector_double& MV_Vector_double::newsize(unsigned int n)
{
#ifdef TRACE_VEC
X    cout << "> MV_Vector_double::newsize(unsigned int n) " << endl;
#endif
X    if (ref_ )                  // is this structure just a pointer?
X    {
X        {
X            cerr << "MV_Vector::newsize can't operator on references.\n";
X            exit(1);
X        }
X    }
X    else
X    if (dim_ != n )                     // only delete and new if
X    {                                   // the size of memory is really
X        if (p_) delete [] p_;           // changing, otherwise just
X        p_ = new double[n];             // copy in place.
X        if (p_ == NULL)
X        {
X            cerr << "Error : NULL pointer in operator= " << endl;
X            exit(1);
X        }
X        dim_ = n;
X    }
X
#ifdef TRACE_VEC
X    cout << "< MV_Vector_double::newsize(unsigned int n) " << endl;
#endif
X
X    return *this;
}
X
X
X    
X
X
MV_Vector_double& MV_Vector_double::operator=(const MV_Vector_double & m) 
{
X
X    int N = m.dim_;
X    int i;
X
X    if (ref_ )                  // is this structure just a pointer?
X    {
X        if (dim_ != m.dim_)     // check conformance,
X        {
X            cerr << "MV_VectorRef::operator=  non-conformant assignment.\n";
X            exit(1);
X        }
X
X        // handle overlapping matrix references
X        if ((m.p_ + m.dim_) >= p_)
X        {
X            // overlap case, copy backwards to avoid overwriting results
X            for (i= N-1; i>=0; i--)
X                p_[i] = m.p_[i];
X        }
X        else
X        {
X            for (i=0; i<N; i++)
X                p_[i] = m.p_[i];
X        }
X                
X    }
X    else
X    {
X        newsize(N);
X
X        // no need to test for overlap, since this region is new
X        for (i =0; i< N; i++)       // careful not to use bcopy()
X            p_[i] = m.p_[i];                // here, but double::operator= double.
X    }
X    return *this;   
}
X
X
MV_Vector_double::MV_Vector_double(const MV_Vector_double & m) : p_(new double[m.dim_]), 
X    dim_(m.dim_) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error:  Null pointer in MV_Vector_double(const MV_Vector&); " << endl;
X        exit(1);
X    }
X
X    int N = m.dim_;
X
X    for (int i=0; i<N; i++)
X        p_[i] = m.p_[i];
}
X
// note that ref() is initalized with i rather than 1.
// this is so compilers will not generate a warning that i was
// not used in the construction.  (MV_Vector::ref_type is an enum that
// can *only* have the value of 1.
//
X
MV_Vector_double::MV_Vector_double(double* d, unsigned int n, MV_Vector_::ref_type i) : 
X        p_(d), dim_(n) , ref_(i) {}
X
X
MV_Vector_double::MV_Vector_double(double* d, unsigned int n) : p_(new double[n]), 
X      dim_(n) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: Null pointer in MV_Vector_double(double*, int) " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = d[i];
X
}
X
X
X
MV_Vector_double::MV_Vector_double(const double* d, unsigned int n) : p_(new double[n]), 
X      dim_(n) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: Null pointer in MV_Vector_double(double*, int) " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = d[i];
X
}
X
X
MV_Vector_double MV_Vector_double::operator()(void)
{
X    return MV_Vector_double(p_, dim_, MV_Vector_::ref);
}
X
X
const MV_Vector_double MV_Vector_double::operator()(void) const
{
X    return MV_Vector_double(p_, dim_, MV_Vector_::ref);
}
X
X
MV_Vector_double MV_Vector_double::operator()(const MV_VecIndex &I) 
{
X    // default parameters
X    if (I.all())
X        return MV_Vector_double(p_, dim_, MV_Vector_::ref);
X    else
X    {
X    // check that index is not out of bounds
X    //
X        if ( I.end() >= dim_)
X        {
X            cerr << "MV_VecIndex: (" << I.start() << ":" << I.end() << 
X                ") too big for matrix (0:" << dim_ - 1 << ") " << endl;
X            exit(1);
X        }
X        return MV_Vector_double(p_+ I.start(), I.end() - I.start() + 1,
X            MV_Vector_::ref);
X    }
}
X
X
const MV_Vector_double MV_Vector_double::operator()(const MV_VecIndex &I) const
{
X    // check that index is not out of bounds
X    //
X    if ( I.end() >= dim_)
X    {
X        cerr << "MV_VecIndex: (" << I.start() << ":" << I.end() << 
X                ") too big for matrix (0:" << dim_ - 1 << ") " << endl;
X        exit(1);
X    }
X    return MV_Vector_double(p_+ I.start(), I.end() - I.start() + 1,
X            MV_Vector_::ref);
}
X
X
MV_Vector_double::~MV_Vector_double()
{
X        if (p_ && !ref_ ) delete [] p_;
}
X
X
ostream&   operator<<(ostream& s, const MV_Vector_double& V)
{
X    int N = V.size();
X
X    for (int i=0; i< N; i++)
X        s << V(i) << endl;
X    
X    return s;
}
X
X
X
X
X
SHAR_EOF
chmod 0660 mv/src/mv_vector_double.cc ||
echo 'restore of mv/src/mv_vector_double.cc failed'
Wc_c="`wc -c < 'mv/src/mv_vector_double.cc'`"
test 6411 -eq "$Wc_c" ||
	echo 'mv/src/mv_vector_double.cc: original size 6411, current size' "$Wc_c"
fi
# ============= mv/src/mv_vector_float.cc ==============
if test -f 'mv/src/mv_vector_float.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_vector_float.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_vector_float.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_vector_float.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_vector_float.cc      Basic vector class (float precision)
//
//      Replace the string "float " with any data type., e.g.
//          sed '1,$s/float/double/g' > mv_vector_double.cc
X
X
X                                 
#include "mv_vector_float.h"
X
X
MV_Vector_float::MV_Vector_float()  : p_(0), dim_(0) , ref_(0){};
X
MV_Vector_float::MV_Vector_float(unsigned int n) : p_(new float[n]), dim_(n), 
X            ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: NULL pointer in MV_Vector_float(int) constructor " << endl;
X        cerr << "       Most likely out of memory... " << endl;
X        exit(1);
X    }
}
X
X
MV_Vector_float::MV_Vector_float(unsigned int n, const float& v) : 
X        p_(new float[n]), dim_(n), ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: NULL pointer in MV_Vector_float(int) constructor " << endl;
X        cerr << "       Most likely out of memory... " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = v;
}
X
// operators and member functions
//
X
X
MV_Vector_float& MV_Vector_float::operator=(const float & m) 
{
#ifdef TRACE_VEC
X    cout << "> MV_Vector_float::operator=(const float & m)  " << endl;
#endif
X
X    // unroll loops to depth of length 4
X
X    int N = size();
X
X    int Nminus4 = N-4;
X    int i;
X
X    for (i=0; i<Nminus4; )
X    {
X        p_[i++] = m;
X        p_[i++] = m;
X        p_[i++] = m;
X        p_[i++] = m;
X    }
X
X    for (; i<N; p_[i++] = m);   // finish off last piece...
X
#ifdef TRACE_VEC
X    cout << "< MV_Vector_float::operator=(const float & m)  " << endl;
#endif
X    return *this;
}
X
X
MV_Vector_float& MV_Vector_float::newsize(unsigned int n)
{
#ifdef TRACE_VEC
X    cout << "> MV_Vector_float::newsize(unsigned int n) " << endl;
#endif
X    if (ref_ )                  // is this structure just a pointer?
X    {
X        {
X            cerr << "MV_Vector::newsize can't operator on references.\n";
X            exit(1);
X        }
X    }
X    else
X    if (dim_ != n )                     // only delete and new if
X    {                                   // the size of memory is really
X        if (p_) delete [] p_;           // changing, otherwise just
X        p_ = new float[n];              // copy in place.
X        if (p_ == NULL)
X        {
X            cerr << "Error : NULL pointer in operator= " << endl;
X            exit(1);
X        }
X        dim_ = n;
X    }
X
#ifdef TRACE_VEC
X    cout << "< MV_Vector_float::newsize(unsigned int n) " << endl;
#endif
X
X    return *this;
}
X
X
X    
X
X
MV_Vector_float& MV_Vector_float::operator=(const MV_Vector_float & m) 
{
X
X    int N = m.dim_;
X    int i;
X
X    if (ref_ )                  // is this structure just a pointer?
X    {
X        if (dim_ != m.dim_)     // check conformance,
X        {
X            cerr << "MV_VectorRef::operator=  non-conformant assignment.\n";
X            exit(1);
X        }
X
X        // handle overlapping matrix references
X        if ((m.p_ + m.dim_) >= p_)
X        {
X            // overlap case, copy backwards to avoid overwriting results
X            for (i= N-1; i>=0; i--)
X                p_[i] = m.p_[i];
X        }
X        else
X        {
X            for (i=0; i<N; i++)
X                p_[i] = m.p_[i];
X        }
X                
X    }
X    else
X    {
X        newsize(N);
X
X        // no need to test for overlap, since this region is new
X        for (i =0; i< N; i++)       // careful not to use bcopy()
X            p_[i] = m.p_[i];                // here, but float::operator= float.
X    }
X    return *this;   
}
X
X
MV_Vector_float::MV_Vector_float(const MV_Vector_float & m) : p_(new float[m.dim_]), 
X    dim_(m.dim_) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error:  Null pointer in MV_Vector_float(const MV_Vector&); " << endl;
X        exit(1);
X    }
X
X    int N = m.dim_;
X
X    for (int i=0; i<N; i++)
X        p_[i] = m.p_[i];
}
X
// note that ref() is initalized with i rather than 1.
// this is so compilers will not generate a warning that i was
// not used in the construction.  (MV_Vector::ref_type is an enum that
// can *only* have the value of 1.
//
X
MV_Vector_float::MV_Vector_float(float* d, unsigned int n, MV_Vector_::ref_type i) : 
X        p_(d), dim_(n) , ref_(i) {}
X
X
MV_Vector_float::MV_Vector_float(float* d, unsigned int n) : p_(new float[n]), 
X      dim_(n) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: Null pointer in MV_Vector_float(float*, int) " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = d[i];
X
}
X
X
X
MV_Vector_float::MV_Vector_float(const float* d, unsigned int n) : p_(new float[n]), 
X      dim_(n) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: Null pointer in MV_Vector_float(float*, int) " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = d[i];
X
}
X
X
MV_Vector_float MV_Vector_float::operator()(void)
{
X    return MV_Vector_float(p_, dim_, MV_Vector_::ref);
}
X
X
const MV_Vector_float MV_Vector_float::operator()(void) const
{
X    return MV_Vector_float(p_, dim_, MV_Vector_::ref);
}
X
X
MV_Vector_float MV_Vector_float::operator()(const MV_VecIndex &I) 
{
X    // default parameters
X    if (I.all())
X        return MV_Vector_float(p_, dim_, MV_Vector_::ref);
X    else
X    {
X    // check that index is not out of bounds
X    //
X        if ( I.end() >= dim_)
X        {
X            cerr << "MV_VecIndex: (" << I.start() << ":" << I.end() << 
X                ") too big for matrix (0:" << dim_ - 1 << ") " << endl;
X            exit(1);
X        }
X        return MV_Vector_float(p_+ I.start(), I.end() - I.start() + 1,
X            MV_Vector_::ref);
X    }
}
X
X
const MV_Vector_float MV_Vector_float::operator()(const MV_VecIndex &I) const
{
X    // check that index is not out of bounds
X    //
X    if ( I.end() >= dim_)
X    {
X        cerr << "MV_VecIndex: (" << I.start() << ":" << I.end() << 
X                ") too big for matrix (0:" << dim_ - 1 << ") " << endl;
X        exit(1);
X    }
X    return MV_Vector_float(p_+ I.start(), I.end() - I.start() + 1,
X            MV_Vector_::ref);
}
X
X
MV_Vector_float::~MV_Vector_float()
{
X        if (p_ && !ref_ ) delete [] p_;
}
X
X
ostream&   operator<<(ostream& s, const MV_Vector_float& V)
{
X    int N = V.size();
X
X    for (int i=0; i< N; i++)
X        s << V(i) << endl;
X    
X    return s;
}
X
X
X
X
X
SHAR_EOF
chmod 0660 mv/src/mv_vector_float.cc ||
echo 'restore of mv/src/mv_vector_float.cc failed'
Wc_c="`wc -c < 'mv/src/mv_vector_float.cc'`"
test 6344 -eq "$Wc_c" ||
	echo 'mv/src/mv_vector_float.cc: original size 6344, current size' "$Wc_c"
fi
# ============= mv/src/mv_vector_int.cc ==============
if test -f 'mv/src/mv_vector_int.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_vector_int.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_vector_int.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_vector_int.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_vector_int.cc        Basic vector class (int precision)
//
//      Replace the string "int " with any data type., e.g.
//          sed '1,$s/int/double/g' > mv_vector_double.cc
X
X
X                                 
#include "mv_vector_int.h"
X
X
MV_Vector_int::MV_Vector_int()  : p_(0), dim_(0) , ref_(0){};
X
MV_Vector_int::MV_Vector_int(unsigned int n) : p_(new int[n]), dim_(n), 
X            ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: NULL pointer in MV_Vector_int(int) constructor " << endl;
X        cerr << "       Most likely out of memory... " << endl;
X        exit(1);
X    }
}
X
X
MV_Vector_int::MV_Vector_int(unsigned int n, const int& v) : 
X        p_(new int[n]), dim_(n), ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: NULL pointer in MV_Vector_int(int) constructor " << endl;
X        cerr << "       Most likely out of memory... " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = v;
}
X
// operators and member functions
//
X
X
MV_Vector_int& MV_Vector_int::operator=(const int & m) 
{
#ifdef TRACE_VEC
X    cout << "> MV_Vector_int::operator=(const int & m)  " << endl;
#endif
X
X    // unroll loops to depth of length 4
X
X    int N = size();
X
X    int Nminus4 = N-4;
X    int i;
X
X    for (i=0; i<Nminus4; )
X    {
X        p_[i++] = m;
X        p_[i++] = m;
X        p_[i++] = m;
X        p_[i++] = m;
X    }
X
X    for (; i<N; p_[i++] = m);   // finish off last piece...
X
#ifdef TRACE_VEC
X    cout << "< MV_Vector_int::operator=(const int & m)  " << endl;
#endif
X    return *this;
}
X
X
MV_Vector_int& MV_Vector_int::newsize(unsigned int n)
{
#ifdef TRACE_VEC
X    cout << "> MV_Vector_int::newsize(unsigned int n) " << endl;
#endif
X    if (ref_ )                  // is this structure just a pointer?
X    {
X        {
X            cerr << "MV_Vector::newsize can't operator on references.\n";
X            exit(1);
X        }
X    }
X    else
X    if (dim_ != n )                     // only delete and new if
X    {                                   // the size of memory is really
X        if (p_) delete [] p_;           // changing, otherwise just
X        p_ = new int[n];                // copy in place.
X        if (p_ == NULL)
X        {
X            cerr << "Error : NULL pointer in operator= " << endl;
X            exit(1);
X        }
X        dim_ = n;
X    }
X
#ifdef TRACE_VEC
X    cout << "< MV_Vector_int::newsize(unsigned int n) " << endl;
#endif
X
X    return *this;
}
X
X
X    
X
X
MV_Vector_int& MV_Vector_int::operator=(const MV_Vector_int & m) 
{
X
X    int N = m.dim_;
X    int i;
X
X    if (ref_ )                  // is this structure just a pointer?
X    {
X        if (dim_ != m.dim_)     // check conformance,
X        {
X            cerr << "MV_VectorRef::operator=  non-conformant assignment.\n";
X            exit(1);
X        }
X
X        // handle overlapping matrix references
X        if ((m.p_ + m.dim_) >= p_)
X        {
X            // overlap case, copy backwards to avoid overwriting results
X            for (i= N-1; i>=0; i--)
X                p_[i] = m.p_[i];
X        }
X        else
X        {
X            for (i=0; i<N; i++)
X                p_[i] = m.p_[i];
X        }
X                
X    }
X    else
X    {
X        newsize(N);
X
X        // no need to test for overlap, since this region is new
X        for (i =0; i< N; i++)       // careful not to use bcopy()
X            p_[i] = m.p_[i];                // here, but int::operator= int.
X    }
X    return *this;   
}
X
X
MV_Vector_int::MV_Vector_int(const MV_Vector_int & m) : p_(new int[m.dim_]), 
X    dim_(m.dim_) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error:  Null pointer in MV_Vector_int(const MV_Vector&); " << endl;
X        exit(1);
X    }
X
X    int N = m.dim_;
X
X    for (int i=0; i<N; i++)
X        p_[i] = m.p_[i];
}
X
// note that ref() is initalized with i rather than 1.
// this is so compilers will not generate a warning that i was
// not used in the construction.  (MV_Vector::ref_type is an enum that
// can *only* have the value of 1.
//
X
MV_Vector_int::MV_Vector_int(int* d, unsigned int n, MV_Vector_::ref_type i) : 
X        p_(d), dim_(n) , ref_(i) {}
X
X
MV_Vector_int::MV_Vector_int(int* d, unsigned int n) : p_(new int[n]), 
X      dim_(n) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: Null pointer in MV_Vector_int(int*, int) " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = d[i];
X
}
X
X
X
MV_Vector_int::MV_Vector_int(const int* d, unsigned int n) : p_(new int[n]), 
X      dim_(n) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: Null pointer in MV_Vector_int(int*, int) " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = d[i];
X
}
X
X
MV_Vector_int MV_Vector_int::operator()(void)
{
X    return MV_Vector_int(p_, dim_, MV_Vector_::ref);
}
X
X
const MV_Vector_int MV_Vector_int::operator()(void) const
{
X    return MV_Vector_int(p_, dim_, MV_Vector_::ref);
}
X
X
MV_Vector_int MV_Vector_int::operator()(const MV_VecIndex &I) 
{
X    // default parameters
X    if (I.all())
X        return MV_Vector_int(p_, dim_, MV_Vector_::ref);
X    else
X    {
X    // check that index is not out of bounds
X    //
X        if ( I.end() >= dim_)
X        {
X            cerr << "MV_VecIndex: (" << I.start() << ":" << I.end() << 
X                ") too big for matrix (0:" << dim_ - 1 << ") " << endl;
X            exit(1);
X        }
X        return MV_Vector_int(p_+ I.start(), I.end() - I.start() + 1,
X            MV_Vector_::ref);
X    }
}
X
X
const MV_Vector_int MV_Vector_int::operator()(const MV_VecIndex &I) const
{
X    // check that index is not out of bounds
X    //
X    if ( I.end() >= dim_)
X    {
X        cerr << "MV_VecIndex: (" << I.start() << ":" << I.end() << 
X                ") too big for matrix (0:" << dim_ - 1 << ") " << endl;
X        exit(1);
X    }
X    return MV_Vector_int(p_+ I.start(), I.end() - I.start() + 1,
X            MV_Vector_::ref);
}
X
X
MV_Vector_int::~MV_Vector_int()
{
X        if (p_ && !ref_ ) delete [] p_;
}
X
X
ostream&   operator<<(ostream& s, const MV_Vector_int& V)
{
X    int N = V.size();
X
X    for (int i=0; i< N; i++)
X        s << V(i) << endl;
X    
X    return s;
}
X
X
X
X
X
SHAR_EOF
chmod 0660 mv/src/mv_vector_int.cc ||
echo 'restore of mv/src/mv_vector_int.cc failed'
Wc_c="`wc -c < 'mv/src/mv_vector_int.cc'`"
test 6210 -eq "$Wc_c" ||
	echo 'mv/src/mv_vector_int.cc: original size 6210, current size' "$Wc_c"
fi
# ============= mv/src/mv_vector_type.cc ==============
if test -f 'mv/src/mv_vector_type.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/mv_vector_type.cc (File already exists)'
else
echo 'x - extracting mv/src/mv_vector_type.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/mv_vector_type.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      mv_vector_TYPE.cc       Basic vector class (TYPE precision)
//
//      Replace the string "TYPE " with any data type., e.g.
//          sed '1,$s/TYPE/double/g' > mv_vector_double.cc
X
X
X                                 
#include "mv_vector_TYPE.h"
X
X
MV_Vector_TYPE::MV_Vector_TYPE()  : p_(0), dim_(0) , ref_(0){};
X
MV_Vector_TYPE::MV_Vector_TYPE(unsigned int n) : p_(new TYPE[n]), dim_(n), 
X            ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: NULL pointer in MV_Vector_TYPE(int) constructor " << endl;
X        cerr << "       Most likely out of memory... " << endl;
X        exit(1);
X    }
}
X
X
MV_Vector_TYPE::MV_Vector_TYPE(unsigned int n, const TYPE& v) : 
X        p_(new TYPE[n]), dim_(n), ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: NULL pointer in MV_Vector_TYPE(int) constructor " << endl;
X        cerr << "       Most likely out of memory... " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = v;
}
X
// operators and member functions
//
X
X
MV_Vector_TYPE& MV_Vector_TYPE::operator=(const TYPE & m) 
{
#ifdef TRACE_VEC
X    cout << "> MV_Vector_TYPE::operator=(const TYPE & m)  " << endl;
#endif
X
X    // unroll loops to depth of length 4
X
X    int N = size();
X
X    int Nminus4 = N-4;
X    int i;
X
X    for (i=0; i<Nminus4; )
X    {
X        p_[i++] = m;
X        p_[i++] = m;
X        p_[i++] = m;
X        p_[i++] = m;
X    }
X
X    for (; i<N; p_[i++] = m);   // finish off last piece...
X
#ifdef TRACE_VEC
X    cout << "< MV_Vector_TYPE::operator=(const TYPE & m)  " << endl;
#endif
X    return *this;
}
X
X
MV_Vector_TYPE& MV_Vector_TYPE::newsize(unsigned int n)
{
#ifdef TRACE_VEC
X    cout << "> MV_Vector_TYPE::newsize(unsigned int n) " << endl;
#endif
X    if (ref_ )                  // is this structure just a pointer?
X    {
X        {
X            cerr << "MV_Vector::newsize can't operator on references.\n";
X            exit(1);
X        }
X    }
X    else
X    if (dim_ != n )                     // only delete and new if
X    {                                   // the size of memory is really
X        if (p_) delete [] p_;           // changing, otherwise just
X        p_ = new TYPE[n];               // copy in place.
X        if (p_ == NULL)
X        {
X            cerr << "Error : NULL pointer in operator= " << endl;
X            exit(1);
X        }
X        dim_ = n;
X    }
X
#ifdef TRACE_VEC
X    cout << "< MV_Vector_TYPE::newsize(unsigned int n) " << endl;
#endif
X
X    return *this;
}
X
X
X    
X
X
MV_Vector_TYPE& MV_Vector_TYPE::operator=(const MV_Vector_TYPE & m) 
{
X
X    int N = m.dim_;
X    int i;
X
X    if (ref_ )                  // is this structure just a pointer?
X    {
X        if (dim_ != m.dim_)     // check conformance,
X        {
X            cerr << "MV_VectorRef::operator=  non-conformant assignment.\n";
X            exit(1);
X        }
X
X        // handle overlapping matrix references
X        if ((m.p_ + m.dim_) >= p_)
X        {
X            // overlap case, copy backwards to avoid overwriting results
X            for (i= N-1; i>=0; i--)
X                p_[i] = m.p_[i];
X        }
X        else
X        {
X            for (i=0; i<N; i++)
X                p_[i] = m.p_[i];
X        }
X                
X    }
X    else
X    {
X        newsize(N);
X
X        // no need to test for overlap, since this region is new
X        for (i =0; i< N; i++)       // careful not to use bcopy()
X            p_[i] = m.p_[i];                // here, but TYPE::operator= TYPE.
X    }
X    return *this;   
}
X
X
MV_Vector_TYPE::MV_Vector_TYPE(const MV_Vector_TYPE & m) : p_(new TYPE[m.dim_]), 
X    dim_(m.dim_) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error:  Null pointer in MV_Vector_TYPE(const MV_Vector&); " << endl;
X        exit(1);
X    }
X
X    int N = m.dim_;
X
X    for (int i=0; i<N; i++)
X        p_[i] = m.p_[i];
}
X
// note that ref() is initalized with i rather than 1.
// this is so compilers will not generate a warning that i was
// not used in the construction.  (MV_Vector::ref_type is an enum that
// can *only* have the value of 1.
//
X
MV_Vector_TYPE::MV_Vector_TYPE(TYPE* d, unsigned int n, MV_Vector_::ref_type i) : 
X        p_(d), dim_(n) , ref_(i) {}
X
X
MV_Vector_TYPE::MV_Vector_TYPE(TYPE* d, unsigned int n) : p_(new TYPE[n]), 
X      dim_(n) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: Null pointer in MV_Vector_TYPE(TYPE*, int) " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = d[i];
X
}
X
X
X
MV_Vector_TYPE::MV_Vector_TYPE(const TYPE* d, unsigned int n) : p_(new TYPE[n]), 
X      dim_(n) , ref_(0)
{
X    if (p_ == NULL)
X    {
X        cerr << "Error: Null pointer in MV_Vector_TYPE(TYPE*, int) " << endl;
X        exit(1);
X    }
X    for (int i=0; i<n; i++)
X        p_[i] = d[i];
X
}
X
X
MV_Vector_TYPE MV_Vector_TYPE::operator()(void)
{
X    return MV_Vector_TYPE(p_, dim_, MV_Vector_::ref);
}
X
X
const MV_Vector_TYPE MV_Vector_TYPE::operator()(void) const
{
X    return MV_Vector_TYPE(p_, dim_, MV_Vector_::ref);
}
X
X
MV_Vector_TYPE MV_Vector_TYPE::operator()(const MV_VecIndex &I) 
{
X    // default parameters
X    if (I.all())
X        return MV_Vector_TYPE(p_, dim_, MV_Vector_::ref);
X    else
X    {
X    // check that index is not out of bounds
X    //
X        if ( I.end() >= dim_)
X        {
X            cerr << "MV_VecIndex: (" << I.start() << ":" << I.end() << 
X                ") too big for matrix (0:" << dim_ - 1 << ") " << endl;
X            exit(1);
X        }
X        return MV_Vector_TYPE(p_+ I.start(), I.end() - I.start() + 1,
X            MV_Vector_::ref);
X    }
}
X
X
const MV_Vector_TYPE MV_Vector_TYPE::operator()(const MV_VecIndex &I) const
{
X    // check that index is not out of bounds
X    //
X    if ( I.end() >= dim_)
X    {
X        cerr << "MV_VecIndex: (" << I.start() << ":" << I.end() << 
X                ") too big for matrix (0:" << dim_ - 1 << ") " << endl;
X        exit(1);
X    }
X    return MV_Vector_TYPE(p_+ I.start(), I.end() - I.start() + 1,
X            MV_Vector_::ref);
}
X
X
MV_Vector_TYPE::~MV_Vector_TYPE()
{
X        if (p_ && !ref_ ) delete [] p_;
}
X
X
ostream&   operator<<(ostream& s, const MV_Vector_TYPE& V)
{
X    int N = V.size();
X
X    for (int i=0; i< N; i++)
X        s << V(i) << endl;
X    
X    return s;
}
X
X
X
X
X
SHAR_EOF
chmod 0660 mv/src/mv_vector_type.cc ||
echo 'restore of mv/src/mv_vector_type.cc failed'
Wc_c="`wc -c < 'mv/src/mv_vector_type.cc'`"
test 6277 -eq "$Wc_c" ||
	echo 'mv/src/mv_vector_type.cc: original size 6277, current size' "$Wc_c"
fi
# ============= mv/src/ostream_complex.cc ==============
if test -f 'mv/src/ostream_complex.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/ostream_complex.cc (File already exists)'
else
echo 'x - extracting mv/src/ostream_complex.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/ostream_complex.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      ostream_complex.cc      Add I/O routine for printing out complex
//                              numbers.
//
X
X                                 
#include <complex.h>
X
// AT&T Cfront does not provide for cout << complex ...
//
ostream& operator<<(ostream &s, complex z)
{
X    s << real(z) << " "  << imag(z) ;
X    return s;
}
X
SHAR_EOF
chmod 0660 mv/src/ostream_complex.cc ||
echo 'restore of mv/src/ostream_complex.cc failed'
Wc_c="`wc -c < 'mv/src/ostream_complex.cc'`"
test 448 -eq "$Wc_c" ||
	echo 'mv/src/ostream_complex.cc: original size 448, current size' "$Wc_c"
fi
# ============= mv/src/makefile ==============
if test -f 'mv/src/makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/src/makefile (File already exists)'
else
echo 'x - extracting mv/src/makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/src/makefile' &&
#
# Makefile for sparselb src
#
X
include ../makefile.def
X
# note: the base file for each class foo contains the keywork TYPE
# must be modified by an editor (something that doesn't parse since
# TYPE can be appear in the middle of a word.)  The base file name
# for double, float, int, etc, is called foo_type.h, while the base
# files for user-defined (non-primitive) classes (e.g. complex) is 
# foo_user_type.h
X
MV_INCLUDE_DIR 	= ../include
MV_LIB_A		= ../lib/mvlib.a
INCLUDES = -I$(MV_INCLUDE_DIR) 
X
SRCS 	= \
X	  mv_vector_double.cc	\
X	  mv_matrix_double.cc \
X	  mv_blas1_double.cc \
X	  mv_vector_float.cc	\
X	  mv_matrix_float.cc \
X	  mv_blas1_float.cc \
X	  mv_vector_int.cc \
X	  mv_matrix_int.cc \
X	  mv_vector_complex.cc \
X	  mv_matrix_complex.cc \
X	  mv_blas1_complex.cc \
X	  ostream_complex.cc
X
OBJS    = $(SRCS:.cc=.o)
X
X
all: lib
X
srcs: $(SRCS)
lib: $(MV_LIB_A)
X
$(MV_LIB_A) : $(OBJS)
X	@ ar rv $(MV_LIB_A) $?
X	@ case x$(HASRANLIB) in xt ) echo ranlib; ranlib $(MV_LIB_A);; esac
X
clean: 
X	/bin/rm -f $(OBJS) 
X
wipe:
X	/bin/rm -f $(OBJS) $(MV_LIB_A) 
SHAR_EOF
chmod 0640 mv/src/makefile ||
echo 'restore of mv/src/makefile failed'
Wc_c="`wc -c < 'mv/src/makefile'`"
test 1057 -eq "$Wc_c" ||
	echo 'mv/src/makefile: original size 1057, current size' "$Wc_c"
fi
# ============= mv/testing/tblas1.cc ==============
if test ! -d 'mv/testing'; then
    echo 'x - creating directory mv/testing'
    mkdir 'mv/testing'
fi
if test -f 'mv/testing/tblas1.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tblas1.cc (File already exists)'
else
echo 'x - extracting mv/testing/tblas1.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tblas1.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tmat.cc        Testing routine for MV++ matrix class
//
//      Usage:  <M> <N> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_ColMat methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
#include "mv_vector.h"
X
X
int
main(int argc, char *argv[])
{
X    if (argc<2)
X    {
X        cout << "Usage: " << " M " << endl;
X        exit(1);
X    }
X
X    int N = atoi(argv[1]);
X    int j;
X    cout << "Using N = " << N << " N = " << N << endl;
X
X    MV_Vector<double> x(N), y(N), z(N);
X
X    for (j=0; j<N; j++)
X    {
X        x(j) = j;
X        y(j) = j / 100.0;
X    }
X
X    cout << " x " << endl;
X    cout << x << endl;
X
X    cout << "Testing MV_Vector * scalar:   " << endl;
X    z = x * 2.0;
X    cout << " z = x * 2.0 : " << endl;
X    cout << z << endl;
X    z = z * 2.0;
X    cout << " z = z * 2.0 : " << endl;
X    cout << z << endl;
X
X
X    cout << "Testing MV_Vector *= scalar:  " << endl;
X     (x *= 2.0) *= 2.0;
X    cout << " (x *= 2.0) *= 2.0: " << endl;
X    cout << x << endl;
X
X    cout << "Testing MV_Vector += MV_Vector:  " << endl;
X    x = 2.0; 
X    y = 1.0;
X
X    cout << "x=2.0, y=1.0; x += y: " << endl;
X    x += y;
X    cout << x << endl;
X
X    cout << "Testing MV_Vector -= MV_Vector:  " << endl;
X    x = 2.0; 
X    y = 1.0;
X
X    cout << "x=2.0, y=1.0; x -= y: " << endl;
X    x -= y;
X    cout << x << endl;
X
X
X    return 0;
}
SHAR_EOF
chmod 0660 mv/testing/tblas1.cc ||
echo 'restore of mv/testing/tblas1.cc failed'
Wc_c="`wc -c < 'mv/testing/tblas1.cc'`"
test 1772 -eq "$Wc_c" ||
	echo 'mv/testing/tblas1.cc: original size 1772, current size' "$Wc_c"
fi
# ============= mv/testing/tblas1_complex.cc ==============
if test -f 'mv/testing/tblas1_complex.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tblas1_complex.cc (File already exists)'
else
echo 'x - extracting mv/testing/tblas1_complex.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tblas1_complex.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tmat.cc        Testing routine for MV++ matrix class
//
//      Usage:  <M> <N> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_ColMat methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
#include "vector_defs.h"
#include VECTOR_H
X
X
int
main(int argc, char *argv[])
{
X    if (argc<2)
X    {
X        cout << "Usage: " << " M " << endl;
X        exit(1);
X    }
X
X    int N = atoi(argv[1]);
X    int j;
X    cout << "Using N = " << N << " N = " << N << endl;
X
X    VECTOR_complex x(N), y(N), z(N);
X
X    for (j=0; j<N; j++)
X    {
X        x(j) = j;
X        y(j) = j / 100;
X    }
X
X    cout << " x " << endl;
X    cout << x << endl;
X
X    cout << "Testing Vector * scalar:   " << endl;
X    z = x * 2;
X    cout << " z = x * 2 : " << endl;
X    cout << z << endl;
X    z = z * 2;
X    cout << " z = z * 2 : " << endl;
X    cout << z << endl;
X
X
X    cout << "Testing Vector *= scalar:  " << endl;
X     (x *= 2) *= 2;
X    cout << " (x *= 2) *= 2: " << endl;
X    cout << x << endl;
X
X    cout << "Testing Vector += Vector:  " << endl;
X    x = (complex) 2; 
X    y = (complex) 1;
X
X    cout << "x=2, y=1; x += y: " << endl;
X    x += y;
X    cout << x << endl;
X
X    cout << "Testing Vector -= Vector:  " << endl;
X    x = (complex) 2; 
X    y = (complex) 1;
X
X    cout << "x=2, y=1; x -= y: " << endl;
X    x -= y;
X    cout << x << endl;
X
X
X    return 0;
}
SHAR_EOF
chmod 0660 mv/testing/tblas1_complex.cc ||
echo 'restore of mv/testing/tblas1_complex.cc failed'
Wc_c="`wc -c < 'mv/testing/tblas1_complex.cc'`"
test 1777 -eq "$Wc_c" ||
	echo 'mv/testing/tblas1_complex.cc: original size 1777, current size' "$Wc_c"
fi
# ============= mv/testing/tblas1_double.cc ==============
if test -f 'mv/testing/tblas1_double.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tblas1_double.cc (File already exists)'
else
echo 'x - extracting mv/testing/tblas1_double.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tblas1_double.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tmat.cc        Testing routine for MV++ matrix class
//
//      Usage:  <M> <N> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_ColMat methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
#include "vector_defs.h"
#include VECTOR_H
X
X
int
main(int argc, char *argv[])
{
X    if (argc<2)
X    {
X        cout << "Usage: " << " M " << endl;
X        exit(1);
X    }
X
X    int N = atoi(argv[1]);
X    int j;
X    cout << "Using N = " << N << " N = " << N << endl;
X
X    VECTOR_double x(N), y(N), z(N);
X
X    for (j=0; j<N; j++)
X    {
X        x(j) = j;
X        y(j) = j / 100;
X    }
X
X    cout << " x " << endl;
X    cout << x << endl;
X
X    cout << "Testing Vector * scalar:   " << endl;
X    z = x * 2;
X    cout << " z = x * 2 : " << endl;
X    cout << z << endl;
X    z = z * 2;
X    cout << " z = z * 2 : " << endl;
X    cout << z << endl;
X
X
X    cout << "Testing Vector *= scalar:  " << endl;
X     (x *= 2) *= 2;
X    cout << " (x *= 2) *= 2: " << endl;
X    cout << x << endl;
X
X    cout << "Testing Vector += Vector:  " << endl;
X    x = (double) 2; 
X    y = (double) 1;
X
X    cout << "x=2, y=1; x += y: " << endl;
X    x += y;
X    cout << x << endl;
X
X    cout << "Testing Vector -= Vector:  " << endl;
X    x = (double) 2; 
X    y = (double) 1;
X
X    cout << "x=2, y=1; x -= y: " << endl;
X    x -= y;
X    cout << x << endl;
X
X
X    return 0;
}
SHAR_EOF
chmod 0660 mv/testing/tblas1_double.cc ||
echo 'restore of mv/testing/tblas1_double.cc failed'
Wc_c="`wc -c < 'mv/testing/tblas1_double.cc'`"
test 1772 -eq "$Wc_c" ||
	echo 'mv/testing/tblas1_double.cc: original size 1772, current size' "$Wc_c"
fi
# ============= mv/testing/tblas1_float.cc ==============
if test -f 'mv/testing/tblas1_float.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tblas1_float.cc (File already exists)'
else
echo 'x - extracting mv/testing/tblas1_float.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tblas1_float.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tmat.cc        Testing routine for MV++ matrix class
//
//      Usage:  <M> <N> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_ColMat methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
#include "vector_defs.h"
#include VECTOR_H
X
X
int
main(int argc, char *argv[])
{
X    if (argc<2)
X    {
X        cout << "Usage: " << " M " << endl;
X        exit(1);
X    }
X
X    int N = atoi(argv[1]);
X    int j;
X    cout << "Using N = " << N << " N = " << N << endl;
X
X    VECTOR_float x(N), y(N), z(N);
X
X    for (j=0; j<N; j++)
X    {
X        x(j) = j;
X        y(j) = j / 100;
X    }
X
X    cout << " x " << endl;
X    cout << x << endl;
X
X    cout << "Testing Vector * scalar:   " << endl;
X    z = x * 2;
X    cout << " z = x * 2 : " << endl;
X    cout << z << endl;
X    z = z * 2;
X    cout << " z = z * 2 : " << endl;
X    cout << z << endl;
X
X
X    cout << "Testing Vector *= scalar:  " << endl;
X     (x *= 2) *= 2;
X    cout << " (x *= 2) *= 2: " << endl;
X    cout << x << endl;
X
X    cout << "Testing Vector += Vector:  " << endl;
X    x = (float) 2; 
X    y = (float) 1;
X
X    cout << "x=2, y=1; x += y: " << endl;
X    x += y;
X    cout << x << endl;
X
X    cout << "Testing Vector -= Vector:  " << endl;
X    x = (float) 2; 
X    y = (float) 1;
X
X    cout << "x=2, y=1; x -= y: " << endl;
X    x -= y;
X    cout << x << endl;
X
X
X    return 0;
}
SHAR_EOF
chmod 0660 mv/testing/tblas1_float.cc ||
echo 'restore of mv/testing/tblas1_float.cc failed'
Wc_c="`wc -c < 'mv/testing/tblas1_float.cc'`"
test 1767 -eq "$Wc_c" ||
	echo 'mv/testing/tblas1_float.cc: original size 1767, current size' "$Wc_c"
fi
# ============= mv/testing/tblas1_int.cc ==============
if test -f 'mv/testing/tblas1_int.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tblas1_int.cc (File already exists)'
else
echo 'x - extracting mv/testing/tblas1_int.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tblas1_int.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tmat.cc        Testing routine for MV++ matrix class
//
//      Usage:  <M> <N> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_ColMat methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
#include "vector_defs.h"
#include VECTOR_H
X
X
int
main(int argc, char *argv[])
{
X    if (argc<2)
X    {
X        cout << "Usage: " << " M " << endl;
X        exit(1);
X    }
X
X    int N = atoi(argv[1]);
X    int j;
X    cout << "Using N = " << N << " N = " << N << endl;
X
X    VECTOR_int x(N), y(N), z(N);
X
X    for (j=0; j<N; j++)
X    {
X        x(j) = j;
X        y(j) = j / 100;
X    }
X
X    cout << " x " << endl;
X    cout << x << endl;
X
X    cout << "Testing Vector * scalar:   " << endl;
X    z = x * 2;
X    cout << " z = x * 2 : " << endl;
X    cout << z << endl;
X    z = z * 2;
X    cout << " z = z * 2 : " << endl;
X    cout << z << endl;
X
X
X    cout << "Testing Vector *= scalar:  " << endl;
X     (x *= 2) *= 2;
X    cout << " (x *= 2) *= 2: " << endl;
X    cout << x << endl;
X
X    cout << "Testing Vector += Vector:  " << endl;
X    x = (int) 2; 
X    y = (int) 1;
X
X    cout << "x=2, y=1; x += y: " << endl;
X    x += y;
X    cout << x << endl;
X
X    cout << "Testing Vector -= Vector:  " << endl;
X    x = (int) 2; 
X    y = (int) 1;
X
X    cout << "x=2, y=1; x -= y: " << endl;
X    x -= y;
X    cout << x << endl;
X
X
X    return 0;
}
SHAR_EOF
chmod 0660 mv/testing/tblas1_int.cc ||
echo 'restore of mv/testing/tblas1_int.cc failed'
Wc_c="`wc -c < 'mv/testing/tblas1_int.cc'`"
test 1757 -eq "$Wc_c" ||
	echo 'mv/testing/tblas1_int.cc: original size 1757, current size' "$Wc_c"
fi
# ============= mv/testing/tblas1_type.cc ==============
if test -f 'mv/testing/tblas1_type.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tblas1_type.cc (File already exists)'
else
echo 'x - extracting mv/testing/tblas1_type.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tblas1_type.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tmat.cc        Testing routine for MV++ matrix class
//
//      Usage:  <M> <N> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_ColMat methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
#include "vector_defs.h"
#include VECTOR_H
X
X
int
main(int argc, char *argv[])
{
X    if (argc<2)
X    {
X        cout << "Usage: " << " M " << endl;
X        exit(1);
X    }
X
X    int N = atoi(argv[1]);
X    int j;
X    cout << "Using N = " << N << " N = " << N << endl;
X
X    VECTOR_TYPE x(N), y(N), z(N);
X
X    for (j=0; j<N; j++)
X    {
X        x(j) = j;
X        y(j) = j / 100;
X    }
X
X    cout << " x " << endl;
X    cout << x << endl;
X
X    cout << "Testing Vector * scalar:   " << endl;
X    z = x * 2;
X    cout << " z = x * 2 : " << endl;
X    cout << z << endl;
X    z = z * 2;
X    cout << " z = z * 2 : " << endl;
X    cout << z << endl;
X
X
X    cout << "Testing Vector *= scalar:  " << endl;
X     (x *= 2) *= 2;
X    cout << " (x *= 2) *= 2: " << endl;
X    cout << x << endl;
X
X    cout << "Testing Vector += Vector:  " << endl;
X    x = (TYPE) 2; 
X    y = (TYPE) 1;
X
X    cout << "x=2, y=1; x += y: " << endl;
X    x += y;
X    cout << x << endl;
X
X    cout << "Testing Vector -= Vector:  " << endl;
X    x = (TYPE) 2; 
X    y = (TYPE) 1;
X
X    cout << "x=2, y=1; x -= y: " << endl;
X    x -= y;
X    cout << x << endl;
X
X
X    return 0;
}
SHAR_EOF
chmod 0660 mv/testing/tblas1_type.cc ||
echo 'restore of mv/testing/tblas1_type.cc failed'
Wc_c="`wc -c < 'mv/testing/tblas1_type.cc'`"
test 1762 -eq "$Wc_c" ||
	echo 'mv/testing/tblas1_type.cc: original size 1762, current size' "$Wc_c"
fi
# ============= mv/testing/tmat.cc ==============
if test -f 'mv/testing/tmat.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tmat.cc (File already exists)'
else
echo 'x - extracting mv/testing/tmat.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tmat.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tmat.cc        Testing routine for MV++ matrix class
//
//      Usage:  <M> <N> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_ColMat methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
#include "mv_matrix.h"
// #include "systime.c"
X
// example function to zero-out a matrix:  illustrates how to pass
// matrixes by "reference" (modifiable), as opposed to by "value"
//
void foo(MV_ColMat<double> *Aptr)
{
X    MV_ColMat<double> &A = *Aptr;
X
X    A = 0.0;
}
X
// example funciton to return MV_ColMats:  (returns matrix + scalar)
//
MV_ColMat<double> fexample(const MV_ColMat<double> A, double s)
{
X    int M = A.size(0);
X    int N = A.size(1);
X    MV_ColMat<double> B(M,N);
X
X    for (int j=0; j<N; j++)
X        for (int i=0; i<M; i++)
X            B(i,j) = A(i,j) + s;
X
X    return B;
}
X
X
main(int argc, char *argv[])
{
X    if (argc<7)
X    {
X        cout << "Usage: " << " M N Istart Iend Jstart Jend" << endl;
X        exit(1);
X    }
X
X    int M = atoi(argv[1]);
X    int N = atoi(argv[2]);
X    int Istart = atoi(argv[3]);
X    int Jstart = atoi(argv[4]);
X    int Iend = atoi(argv[5]);
X    int Jend = atoi(argv[6]);
X    int i,j;
X    cout << "Using M = " << M << " N = " << N << 
X            "   Istart = " << Istart << "   Iend = " <<  Iend <<
X            "   Jstart = " << Jstart << "   Jend = " <<  Jend << endl;
X
X
X
X    MV_ColMat<double> C;
X    cout << " Test null constructor:  MV_ColMat C() " << endl;
X    cout << C << endl;
X
X
X    MV_ColMat<double> A(M,N);
X    cout << " Test MV_ColMat(int,int) constructor:  MV_ColMat A(M,N) " << endl;
X    cout << " values should be uninitalized.. " << endl;
X    cout << A << endl;
X
X    MV_ColMat<double> B(M,N, 3.0);
X    cout << " Test MV_ColMat(int, int, val) constructor:  MV_ColMat B(N, 3.0) " 
X                << endl;
X    cout << "   all values should be 3.0:  " << endl;
X    cout << B << endl;
X
X    cout << " Test A(i,j) indexing, set A(i,j) = 100*j + i, and B(i) = -A(i,j)"
X        << endl;
X
X    for (j=0; j<N; j++)
X        for (i=0; i<M; i++)
X        {
X            A(i,j) = 100*i+j;
X            B(i,j) =  - A(i,j);
X        }
X
X    cout << " A " << endl;
X    cout << A << endl;
X    cout << " B " << endl;
X    cout <<  B << endl;
X
X
X
X    cout << "Testing MV_VecIndex I(Istart, Iend) " << endl;
X    //
X    MV_VecIndex I(Istart, Iend);
X    MV_VecIndex J(Jstart, Jend);
X    //
X    cout << "I = (" << Istart << ":"<< Iend <<") " << endl;
X    cout << "J = (" << Jstart << ":"<< Jend <<") " << endl;
X
X    cout << "Test A(I,J) = B(I,J) " <<  endl ;
X    A(I,J) = B(I,J);
X    cout << A << endl;
X
X    cout << "Testing A(I,J) = 1.1 " << endl;
X    A(I,J) = 1.1;
X    cout << "A" << endl << A << endl;
X
X    cout << "Testing MV_VecIndex + operators: " << endl;
X    cout << " A = 0.0; A(I+1,J-1) = 1.0; " << endl;
X    //
X    A = 0.0; 
X    A(I+1,J-1) = 1.0;
X    //
X    cout << " A " << endl << A << endl;
X
#if 0
X    MV_VecIndex K( N/2, N/2 );
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/2, N/2 );" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A = 0.0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << "Test = when matrices are overlapping  " << endl;
X    cout << " A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); " << endl;
X    //
X    A(MV_VecIndex(0, N-1)) = B; 
X    A(J+1) = A(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X    cout << "Testing MV_ColMat<double> &c = C(I)" << endl;
X    MV_ColMat<double> &c = C(I);
X    cout << " c " << endl;
X    cout << c << endl;
X
X    cout << "Testing c = B(I) " << endl;
X    c  = B(I);
X    cout << "c " << endl;
X    cout << c << endl;
X
X    cout << " C " << endl;
X    cout << C << endl;
X
X    cout << "Testing passing submatrixs to functions: calling foo(&c) " 
X        << endl << "  where foo zeros out a matrix " << endl;
X    foo(&c);
X    cout << "C" << endl << C << endl;
X
X    MV_ColMat<double> F(N, 9.0);
X    cout << endl << "Test constructors from exisitng memory : " << endl;
X    cout <<  " MV_ColMat<double> E(&F(0),N) " << endl;
X
X    MV_ColMat<double> E(&F[0], N);
X    cout << "E : " << endl << E << endl;
X
X    cout << " Now modify F(0) = 99.9 " << endl;
X    F(0) = 99.9;
X    cout << "E should not be changed:" << endl;
X    cout << E << endl;
X
X    cout << "Test reference constructors from exisitng memory : " << endl;
X    cout <<  " MV_ColMat<double> G(&F(0),N, MV_ColMat_::ref) " << endl;
X
X    MV_ColMat<double> G(&F[0], N, MV_ColMat_::ref);
X
X    cout << " Now modify F(0) = 99.9 " << endl;
X    F(0) = 99.9;
X    cout << "G " << endl;
X    cout << G << endl;
X
X    cout << "Now set G = 5.0, F should change also " << endl;
X    //
X    G = 5.0;
X    //
X    cout << " F: " << endl << F << endl;
X
X
X    cout << "Testing returning submatrixs from functions:  " 
X        << endl << "   MV_ColMat<double> K = fexample(A,1.0); " << endl;
X    //
X    MV_ColMat<double> K = fexample(A,1.0);
X    //
X    cout << "A" << endl << A << endl;
X    cout << "K" << endl << K << endl;
#endif
X
X
X    return 0;
}
SHAR_EOF
chmod 0660 mv/testing/tmat.cc ||
echo 'restore of mv/testing/tmat.cc failed'
Wc_c="`wc -c < 'mv/testing/tmat.cc'`"
test 5418 -eq "$Wc_c" ||
	echo 'mv/testing/tmat.cc: original size 5418, current size' "$Wc_c"
fi
# ============= mv/testing/tmat2.cc ==============
if test -f 'mv/testing/tmat2.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tmat2.cc (File already exists)'
else
echo 'x - extracting mv/testing/tmat2.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tmat2.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
#include <iostream.h>
#include <stdlib.h>
X
#include "mv_matrix.h"
X
void foo(MV_ColMat<double> *Aptr)
{
X    MV_ColMat<double> &A = *Aptr;
X
X    A = 0.0;
}
X
main(int argc, char *argv[])
{
X    if (argc<7)
X    {
X        cout << "Usage " << argv[0] << " M N start0 end0  start1 end1" << endl;
X        exit(1);
X    }
X
X    int M = atoi(argv[1]);
X    int N = atoi(argv[2]);
X    int s0 = atoi(argv[3]);
X    int e0 = atoi(argv[4]);
X    int s1 = atoi(argv[5]);
X    int e1 = atoi(argv[6]);
X
X    cout << "Using M = " << M << endl;
X    cout << "Using N = " << N << endl;
X    cout << "Using start0 = " << s0 << endl;
X    cout << "Using end0   = " << e0 << endl;
X    cout << "Using start1 = " << s1 << endl;
X    cout << "Using end1   = " << e1 << endl << endl;;
X
X
X    MV_ColMat<double> A(M,N);
X    MV_ColMat<double> B(M,N);
X
X    A = 3.0;
X    B = 7.0;
X
X    A( M/2, N/2) = 0.0;
X    cout << " A=3.0;   A(M/2, N/2) = 0.0 " << endl;
X    cout << A << endl;
X
X
X    MV_VecIndex I(s0, e0);
X    MV_VecIndex J(s1, e1);
X
X
X    cout << "I = (" << s0 << ":"<< e0 <<") " << endl;
X    cout << "J = (" << s1 << ":"<< e1 <<") " << endl;
X
X    A(I,J+1) = B(I,J);
X    cout << "A(I,J+1) = B(I,J) " <<  endl << A << endl;
X
X
X    A(I,J) = 8.0;
X    cout << "A(I,J) = 8.0 " <<  endl << A << endl;
X
#if 0
// The following test section attempts to take the address of a temporary
// result and hence not compilable on all C++ platforms.  
X
X    cout << "calling foo(&A(I)) " << endl;
X    foo(&A(I));
X    cout << "A(I)" << endl << A << endl;
X
X    MV_ColMat<int> C(M, N);
X    MV_ColMat<int> &c = C(I,J);
X
X    C = 1;
X    c = 0;
X
X    cout << "After renaming c to be C(I,J), and executing c = 0.0 "
X        << endl << C << endl;
#endif
X
X    return (0);
}
X
SHAR_EOF
chmod 0660 mv/testing/tmat2.cc ||
echo 'restore of mv/testing/tmat2.cc failed'
Wc_c="`wc -c < 'mv/testing/tmat2.cc'`"
test 1814 -eq "$Wc_c" ||
	echo 'mv/testing/tmat2.cc: original size 1814, current size' "$Wc_c"
fi
# ============= mv/testing/tmat_complex.cc ==============
if test -f 'mv/testing/tmat_complex.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tmat_complex.cc (File already exists)'
else
echo 'x - extracting mv/testing/tmat_complex.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tmat_complex.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tmat.cc        Testing routine for MV++ matrix class
//
//      Usage:  <M> <N> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_ColMat methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
X
#include "vector_defs.h"
#include MATRIX_H
X
// #include "systime.c"
X
// example function to zero-out a matrix:  illustrates how to pass
// matrixes by "reference" (modifiable), as opposed to by "value"
//
void foo(MATRIX_complex *Aptr)
{
X    MATRIX_complex &A = *Aptr;
X
X    A = (complex) 0;
}
X
// example funciton to return MV_ColMats:  (returns matrix + scalar)
//
MATRIX_complex fexample(const MATRIX_complex A, complex s)
{
X    int M = A.size(0);
X    int N = A.size(1);
X    MATRIX_complex B(M,N);
X
X    for (int j=0; j<N; j++)
X        for (int i=0; i<M; i++)
X            B(i,j) = A(i,j) + s;
X
X    return B;
}
X
X
main(int argc, char *argv[])
{
X    if (argc<7)
X    {
X        cout << "Usage: " << " M N Istart Iend Jstart Jend" << endl;
X        exit(1);
X    }
X
X    int M = atoi(argv[1]);
X    int N = atoi(argv[2]);
X    int Istart = atoi(argv[3]);
X    int Jstart = atoi(argv[4]);
X    int Iend = atoi(argv[5]);
X    int Jend = atoi(argv[6]);
X    int i,j;
X    cout << "Using M = " << M << " N = " << N << 
X            "   Istart = " << Istart << "   Iend = " <<  Iend <<
X            "   Jstart = " << Jstart << "   Jend = " <<  Jend << endl;
X
X
X
X    MATRIX_complex C;
X    cout << " Test null constructor:  MV_ColMat C() " << endl;
X    cout << C << endl;
X
X
X    MATRIX_complex A(M,N);
X    cout << " Test MV_ColMat(int,int) constructor:  MV_ColMat A(M,N) " << endl;
X    cout << " values should be uninitalized.. " << endl;
X    cout << A << endl;
X
X    MATRIX_complex B(M,N, 3);
X    cout << " Test MV_ColMat(int, int, val) constructor:  MV_ColMat B(N, 3.0) " 
X                << endl;
X    cout << "   all values should be 3:  " << endl;
X    cout << B << endl;
X
X    cout << " Test A(i,j) indexing, set A(i,j) = 100*j + i, and B(i) = -A(i,j)"
X        << endl;
X
X    for (j=0; j<N; j++)
X        for (i=0; i<M; i++)
X        {
X            A(i,j) = 100*i+j;
X            B(i,j) =  - A(i,j);
X        }
X
X    cout << " A " << endl;
X    cout << A << endl;
X    cout << " B " << endl;
X    cout <<  B << endl;
X
X
X
X    cout << "Testing MV_VecIndex I(Istart, Iend) " << endl;
X    //
X    MV_VecIndex I(Istart, Iend);
X    MV_VecIndex J(Jstart, Jend);
X    //
X    cout << "I = (" << Istart << ":"<< Iend <<") " << endl;
X    cout << "J = (" << Jstart << ":"<< Jend <<") " << endl;
X
X    cout << "Test A(I,J) = B(I,J) " <<  endl ;
X    A(I,J) = B(I,J);
X    cout << A << endl;
X
X    cout << "Testing A(I,J) = 1.1 " << endl;
X    A(I,J) = 11;
X    cout << "A" << endl << A << endl;
X
X    cout << "Testing MV_VecIndex + operators: " << endl;
X    cout << " A = 0.0; A(I+1,J-1) = 1.0; " << endl;
X    //
X    A = (complex) 0; 
X    A(I+1,J-1) = (complex) 1;
X    //
X    cout << " A " << endl << A << endl;
X
#if 0
X    MV_VecIndex K( N/2, N/2 );
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/2, N/2 );" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A = 0.0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << "Test = when matrices are overlapping  " << endl;
X    cout << " A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); " << endl;
X    //
X    A(MV_VecIndex(0, N-1)) = B; 
X    A(J+1) = A(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X    cout << "Testing MATRIX_complex &c = C(I)" << endl;
X    MATRIX_complex &c = C(I);
X    cout << " c " << endl;
X    cout << c << endl;
X
X    cout << "Testing c = B(I) " << endl;
X    c  = B(I);
X    cout << "c " << endl;
X    cout << c << endl;
X
X    cout << " C " << endl;
X    cout << C << endl;
X
X    cout << "Testing passing submatrixs to functions: calling foo(&c) " 
X        << endl << "  where foo zeros out a matrix " << endl;
X    foo(&c);
X    cout << "C" << endl << C << endl;
X
X    MATRIX_complex F(N, 90);
X    cout << endl << "Test constructors from exisitng memory : " << endl;
X    cout <<  " MATRIX_complex E(&F(0),N) " << endl;
X
X    MATRIX_complex E(&F[0], N);
X    cout << "E : " << endl << E << endl;
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (complex) 999;
X    cout << "E should not be changed:" << endl;
X    cout << E << endl;
X
X    cout << "Test reference constructors from exisitng memory : " << endl;
X    cout <<  " MATRIX_complex G(&F(0),N, MV_Matrix_::ref) " << endl;
X
X    MATRIX_complex G(&F[0], N, MV_Matrix_::ref);
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (complex) 999;
X    cout << "G " << endl;
X    cout << G << endl;
X
X    cout << "Now set G = 5, F should change also " << endl;
X    //
X    G = (complex) 5;
X    //
X    cout << " F: " << endl << F << endl;
X
X
X    cout << "Testing returning submatrixs from functions:  " 
X        << endl << "   MATRIX_complex K = fexample(A,1); " << endl;
X    //
X    MATRIX_complex K = fexample(A,1);
X    //
X    cout << "A" << endl << A << endl;
X    cout << "K" << endl << K << endl;
#endif
X
X
X    return 0;
}
SHAR_EOF
chmod 0660 mv/testing/tmat_complex.cc ||
echo 'restore of mv/testing/tmat_complex.cc failed'
Wc_c="`wc -c < 'mv/testing/tmat_complex.cc'`"
test 5426 -eq "$Wc_c" ||
	echo 'mv/testing/tmat_complex.cc: original size 5426, current size' "$Wc_c"
fi
# ============= mv/testing/tmat_double.cc ==============
if test -f 'mv/testing/tmat_double.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tmat_double.cc (File already exists)'
else
echo 'x - extracting mv/testing/tmat_double.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tmat_double.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tmat.cc        Testing routine for MV++ matrix class
//
//      Usage:  <M> <N> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_ColMat methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
X
#include "vector_defs.h"
#include MATRIX_H
X
// #include "systime.c"
X
// example function to zero-out a matrix:  illustrates how to pass
// matrixes by "reference" (modifiable), as opposed to by "value"
//
void foo(MATRIX_double *Aptr)
{
X    MATRIX_double &A = *Aptr;
X
X    A = (double) 0;
}
X
// example funciton to return MV_ColMats:  (returns matrix + scalar)
//
MATRIX_double fexample(const MATRIX_double A, double s)
{
X    int M = A.size(0);
X    int N = A.size(1);
X    MATRIX_double B(M,N);
X
X    for (int j=0; j<N; j++)
X        for (int i=0; i<M; i++)
X            B(i,j) = A(i,j) + s;
X
X    return B;
}
X
X
main(int argc, char *argv[])
{
X    if (argc<7)
X    {
X        cout << "Usage: " << " M N Istart Iend Jstart Jend" << endl;
X        exit(1);
X    }
X
X    int M = atoi(argv[1]);
X    int N = atoi(argv[2]);
X    int Istart = atoi(argv[3]);
X    int Jstart = atoi(argv[4]);
X    int Iend = atoi(argv[5]);
X    int Jend = atoi(argv[6]);
X    int i,j;
X    cout << "Using M = " << M << " N = " << N << 
X            "   Istart = " << Istart << "   Iend = " <<  Iend <<
X            "   Jstart = " << Jstart << "   Jend = " <<  Jend << endl;
X
X
X
X    MATRIX_double C;
X    cout << " Test null constructor:  MV_ColMat C() " << endl;
X    cout << C << endl;
X
X
X    MATRIX_double A(M,N);
X    cout << " Test MV_ColMat(int,int) constructor:  MV_ColMat A(M,N) " << endl;
X    cout << " values should be uninitalized.. " << endl;
X    cout << A << endl;
X
X    MATRIX_double B(M,N, 3);
X    cout << " Test MV_ColMat(int, int, val) constructor:  MV_ColMat B(N, 3.0) " 
X                << endl;
X    cout << "   all values should be 3:  " << endl;
X    cout << B << endl;
X
X    cout << " Test A(i,j) indexing, set A(i,j) = 100*j + i, and B(i) = -A(i,j)"
X        << endl;
X
X    for (j=0; j<N; j++)
X        for (i=0; i<M; i++)
X        {
X            A(i,j) = 100*i+j;
X            B(i,j) =  - A(i,j);
X        }
X
X    cout << " A " << endl;
X    cout << A << endl;
X    cout << " B " << endl;
X    cout <<  B << endl;
X
X
X
X    cout << "Testing MV_VecIndex I(Istart, Iend) " << endl;
X    //
X    MV_VecIndex I(Istart, Iend);
X    MV_VecIndex J(Jstart, Jend);
X    //
X    cout << "I = (" << Istart << ":"<< Iend <<") " << endl;
X    cout << "J = (" << Jstart << ":"<< Jend <<") " << endl;
X
X    cout << "Test A(I,J) = B(I,J) " <<  endl ;
X    A(I,J) = B(I,J);
X    cout << A << endl;
X
X    cout << "Testing A(I,J) = 1.1 " << endl;
X    A(I,J) = 11;
X    cout << "A" << endl << A << endl;
X
X    cout << "Testing MV_VecIndex + operators: " << endl;
X    cout << " A = 0.0; A(I+1,J-1) = 1.0; " << endl;
X    //
X    A = (double) 0; 
X    A(I+1,J-1) = (double) 1;
X    //
X    cout << " A " << endl << A << endl;
X
#if 0
X    MV_VecIndex K( N/2, N/2 );
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/2, N/2 );" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A = 0.0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << "Test = when matrices are overlapping  " << endl;
X    cout << " A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); " << endl;
X    //
X    A(MV_VecIndex(0, N-1)) = B; 
X    A(J+1) = A(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X    cout << "Testing MATRIX_double &c = C(I)" << endl;
X    MATRIX_double &c = C(I);
X    cout << " c " << endl;
X    cout << c << endl;
X
X    cout << "Testing c = B(I) " << endl;
X    c  = B(I);
X    cout << "c " << endl;
X    cout << c << endl;
X
X    cout << " C " << endl;
X    cout << C << endl;
X
X    cout << "Testing passing submatrixs to functions: calling foo(&c) " 
X        << endl << "  where foo zeros out a matrix " << endl;
X    foo(&c);
X    cout << "C" << endl << C << endl;
X
X    MATRIX_double F(N, 90);
X    cout << endl << "Test constructors from exisitng memory : " << endl;
X    cout <<  " MATRIX_double E(&F(0),N) " << endl;
X
X    MATRIX_double E(&F[0], N);
X    cout << "E : " << endl << E << endl;
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (double) 999;
X    cout << "E should not be changed:" << endl;
X    cout << E << endl;
X
X    cout << "Test reference constructors from exisitng memory : " << endl;
X    cout <<  " MATRIX_double G(&F(0),N, MV_Matrix_::ref) " << endl;
X
X    MATRIX_double G(&F[0], N, MV_Matrix_::ref);
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (double) 999;
X    cout << "G " << endl;
X    cout << G << endl;
X
X    cout << "Now set G = 5, F should change also " << endl;
X    //
X    G = (double) 5;
X    //
X    cout << " F: " << endl << F << endl;
X
X
X    cout << "Testing returning submatrixs from functions:  " 
X        << endl << "   MATRIX_double K = fexample(A,1); " << endl;
X    //
X    MATRIX_double K = fexample(A,1);
X    //
X    cout << "A" << endl << A << endl;
X    cout << "K" << endl << K << endl;
#endif
X
X
X    return 0;
}
SHAR_EOF
chmod 0660 mv/testing/tmat_double.cc ||
echo 'restore of mv/testing/tmat_double.cc failed'
Wc_c="`wc -c < 'mv/testing/tmat_double.cc'`"
test 5402 -eq "$Wc_c" ||
	echo 'mv/testing/tmat_double.cc: original size 5402, current size' "$Wc_c"
fi
# ============= mv/testing/tmat_float.cc ==============
if test -f 'mv/testing/tmat_float.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tmat_float.cc (File already exists)'
else
echo 'x - extracting mv/testing/tmat_float.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tmat_float.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tmat.cc        Testing routine for MV++ matrix class
//
//      Usage:  <M> <N> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_ColMat methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
X
#include "vector_defs.h"
#include MATRIX_H
X
// #include "systime.c"
X
// example function to zero-out a matrix:  illustrates how to pass
// matrixes by "reference" (modifiable), as opposed to by "value"
//
void foo(MATRIX_float *Aptr)
{
X    MATRIX_float &A = *Aptr;
X
X    A = (float) 0;
}
X
// example funciton to return MV_ColMats:  (returns matrix + scalar)
//
MATRIX_float fexample(const MATRIX_float A, float s)
{
X    int M = A.size(0);
X    int N = A.size(1);
X    MATRIX_float B(M,N);
X
X    for (int j=0; j<N; j++)
X        for (int i=0; i<M; i++)
X            B(i,j) = A(i,j) + s;
X
X    return B;
}
X
X
main(int argc, char *argv[])
{
X    if (argc<7)
X    {
X        cout << "Usage: " << " M N Istart Iend Jstart Jend" << endl;
X        exit(1);
X    }
X
X    int M = atoi(argv[1]);
X    int N = atoi(argv[2]);
X    int Istart = atoi(argv[3]);
X    int Jstart = atoi(argv[4]);
X    int Iend = atoi(argv[5]);
X    int Jend = atoi(argv[6]);
X    int i,j;
X    cout << "Using M = " << M << " N = " << N << 
X            "   Istart = " << Istart << "   Iend = " <<  Iend <<
X            "   Jstart = " << Jstart << "   Jend = " <<  Jend << endl;
X
X
X
X    MATRIX_float C;
X    cout << " Test null constructor:  MV_ColMat C() " << endl;
X    cout << C << endl;
X
X
X    MATRIX_float A(M,N);
X    cout << " Test MV_ColMat(int,int) constructor:  MV_ColMat A(M,N) " << endl;
X    cout << " values should be uninitalized.. " << endl;
X    cout << A << endl;
X
X    MATRIX_float B(M,N, 3);
X    cout << " Test MV_ColMat(int, int, val) constructor:  MV_ColMat B(N, 3.0) " 
X                << endl;
X    cout << "   all values should be 3:  " << endl;
X    cout << B << endl;
X
X    cout << " Test A(i,j) indexing, set A(i,j) = 100*j + i, and B(i) = -A(i,j)"
X        << endl;
X
X    for (j=0; j<N; j++)
X        for (i=0; i<M; i++)
X        {
X            A(i,j) = 100*i+j;
X            B(i,j) =  - A(i,j);
X        }
X
X    cout << " A " << endl;
X    cout << A << endl;
X    cout << " B " << endl;
X    cout <<  B << endl;
X
X
X
X    cout << "Testing MV_VecIndex I(Istart, Iend) " << endl;
X    //
X    MV_VecIndex I(Istart, Iend);
X    MV_VecIndex J(Jstart, Jend);
X    //
X    cout << "I = (" << Istart << ":"<< Iend <<") " << endl;
X    cout << "J = (" << Jstart << ":"<< Jend <<") " << endl;
X
X    cout << "Test A(I,J) = B(I,J) " <<  endl ;
X    A(I,J) = B(I,J);
X    cout << A << endl;
X
X    cout << "Testing A(I,J) = 1.1 " << endl;
X    A(I,J) = 11;
X    cout << "A" << endl << A << endl;
X
X    cout << "Testing MV_VecIndex + operators: " << endl;
X    cout << " A = 0.0; A(I+1,J-1) = 1.0; " << endl;
X    //
X    A = (float) 0; 
X    A(I+1,J-1) = (float) 1;
X    //
X    cout << " A " << endl << A << endl;
X
#if 0
X    MV_VecIndex K( N/2, N/2 );
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/2, N/2 );" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A = 0.0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << "Test = when matrices are overlapping  " << endl;
X    cout << " A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); " << endl;
X    //
X    A(MV_VecIndex(0, N-1)) = B; 
X    A(J+1) = A(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X    cout << "Testing MATRIX_float &c = C(I)" << endl;
X    MATRIX_float &c = C(I);
X    cout << " c " << endl;
X    cout << c << endl;
X
X    cout << "Testing c = B(I) " << endl;
X    c  = B(I);
X    cout << "c " << endl;
X    cout << c << endl;
X
X    cout << " C " << endl;
X    cout << C << endl;
X
X    cout << "Testing passing submatrixs to functions: calling foo(&c) " 
X        << endl << "  where foo zeros out a matrix " << endl;
X    foo(&c);
X    cout << "C" << endl << C << endl;
X
X    MATRIX_float F(N, 90);
X    cout << endl << "Test constructors from exisitng memory : " << endl;
X    cout <<  " MATRIX_float E(&F(0),N) " << endl;
X
X    MATRIX_float E(&F[0], N);
X    cout << "E : " << endl << E << endl;
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (float) 999;
X    cout << "E should not be changed:" << endl;
X    cout << E << endl;
X
X    cout << "Test reference constructors from exisitng memory : " << endl;
X    cout <<  " MATRIX_float G(&F(0),N, MV_Matrix_::ref) " << endl;
X
X    MATRIX_float G(&F[0], N, MV_Matrix_::ref);
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (float) 999;
X    cout << "G " << endl;
X    cout << G << endl;
X
X    cout << "Now set G = 5, F should change also " << endl;
X    //
X    G = (float) 5;
X    //
X    cout << " F: " << endl << F << endl;
X
X
X    cout << "Testing returning submatrixs from functions:  " 
X        << endl << "   MATRIX_float K = fexample(A,1); " << endl;
X    //
X    MATRIX_float K = fexample(A,1);
X    //
X    cout << "A" << endl << A << endl;
X    cout << "K" << endl << K << endl;
#endif
X
X
X    return 0;
}
SHAR_EOF
chmod 0660 mv/testing/tmat_float.cc ||
echo 'restore of mv/testing/tmat_float.cc failed'
Wc_c="`wc -c < 'mv/testing/tmat_float.cc'`"
test 5378 -eq "$Wc_c" ||
	echo 'mv/testing/tmat_float.cc: original size 5378, current size' "$Wc_c"
fi
# ============= mv/testing/tmat_int.cc ==============
if test -f 'mv/testing/tmat_int.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tmat_int.cc (File already exists)'
else
echo 'x - extracting mv/testing/tmat_int.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tmat_int.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tmat.cc        Testing routine for MV++ matrix class
//
//      Usage:  <M> <N> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_ColMat methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
X
#include "vector_defs.h"
#include MATRIX_H
X
// #include "systime.c"
X
// example function to zero-out a matrix:  illustrates how to pass
// matrixes by "reference" (modifiable), as opposed to by "value"
//
void foo(MATRIX_int *Aptr)
{
X    MATRIX_int &A = *Aptr;
X
X    A = (int) 0;
}
X
// example funciton to return MV_ColMats:  (returns matrix + scalar)
//
MATRIX_int fexample(const MATRIX_int A, int s)
{
X    int M = A.size(0);
X    int N = A.size(1);
X    MATRIX_int B(M,N);
X
X    for (int j=0; j<N; j++)
X        for (int i=0; i<M; i++)
X            B(i,j) = A(i,j) + s;
X
X    return B;
}
X
X
main(int argc, char *argv[])
{
X    if (argc<7)
X    {
X        cout << "Usage: " << " M N Istart Iend Jstart Jend" << endl;
X        exit(1);
X    }
X
X    int M = atoi(argv[1]);
X    int N = atoi(argv[2]);
X    int Istart = atoi(argv[3]);
X    int Jstart = atoi(argv[4]);
X    int Iend = atoi(argv[5]);
X    int Jend = atoi(argv[6]);
X    int i,j;
X    cout << "Using M = " << M << " N = " << N << 
X            "   Istart = " << Istart << "   Iend = " <<  Iend <<
X            "   Jstart = " << Jstart << "   Jend = " <<  Jend << endl;
X
X
X
X    MATRIX_int C;
X    cout << " Test null constructor:  MV_ColMat C() " << endl;
X    cout << C << endl;
X
X
X    MATRIX_int A(M,N);
X    cout << " Test MV_ColMat(int,int) constructor:  MV_ColMat A(M,N) " << endl;
X    cout << " values should be uninitalized.. " << endl;
X    cout << A << endl;
X
X    MATRIX_int B(M,N, 3);
X    cout << " Test MV_ColMat(int, int, val) constructor:  MV_ColMat B(N, 3.0) " 
X                << endl;
X    cout << "   all values should be 3:  " << endl;
X    cout << B << endl;
X
X    cout << " Test A(i,j) indexing, set A(i,j) = 100*j + i, and B(i) = -A(i,j)"
X        << endl;
X
X    for (j=0; j<N; j++)
X        for (i=0; i<M; i++)
X        {
X            A(i,j) = 100*i+j;
X            B(i,j) =  - A(i,j);
X        }
X
X    cout << " A " << endl;
X    cout << A << endl;
X    cout << " B " << endl;
X    cout <<  B << endl;
X
X
X
X    cout << "Testing MV_VecIndex I(Istart, Iend) " << endl;
X    //
X    MV_VecIndex I(Istart, Iend);
X    MV_VecIndex J(Jstart, Jend);
X    //
X    cout << "I = (" << Istart << ":"<< Iend <<") " << endl;
X    cout << "J = (" << Jstart << ":"<< Jend <<") " << endl;
X
X    cout << "Test A(I,J) = B(I,J) " <<  endl ;
X    A(I,J) = B(I,J);
X    cout << A << endl;
X
X    cout << "Testing A(I,J) = 1.1 " << endl;
X    A(I,J) = 11;
X    cout << "A" << endl << A << endl;
X
X    cout << "Testing MV_VecIndex + operators: " << endl;
X    cout << " A = 0.0; A(I+1,J-1) = 1.0; " << endl;
X    //
X    A = (int) 0; 
X    A(I+1,J-1) = (int) 1;
X    //
X    cout << " A " << endl << A << endl;
X
#if 0
X    MV_VecIndex K( N/2, N/2 );
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/2, N/2 );" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A = 0.0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << "Test = when matrices are overlapping  " << endl;
X    cout << " A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); " << endl;
X    //
X    A(MV_VecIndex(0, N-1)) = B; 
X    A(J+1) = A(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X    cout << "Testing MATRIX_int &c = C(I)" << endl;
X    MATRIX_int &c = C(I);
X    cout << " c " << endl;
X    cout << c << endl;
X
X    cout << "Testing c = B(I) " << endl;
X    c  = B(I);
X    cout << "c " << endl;
X    cout << c << endl;
X
X    cout << " C " << endl;
X    cout << C << endl;
X
X    cout << "Testing passing submatrixs to functions: calling foo(&c) " 
X        << endl << "  where foo zeros out a matrix " << endl;
X    foo(&c);
X    cout << "C" << endl << C << endl;
X
X    MATRIX_int F(N, 90);
X    cout << endl << "Test constructors from exisitng memory : " << endl;
X    cout <<  " MATRIX_int E(&F(0),N) " << endl;
X
X    MATRIX_int E(&F[0], N);
X    cout << "E : " << endl << E << endl;
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (int) 999;
X    cout << "E should not be changed:" << endl;
X    cout << E << endl;
X
X    cout << "Test reference constructors from exisitng memory : " << endl;
X    cout <<  " MATRIX_int G(&F(0),N, MV_Matrix_::ref) " << endl;
X
X    MATRIX_int G(&F[0], N, MV_Matrix_::ref);
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (int) 999;
X    cout << "G " << endl;
X    cout << G << endl;
X
X    cout << "Now set G = 5, F should change also " << endl;
X    //
X    G = (int) 5;
X    //
X    cout << " F: " << endl << F << endl;
X
X
X    cout << "Testing returning submatrixs from functions:  " 
X        << endl << "   MATRIX_int K = fexample(A,1); " << endl;
X    //
X    MATRIX_int K = fexample(A,1);
X    //
X    cout << "A" << endl << A << endl;
X    cout << "K" << endl << K << endl;
#endif
X
X
X    return 0;
}
SHAR_EOF
chmod 0660 mv/testing/tmat_int.cc ||
echo 'restore of mv/testing/tmat_int.cc failed'
Wc_c="`wc -c < 'mv/testing/tmat_int.cc'`"
test 5330 -eq "$Wc_c" ||
	echo 'mv/testing/tmat_int.cc: original size 5330, current size' "$Wc_c"
fi
# ============= mv/testing/tmat_type.cc ==============
if test -f 'mv/testing/tmat_type.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tmat_type.cc (File already exists)'
else
echo 'x - extracting mv/testing/tmat_type.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tmat_type.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tmat.cc        Testing routine for MV++ matrix class
//
//      Usage:  <M> <N> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_ColMat methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
X
#include "vector_defs.h"
#include MATRIX_H
X
// #include "systime.c"
X
// example function to zero-out a matrix:  illustrates how to pass
// matrixes by "reference" (modifiable), as opposed to by "value"
//
void foo(MATRIX_TYPE *Aptr)
{
X    MATRIX_TYPE &A = *Aptr;
X
X    A = (TYPE) 0;
}
X
// example funciton to return MV_ColMats:  (returns matrix + scalar)
//
MATRIX_TYPE fexample(const MATRIX_TYPE A, TYPE s)
{
X    int M = A.size(0);
X    int N = A.size(1);
X    MATRIX_TYPE B(M,N);
X
X    for (int j=0; j<N; j++)
X        for (int i=0; i<M; i++)
X            B(i,j) = A(i,j) + s;
X
X    return B;
}
X
X
main(int argc, char *argv[])
{
X    if (argc<7)
X    {
X        cout << "Usage: " << " M N Istart Iend Jstart Jend" << endl;
X        exit(1);
X    }
X
X    int M = atoi(argv[1]);
X    int N = atoi(argv[2]);
X    int Istart = atoi(argv[3]);
X    int Jstart = atoi(argv[4]);
X    int Iend = atoi(argv[5]);
X    int Jend = atoi(argv[6]);
X    int i,j;
X    cout << "Using M = " << M << " N = " << N << 
X            "   Istart = " << Istart << "   Iend = " <<  Iend <<
X            "   Jstart = " << Jstart << "   Jend = " <<  Jend << endl;
X
X
X
X    MATRIX_TYPE C;
X    cout << " Test null constructor:  MV_ColMat C() " << endl;
X    cout << C << endl;
X
X
X    MATRIX_TYPE A(M,N);
X    cout << " Test MV_ColMat(int,int) constructor:  MV_ColMat A(M,N) " << endl;
X    cout << " values should be uninitalized.. " << endl;
X    cout << A << endl;
X
X    MATRIX_TYPE B(M,N, 3);
X    cout << " Test MV_ColMat(int, int, val) constructor:  MV_ColMat B(N, 3.0) " 
X                << endl;
X    cout << "   all values should be 3:  " << endl;
X    cout << B << endl;
X
X    cout << " Test A(i,j) indexing, set A(i,j) = 100*j + i, and B(i) = -A(i,j)"
X        << endl;
X
X    for (j=0; j<N; j++)
X        for (i=0; i<M; i++)
X        {
X            A(i,j) = 100*i+j;
X            B(i,j) =  - A(i,j);
X        }
X
X    cout << " A " << endl;
X    cout << A << endl;
X    cout << " B " << endl;
X    cout <<  B << endl;
X
X
X
X    cout << "Testing MV_VecIndex I(Istart, Iend) " << endl;
X    //
X    MV_VecIndex I(Istart, Iend);
X    MV_VecIndex J(Jstart, Jend);
X    //
X    cout << "I = (" << Istart << ":"<< Iend <<") " << endl;
X    cout << "J = (" << Jstart << ":"<< Jend <<") " << endl;
X
X    cout << "Test A(I,J) = B(I,J) " <<  endl ;
X    A(I,J) = B(I,J);
X    cout << A << endl;
X
X    cout << "Testing A(I,J) = 1.1 " << endl;
X    A(I,J) = 11;
X    cout << "A" << endl << A << endl;
X
X    cout << "Testing MV_VecIndex + operators: " << endl;
X    cout << " A = 0.0; A(I+1,J-1) = 1.0; " << endl;
X    //
X    A = (TYPE) 0; 
X    A(I+1,J-1) = (TYPE) 1;
X    //
X    cout << " A " << endl << A << endl;
X
#if 0
X    MV_VecIndex K( N/2, N/2 );
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/2, N/2 );" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A = 0.0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << "Test = when matrices are overlapping  " << endl;
X    cout << " A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); " << endl;
X    //
X    A(MV_VecIndex(0, N-1)) = B; 
X    A(J+1) = A(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X    cout << "Testing MATRIX_TYPE &c = C(I)" << endl;
X    MATRIX_TYPE &c = C(I);
X    cout << " c " << endl;
X    cout << c << endl;
X
X    cout << "Testing c = B(I) " << endl;
X    c  = B(I);
X    cout << "c " << endl;
X    cout << c << endl;
X
X    cout << " C " << endl;
X    cout << C << endl;
X
X    cout << "Testing passing submatrixs to functions: calling foo(&c) " 
X        << endl << "  where foo zeros out a matrix " << endl;
X    foo(&c);
X    cout << "C" << endl << C << endl;
X
X    MATRIX_TYPE F(N, 90);
X    cout << endl << "Test constructors from exisitng memory : " << endl;
X    cout <<  " MATRIX_TYPE E(&F(0),N) " << endl;
X
X    MATRIX_TYPE E(&F[0], N);
X    cout << "E : " << endl << E << endl;
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (TYPE) 999;
X    cout << "E should not be changed:" << endl;
X    cout << E << endl;
X
X    cout << "Test reference constructors from exisitng memory : " << endl;
X    cout <<  " MATRIX_TYPE G(&F(0),N, MV_Matrix_::ref) " << endl;
X
X    MATRIX_TYPE G(&F[0], N, MV_Matrix_::ref);
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (TYPE) 999;
X    cout << "G " << endl;
X    cout << G << endl;
X
X    cout << "Now set G = 5, F should change also " << endl;
X    //
X    G = (TYPE) 5;
X    //
X    cout << " F: " << endl << F << endl;
X
X
X    cout << "Testing returning submatrixs from functions:  " 
X        << endl << "   MATRIX_TYPE K = fexample(A,1); " << endl;
X    //
X    MATRIX_TYPE K = fexample(A,1);
X    //
X    cout << "A" << endl << A << endl;
X    cout << "K" << endl << K << endl;
#endif
X
X
X    return 0;
}
SHAR_EOF
chmod 0660 mv/testing/tmat_type.cc ||
echo 'restore of mv/testing/tmat_type.cc failed'
Wc_c="`wc -c < 'mv/testing/tmat_type.cc'`"
test 5354 -eq "$Wc_c" ||
	echo 'mv/testing/tmat_type.cc: original size 5354, current size' "$Wc_c"
fi
# ============= mv/testing/tvec.cc ==============
if test -f 'mv/testing/tvec.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tvec.cc (File already exists)'
else
echo 'x - extracting mv/testing/tvec.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tvec.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tvec.cc        Testing routine for MV++ vector class
//
//      Usage:  <length> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_Vector methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
#include "mv_vector.h"
X
// example function to zero-out a vector:  illustrates how to pass
// vectors by "reference" (modifiable), as opposed to by "value"
//
void foo(MV_Vector<double> *Aptr)
{
X    MV_Vector<double> &A = *Aptr;
X
X    A = 0.0;
}
X
// example funciton to return MV_Vectors:  (returns vector + scalar)
//
MV_Vector<double> fexample(const MV_Vector<double> A, double s)
{
X    int N = A.size();
X    MV_Vector<double> B(N);
X
X    for (int i=0; i<N; i++)
X        B(i) = A(i) + s;
X
X    return B;
}
X
X
main(int argc, char *argv[])
{
X    if (argc<4)
X    {
X        cout << "Usage " << argv[0] << " N start end" << endl;
X        exit(1);
X    }
X
X    int N = atoi(argv[1]);
X    int start = atoi(argv[2]);
X    int end = atoi(argv[3]);
X    int i;
X    cout << "Using N = " << N << "   start = " << start << "   end = "
X        << end << endl;
X
X
X
X    MV_Vector<double> C;
X    cout << " Test null constructor:  MV_Vector C() " << endl;
X    cout << C << endl;
X
X
X    MV_Vector<double> A(N);
X    cout << " Test MV_Vector(int) constructor:  MV_Vector A(N) " << endl;
X    cout << " values should be uninitalized.. " << endl;
X    cout << A << endl;
X
X    MV_Vector<double> B(N, 3.0);
X    cout << " Test MV_Vector(int, val) constructor:  MV_Vector B(N, 3.0) " << endl;
X    cout << "   all values should be 3.0:  " << endl;
X    cout << B << endl;
X
X    cout << " Test A(i) indexing, set A(i) = i, and B(i) = -i " << endl;
X    for (i=0; i<N; i++)
X        {
X            A(i) = i;
X            B(i) =  -i;
X        }
X
X    cout << " A " << endl;
X    cout << A << endl;
X    cout << " B " << endl;
X    cout <<  B << endl;
X
X
X    cout  << "Test opeator= :  C = A " << endl;
X    cout <<  "  C is a new copy of A " << endl;
X
X    C = A;                      
X
X    cout  << "  C : " << endl;
X    cout << C << endl;
X
X
X    cout << "Testing MV_VecIndexI(start, end) " << endl;
X    //
X    MV_VecIndex I(start, end);
X    //
X    cout << "I = (" << start << ":"<< end <<") " << endl;
X
X    cout << "Test A(I) = B(I) " <<  endl ;
X    A(I) = B(I);
X    cout << A << endl;
X
X    cout << "Testing A(I) = 1.1 " << endl;
X    A(I) = 1.1;
X    cout << "A" << endl << A << endl;
X
X    cout << "Testing MV_VecIndex + operators: " << endl;
X    cout << " A = 0.0; A(I+1) = 1.0; " << endl;
X    //
X    A = 0.0; 
X    A(I+1) = 1.0;
X    //
X    cout << " A " << endl << A << endl;
X
X    MV_VecIndex J( N/4,  (3*N)/4);
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/4,  (3*N)/4  );" << endl;
X    cout << " J = MV_VecIndex(" <<  N/4  << "," << (3*N)/4 << ");" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A = 0.0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X    J = MV_VecIndex( N/2 , N/2  );
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/2 , N/2   );" << endl;
X    cout << " J = MV_VecIndex(" << N/2  << "," << N/2 << ");" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A = 0.0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << " A = 0.0; A(J-1) = B(J+1); " << endl;
X    //
X    A = 0.0; 
X    A(J-1) = B(J+1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << "Test = when matrices are overlapping  " << endl;
X    cout << " A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); " << endl;
X    //
X    A(MV_VecIndex(0, N-1)) = B; 
X    A(J+1) = A(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X
X    cout << "Testing MV_Vector<double> &c = C(I)" << endl;
X
#if 0
// The following seciton attemps to take the address of a temporary
// result and hence not compilable on all C++ platforms.
X
X    MV_Vector<double> &c = C(I);
X    cout << " c " << endl;
X    cout << c << endl;
X
X    cout << "Testing c = B(I) " << endl;
X    c  = B(I);
X    cout << "c " << endl;
X    cout << c << endl;
X
X    cout << " C " << endl;
X    cout << C << endl;
X
X    cout << "Testing passing subvectors to functions: calling foo(&c) " 
X        << endl << "  where foo zeros out a matrix " << endl;
X    foo(&c);
X    cout << "C" << endl << C << endl;
#endif
X
X    MV_Vector<double> F(N, 9.0);
X    cout << endl << "Test constructors from exisitng memory : " << endl;
X    cout <<  " MV_Vector<double> E(&F(0),N) " << endl;
X
X    MV_Vector<double> E(&F[0], N);
X    cout << "E : " << endl << E << endl;
X
X    cout << " Now modify F(0) = 99.9 " << endl;
X    F(0) = 99.9;
X    cout << "E should not be changed:" << endl;
X    cout << E << endl;
X
X    cout << "Test reference constructors from exisitng memory : " << endl;
X    cout <<  " MV_Vector<double> G(&F(0),N, MV_Vector_::ref) " << endl;
X
X    MV_Vector<double> G(&F[0], N, MV_Vector_::ref);
X
X    cout << " Now modify F(0) = 99.9 " << endl;
X    F(0) = 99.9;
X    cout << "G " << endl;
X    cout << G << endl;
X
X    cout << "Now set G = 5.0, F should change also " << endl;
X    //
X    G = 5.0;
X    //
X    cout << " F: " << endl << F << endl;
X
X
X    cout << "Testing returning subvectors from functions:  " 
X        << endl << "   MV_Vector<double> K = fexample(A,1.0); " << endl;
X    //
X    MV_Vector<double> K = fexample(A,1.0);
X    //
X    cout << "A" << endl << A << endl;
X    cout << "K" << endl << K << endl;
X
X
X    MV_Vector<double> Q( &A(0), A.size(), MV_Vector_::ref);
X    A() = B;
X    //
X    cout << "Q points to A;  A() = B " << endl;
X    cout << "Q  "<< endl;
X    cout << Q << endl;
X
X    A(MV_VecIndex()) = B;
X    //
X    cout << "Q points to A;  A(MV_VecIndex()) = B " << endl;
X    cout << "Q  "<< endl;
X    cout << Q << endl;
X    return 0;
}
X
SHAR_EOF
chmod 0660 mv/testing/tvec.cc ||
echo 'restore of mv/testing/tvec.cc failed'
Wc_c="`wc -c < 'mv/testing/tvec.cc'`"
test 6143 -eq "$Wc_c" ||
	echo 'mv/testing/tvec.cc: original size 6143, current size' "$Wc_c"
fi
# ============= mv/testing/tvec_complex.cc ==============
if test -f 'mv/testing/tvec_complex.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tvec_complex.cc (File already exists)'
else
echo 'x - extracting mv/testing/tvec_complex.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tvec_complex.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tvec.cc        Testing routine for MV++ vector class
//
//      Usage:  <length> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_Vector methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
#include "vector_defs.h"
#include VECTOR_H
X
X
// example function to zero-out a vector:  illustrates how to pass
// vectors by "reference" (modifiable), as opposed to by "value"
//
void foo(VECTOR_complex *Aptr)
{
X    VECTOR_complex &A = *Aptr;
X
X    A = (complex) 0;
}
X
// example funciton to return MV_Vectors:  (returns vector + scalar)
//
VECTOR_complex fexample(const VECTOR_complex A, complex s)
{
X    int N = A.size();
X    VECTOR_complex B(N);
X
X    for (int i=0; i<N; i++)
X        B(i) = A(i) + s;
X
X    return B;
}
X
X
main(int argc, char *argv[])
{
X    if (argc<4)
X    {
X        cout << "Usage " << argv[0] << " N start end" << endl;
X        exit(1);
X    }
X
X    int N = atoi(argv[1]);
X    int start = atoi(argv[2]);
X    int end = atoi(argv[3]);
X    int i;
X    cout << "Using N = " << N << "   start = " << start << "   end = "
X        << end << endl;
X
X
X
X    VECTOR_complex C;
X    cout << " Test null constructor:  MV_Vector C() " << endl;
X    cout << C << endl;
X
X
X    VECTOR_complex A(N);
X    cout << " Test MV_Vector(int) constructor:  MV_Vector A(N) " << endl;
X    cout << " values should be uninitalized.. " << endl;
X    cout << A << endl;
X
X    VECTOR_complex B(N, 3);
X    cout << " Test MV_Vector(int, val) constructor:  MV_Vector B(N, 3.0) " << endl;
X    cout << "   all values should be 3.0:  " << endl;
X    cout << B << endl;
X
X    cout << " Test A(i) indexing, set A(i) = i, and B(i) = -i " << endl;
X    for (i=0; i<N; i++)
X        {
X            A(i) = i;
X            B(i) =  -i;
X        }
X
X    cout << " A " << endl;
X    cout << A << endl;
X    cout << " B " << endl;
X    cout <<  B << endl;
X
X
X    cout  << "Test opeator= :  C = A " << endl;
X    cout <<  "  C is a new copy of A " << endl;
X
X    C = A;                      
X
X    cout  << "  C : " << endl;
X    cout << C << endl;
X
X
X    cout << "Testing MV_VecIndexI(start, end) " << endl;
X    //
X    MV_VecIndex I(start, end);
X    //
X    cout << "I = (" << start << ":"<< end <<") " << endl;
X
X    cout << "Test A(I) = B(I) " <<  endl ;
X    A(I) = B(I);
X    cout << A << endl;
X
X    cout << "Testing A(I) = 11 " << endl;
X    A(I) =  (complex) 11;
X    cout << "A" << endl << A << endl;
X
X    cout << "Testing MV_VecIndex + operators: " << endl;
X    cout << " A = 0.0; A(I+1) = 1.0; " << endl;
X    //
X    A = (complex) 0; 
X    A(I+1) =  (complex) 1;
X    //
X    cout << " A " << endl << A << endl;
X
X    MV_VecIndex J( N/4,  (3*N)/4);
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/4,  (3*N)/4  );" << endl;
X    cout << " J = MV_VecIndex(" <<  N/4  << "," << (3*N)/4 << ");" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A =  (complex) 0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X    J = MV_VecIndex( N/2 , N/2  );
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/2 , N/2   );" << endl;
X    cout << " J = MV_VecIndex(" << N/2  << "," << N/2 << ");" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A = (complex) 0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << " A = 0.0; A(J-1) = B(J+1); " << endl;
X    //
X    A = (complex) 0; 
X    A(J-1) = B(J+1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << "Test = when matrices are overlapping  " << endl;
X    cout << " A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); " << endl;
X    //
X    A(MV_VecIndex(0, N-1)) = B; 
X    A(J+1) = A(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X
X    cout << "Testing VECTOR_complex &c = C(I)" << endl;
X
#if 0
// The following seciton attemps to take the address of a temporary
// result and hence not compilable on all C++ platforms.
X
X    VECTOR_complex &c = C(I);
X    cout << " c " << endl;
X    cout << c << endl;
X
X    cout << "Testing c = B(I) " << endl;
X    c  = B(I);
X    cout << "c " << endl;
X    cout << c << endl;
X
X    cout << " C " << endl;
X    cout << C << endl;
X
X    cout << "Testing passing subvectors to functions: calling foo(&c) " 
X        << endl << "  where foo zeros out a matrix " << endl;
X    foo(&c);
X    cout << "C" << endl << C << endl;
#endif
X
X    VECTOR_complex F(N, 9);
X    cout << endl << "Test constructors from exisitng memory : " << endl;
X    cout <<  " VECTOR_complex E(&F(0),N) " << endl;
X
X    VECTOR_complex E(&F[0], N);
X    cout << "E : " << endl << E << endl;
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (complex) 999;
X    cout << "E should not be changed:" << endl;
X    cout << E << endl;
X
X    cout << "Test reference constructors from exisitng memory : " << endl;
X    cout <<  " VECTOR_complex G(&F(0),N, MV_Vector_::ref) " << endl;
X
X    VECTOR_complex G(&F[0], N, MV_Vector_::ref);
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (complex) 999;
X    cout << "G " << endl;
X    cout << G << endl;
X
X    cout << "Now set G = 5, F should change also " << endl;
X    //
X    G = (complex) 5;
X    //
X    cout << " F: " << endl << F << endl;
X
X
X    cout << "Testing returning subvectors from functions:  " 
X        << endl << "   VECTOR_complex K = fexample(A,1.0); " << endl;
X    //
X    VECTOR_complex K = fexample(A,1);
X    //
X    cout << "A" << endl << A << endl;
X    cout << "K" << endl << K << endl;
X
X
X    VECTOR_complex Q( &A(0), A.size(), MV_Vector_::ref);
X    A() = B;
X    //
X    cout << "Q points to A;  A() = B " << endl;
X    cout << "Q  "<< endl;
X    cout << Q << endl;
X
X    A(MV_VecIndex()) = B;
X    //
X    cout << "Q points to A;  A(MV_VecIndex()) = B " << endl;
X    cout << "Q  "<< endl;
X    cout << Q << endl;
X
X    cout << "Test A(B(I)) constructor " << endl;
X    VECTOR_complex Z = A(I);
X    cout << "A(I) " << endl;
X    cout << A(I) << endl;
X    Z = (complex) 0;
X    cout << "After Z=A(I); Z=0;, A should remian unchanged " << endl;
X    cout << A << endl;
X
X    return 0;
}
X
SHAR_EOF
chmod 0660 mv/testing/tvec_complex.cc ||
echo 'restore of mv/testing/tvec_complex.cc failed'
Wc_c="`wc -c < 'mv/testing/tvec_complex.cc'`"
test 6435 -eq "$Wc_c" ||
	echo 'mv/testing/tvec_complex.cc: original size 6435, current size' "$Wc_c"
fi
# ============= mv/testing/tvec_double.cc ==============
if test -f 'mv/testing/tvec_double.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tvec_double.cc (File already exists)'
else
echo 'x - extracting mv/testing/tvec_double.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tvec_double.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tvec.cc        Testing routine for MV++ vector class
//
//      Usage:  <length> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_Vector methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
#include "vector_defs.h"
#include VECTOR_H
X
X
// example function to zero-out a vector:  illustrates how to pass
// vectors by "reference" (modifiable), as opposed to by "value"
//
void foo(VECTOR_double *Aptr)
{
X    VECTOR_double &A = *Aptr;
X
X    A = (double) 0;
}
X
// example funciton to return MV_Vectors:  (returns vector + scalar)
//
VECTOR_double fexample(const VECTOR_double A, double s)
{
X    int N = A.size();
X    VECTOR_double B(N);
X
X    for (int i=0; i<N; i++)
X        B(i) = A(i) + s;
X
X    return B;
}
X
X
main(int argc, char *argv[])
{
X    if (argc<4)
X    {
X        cout << "Usage " << argv[0] << " N start end" << endl;
X        exit(1);
X    }
X
X    int N = atoi(argv[1]);
X    int start = atoi(argv[2]);
X    int end = atoi(argv[3]);
X    int i;
X    cout << "Using N = " << N << "   start = " << start << "   end = "
X        << end << endl;
X
X
X
X    VECTOR_double C;
X    cout << " Test null constructor:  MV_Vector C() " << endl;
X    cout << C << endl;
X
X
X    VECTOR_double A(N);
X    cout << " Test MV_Vector(int) constructor:  MV_Vector A(N) " << endl;
X    cout << " values should be uninitalized.. " << endl;
X    cout << A << endl;
X
X    VECTOR_double B(N, 3);
X    cout << " Test MV_Vector(int, val) constructor:  MV_Vector B(N, 3.0) " << endl;
X    cout << "   all values should be 3.0:  " << endl;
X    cout << B << endl;
X
X    cout << " Test A(i) indexing, set A(i) = i, and B(i) = -i " << endl;
X    for (i=0; i<N; i++)
X        {
X            A(i) = i;
X            B(i) =  -i;
X        }
X
X    cout << " A " << endl;
X    cout << A << endl;
X    cout << " B " << endl;
X    cout <<  B << endl;
X
X
X    cout  << "Test opeator= :  C = A " << endl;
X    cout <<  "  C is a new copy of A " << endl;
X
X    C = A;                      
X
X    cout  << "  C : " << endl;
X    cout << C << endl;
X
X
X    cout << "Testing MV_VecIndexI(start, end) " << endl;
X    //
X    MV_VecIndex I(start, end);
X    //
X    cout << "I = (" << start << ":"<< end <<") " << endl;
X
X    cout << "Test A(I) = B(I) " <<  endl ;
X    A(I) = B(I);
X    cout << A << endl;
X
X    cout << "Testing A(I) = 11 " << endl;
X    A(I) =  (double) 11;
X    cout << "A" << endl << A << endl;
X
X    cout << "Testing MV_VecIndex + operators: " << endl;
X    cout << " A = 0.0; A(I+1) = 1.0; " << endl;
X    //
X    A = (double) 0; 
X    A(I+1) =  (double) 1;
X    //
X    cout << " A " << endl << A << endl;
X
X    MV_VecIndex J( N/4,  (3*N)/4);
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/4,  (3*N)/4  );" << endl;
X    cout << " J = MV_VecIndex(" <<  N/4  << "," << (3*N)/4 << ");" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A =  (double) 0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X    J = MV_VecIndex( N/2 , N/2  );
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/2 , N/2   );" << endl;
X    cout << " J = MV_VecIndex(" << N/2  << "," << N/2 << ");" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A = (double) 0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << " A = 0.0; A(J-1) = B(J+1); " << endl;
X    //
X    A = (double) 0; 
X    A(J-1) = B(J+1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << "Test = when matrices are overlapping  " << endl;
X    cout << " A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); " << endl;
X    //
X    A(MV_VecIndex(0, N-1)) = B; 
X    A(J+1) = A(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X
X    cout << "Testing VECTOR_double &c = C(I)" << endl;
X
#if 0
// The following seciton attemps to take the address of a temporary
// result and hence not compilable on all C++ platforms.
X
X    VECTOR_double &c = C(I);
X    cout << " c " << endl;
X    cout << c << endl;
X
X    cout << "Testing c = B(I) " << endl;
X    c  = B(I);
X    cout << "c " << endl;
X    cout << c << endl;
X
X    cout << " C " << endl;
X    cout << C << endl;
X
X    cout << "Testing passing subvectors to functions: calling foo(&c) " 
X        << endl << "  where foo zeros out a matrix " << endl;
X    foo(&c);
X    cout << "C" << endl << C << endl;
#endif
X
X    VECTOR_double F(N, 9);
X    cout << endl << "Test constructors from exisitng memory : " << endl;
X    cout <<  " VECTOR_double E(&F(0),N) " << endl;
X
X    VECTOR_double E(&F[0], N);
X    cout << "E : " << endl << E << endl;
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (double) 999;
X    cout << "E should not be changed:" << endl;
X    cout << E << endl;
X
X    cout << "Test reference constructors from exisitng memory : " << endl;
X    cout <<  " VECTOR_double G(&F(0),N, MV_Vector_::ref) " << endl;
X
X    VECTOR_double G(&F[0], N, MV_Vector_::ref);
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (double) 999;
X    cout << "G " << endl;
X    cout << G << endl;
X
X    cout << "Now set G = 5, F should change also " << endl;
X    //
X    G = (double) 5;
X    //
X    cout << " F: " << endl << F << endl;
X
X
X    cout << "Testing returning subvectors from functions:  " 
X        << endl << "   VECTOR_double K = fexample(A,1.0); " << endl;
X    //
X    VECTOR_double K = fexample(A,1);
X    //
X    cout << "A" << endl << A << endl;
X    cout << "K" << endl << K << endl;
X
X
X    VECTOR_double Q( &A(0), A.size(), MV_Vector_::ref);
X    A() = B;
X    //
X    cout << "Q points to A;  A() = B " << endl;
X    cout << "Q  "<< endl;
X    cout << Q << endl;
X
X    A(MV_VecIndex()) = B;
X    //
X    cout << "Q points to A;  A(MV_VecIndex()) = B " << endl;
X    cout << "Q  "<< endl;
X    cout << Q << endl;
X
X    cout << "Test A(B(I)) constructor " << endl;
X    VECTOR_double Z = A(I);
X    cout << "A(I) " << endl;
X    cout << A(I) << endl;
X    Z = (double) 0;
X    cout << "After Z=A(I); Z=0;, A should remian unchanged " << endl;
X    cout << A << endl;
X
X    return 0;
}
X
SHAR_EOF
chmod 0660 mv/testing/tvec_double.cc ||
echo 'restore of mv/testing/tvec_double.cc failed'
Wc_c="`wc -c < 'mv/testing/tvec_double.cc'`"
test 6404 -eq "$Wc_c" ||
	echo 'mv/testing/tvec_double.cc: original size 6404, current size' "$Wc_c"
fi
# ============= mv/testing/tvec_float.cc ==============
if test -f 'mv/testing/tvec_float.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tvec_float.cc (File already exists)'
else
echo 'x - extracting mv/testing/tvec_float.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tvec_float.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tvec.cc        Testing routine for MV++ vector class
//
//      Usage:  <length> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_Vector methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
#include "vector_defs.h"
#include VECTOR_H
X
X
// example function to zero-out a vector:  illustrates how to pass
// vectors by "reference" (modifiable), as opposed to by "value"
//
void foo(VECTOR_float *Aptr)
{
X    VECTOR_float &A = *Aptr;
X
X    A = (float) 0;
}
X
// example funciton to return MV_Vectors:  (returns vector + scalar)
//
VECTOR_float fexample(const VECTOR_float A, float s)
{
X    int N = A.size();
X    VECTOR_float B(N);
X
X    for (int i=0; i<N; i++)
X        B(i) = A(i) + s;
X
X    return B;
}
X
X
main(int argc, char *argv[])
{
X    if (argc<4)
X    {
X        cout << "Usage " << argv[0] << " N start end" << endl;
X        exit(1);
X    }
X
X    int N = atoi(argv[1]);
X    int start = atoi(argv[2]);
X    int end = atoi(argv[3]);
X    int i;
X    cout << "Using N = " << N << "   start = " << start << "   end = "
X        << end << endl;
X
X
X
X    VECTOR_float C;
X    cout << " Test null constructor:  MV_Vector C() " << endl;
X    cout << C << endl;
X
X
X    VECTOR_float A(N);
X    cout << " Test MV_Vector(int) constructor:  MV_Vector A(N) " << endl;
X    cout << " values should be uninitalized.. " << endl;
X    cout << A << endl;
X
X    VECTOR_float B(N, 3);
X    cout << " Test MV_Vector(int, val) constructor:  MV_Vector B(N, 3.0) " << endl;
X    cout << "   all values should be 3.0:  " << endl;
X    cout << B << endl;
X
X    cout << " Test A(i) indexing, set A(i) = i, and B(i) = -i " << endl;
X    for (i=0; i<N; i++)
X        {
X            A(i) = i;
X            B(i) =  -i;
X        }
X
X    cout << " A " << endl;
X    cout << A << endl;
X    cout << " B " << endl;
X    cout <<  B << endl;
X
X
X    cout  << "Test opeator= :  C = A " << endl;
X    cout <<  "  C is a new copy of A " << endl;
X
X    C = A;                      
X
X    cout  << "  C : " << endl;
X    cout << C << endl;
X
X
X    cout << "Testing MV_VecIndexI(start, end) " << endl;
X    //
X    MV_VecIndex I(start, end);
X    //
X    cout << "I = (" << start << ":"<< end <<") " << endl;
X
X    cout << "Test A(I) = B(I) " <<  endl ;
X    A(I) = B(I);
X    cout << A << endl;
X
X    cout << "Testing A(I) = 11 " << endl;
X    A(I) =  (float) 11;
X    cout << "A" << endl << A << endl;
X
X    cout << "Testing MV_VecIndex + operators: " << endl;
X    cout << " A = 0.0; A(I+1) = 1.0; " << endl;
X    //
X    A = (float) 0; 
X    A(I+1) =  (float) 1;
X    //
X    cout << " A " << endl << A << endl;
X
X    MV_VecIndex J( N/4,  (3*N)/4);
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/4,  (3*N)/4  );" << endl;
X    cout << " J = MV_VecIndex(" <<  N/4  << "," << (3*N)/4 << ");" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A =  (float) 0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X    J = MV_VecIndex( N/2 , N/2  );
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/2 , N/2   );" << endl;
X    cout << " J = MV_VecIndex(" << N/2  << "," << N/2 << ");" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A = (float) 0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << " A = 0.0; A(J-1) = B(J+1); " << endl;
X    //
X    A = (float) 0; 
X    A(J-1) = B(J+1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << "Test = when matrices are overlapping  " << endl;
X    cout << " A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); " << endl;
X    //
X    A(MV_VecIndex(0, N-1)) = B; 
X    A(J+1) = A(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X
X    cout << "Testing VECTOR_float &c = C(I)" << endl;
X
#if 0
// The following seciton attemps to take the address of a temporary
// result and hence not compilable on all C++ platforms.
X
X    VECTOR_float &c = C(I);
X    cout << " c " << endl;
X    cout << c << endl;
X
X    cout << "Testing c = B(I) " << endl;
X    c  = B(I);
X    cout << "c " << endl;
X    cout << c << endl;
X
X    cout << " C " << endl;
X    cout << C << endl;
X
X    cout << "Testing passing subvectors to functions: calling foo(&c) " 
X        << endl << "  where foo zeros out a matrix " << endl;
X    foo(&c);
X    cout << "C" << endl << C << endl;
#endif
X
X    VECTOR_float F(N, 9);
X    cout << endl << "Test constructors from exisitng memory : " << endl;
X    cout <<  " VECTOR_float E(&F(0),N) " << endl;
X
X    VECTOR_float E(&F[0], N);
X    cout << "E : " << endl << E << endl;
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (float) 999;
X    cout << "E should not be changed:" << endl;
X    cout << E << endl;
X
X    cout << "Test reference constructors from exisitng memory : " << endl;
X    cout <<  " VECTOR_float G(&F(0),N, MV_Vector_::ref) " << endl;
X
X    VECTOR_float G(&F[0], N, MV_Vector_::ref);
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (float) 999;
X    cout << "G " << endl;
X    cout << G << endl;
X
X    cout << "Now set G = 5, F should change also " << endl;
X    //
X    G = (float) 5;
X    //
X    cout << " F: " << endl << F << endl;
X
X
X    cout << "Testing returning subvectors from functions:  " 
X        << endl << "   VECTOR_float K = fexample(A,1.0); " << endl;
X    //
X    VECTOR_float K = fexample(A,1);
X    //
X    cout << "A" << endl << A << endl;
X    cout << "K" << endl << K << endl;
X
X
X    VECTOR_float Q( &A(0), A.size(), MV_Vector_::ref);
X    A() = B;
X    //
X    cout << "Q points to A;  A() = B " << endl;
X    cout << "Q  "<< endl;
X    cout << Q << endl;
X
X    A(MV_VecIndex()) = B;
X    //
X    cout << "Q points to A;  A(MV_VecIndex()) = B " << endl;
X    cout << "Q  "<< endl;
X    cout << Q << endl;
X
X    cout << "Test A(B(I)) constructor " << endl;
X    VECTOR_float Z = A(I);
X    cout << "A(I) " << endl;
X    cout << A(I) << endl;
X    Z = (float) 0;
X    cout << "After Z=A(I); Z=0;, A should remian unchanged " << endl;
X    cout << A << endl;
X
X    return 0;
}
X
SHAR_EOF
chmod 0660 mv/testing/tvec_float.cc ||
echo 'restore of mv/testing/tvec_float.cc failed'
Wc_c="`wc -c < 'mv/testing/tvec_float.cc'`"
test 6373 -eq "$Wc_c" ||
	echo 'mv/testing/tvec_float.cc: original size 6373, current size' "$Wc_c"
fi
# ============= mv/testing/tvec_int.cc ==============
if test -f 'mv/testing/tvec_int.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tvec_int.cc (File already exists)'
else
echo 'x - extracting mv/testing/tvec_int.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tvec_int.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tvec.cc        Testing routine for MV++ vector class
//
//      Usage:  <length> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_Vector methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
#include "vector_defs.h"
#include VECTOR_H
X
X
// example function to zero-out a vector:  illustrates how to pass
// vectors by "reference" (modifiable), as opposed to by "value"
//
void foo(VECTOR_int *Aptr)
{
X    VECTOR_int &A = *Aptr;
X
X    A = (int) 0;
}
X
// example funciton to return MV_Vectors:  (returns vector + scalar)
//
VECTOR_int fexample(const VECTOR_int A, int s)
{
X    int N = A.size();
X    VECTOR_int B(N);
X
X    for (int i=0; i<N; i++)
X        B(i) = A(i) + s;
X
X    return B;
}
X
X
main(int argc, char *argv[])
{
X    if (argc<4)
X    {
X        cout << "Usage " << argv[0] << " N start end" << endl;
X        exit(1);
X    }
X
X    int N = atoi(argv[1]);
X    int start = atoi(argv[2]);
X    int end = atoi(argv[3]);
X    int i;
X    cout << "Using N = " << N << "   start = " << start << "   end = "
X        << end << endl;
X
X
X
X    VECTOR_int C;
X    cout << " Test null constructor:  MV_Vector C() " << endl;
X    cout << C << endl;
X
X
X    VECTOR_int A(N);
X    cout << " Test MV_Vector(int) constructor:  MV_Vector A(N) " << endl;
X    cout << " values should be uninitalized.. " << endl;
X    cout << A << endl;
X
X    VECTOR_int B(N, 3);
X    cout << " Test MV_Vector(int, val) constructor:  MV_Vector B(N, 3.0) " << endl;
X    cout << "   all values should be 3.0:  " << endl;
X    cout << B << endl;
X
X    cout << " Test A(i) indexing, set A(i) = i, and B(i) = -i " << endl;
X    for (i=0; i<N; i++)
X        {
X            A(i) = i;
X            B(i) =  -i;
X        }
X
X    cout << " A " << endl;
X    cout << A << endl;
X    cout << " B " << endl;
X    cout <<  B << endl;
X
X
X    cout  << "Test opeator= :  C = A " << endl;
X    cout <<  "  C is a new copy of A " << endl;
X
X    C = A;                      
X
X    cout  << "  C : " << endl;
X    cout << C << endl;
X
X
X    cout << "Testing MV_VecIndexI(start, end) " << endl;
X    //
X    MV_VecIndex I(start, end);
X    //
X    cout << "I = (" << start << ":"<< end <<") " << endl;
X
X    cout << "Test A(I) = B(I) " <<  endl ;
X    A(I) = B(I);
X    cout << A << endl;
X
X    cout << "Testing A(I) = 11 " << endl;
X    A(I) =  (int) 11;
X    cout << "A" << endl << A << endl;
X
X    cout << "Testing MV_VecIndex + operators: " << endl;
X    cout << " A = 0.0; A(I+1) = 1.0; " << endl;
X    //
X    A = (int) 0; 
X    A(I+1) =  (int) 1;
X    //
X    cout << " A " << endl << A << endl;
X
X    MV_VecIndex J( N/4,  (3*N)/4);
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/4,  (3*N)/4  );" << endl;
X    cout << " J = MV_VecIndex(" <<  N/4  << "," << (3*N)/4 << ");" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A =  (int) 0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X    J = MV_VecIndex( N/2 , N/2  );
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/2 , N/2   );" << endl;
X    cout << " J = MV_VecIndex(" << N/2  << "," << N/2 << ");" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A = (int) 0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << " A = 0.0; A(J-1) = B(J+1); " << endl;
X    //
X    A = (int) 0; 
X    A(J-1) = B(J+1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << "Test = when matrices are overlapping  " << endl;
X    cout << " A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); " << endl;
X    //
X    A(MV_VecIndex(0, N-1)) = B; 
X    A(J+1) = A(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X
X    cout << "Testing VECTOR_int &c = C(I)" << endl;
X
#if 0
// The following seciton attemps to take the address of a temporary
// result and hence not compilable on all C++ platforms.
X
X    VECTOR_int &c = C(I);
X    cout << " c " << endl;
X    cout << c << endl;
X
X    cout << "Testing c = B(I) " << endl;
X    c  = B(I);
X    cout << "c " << endl;
X    cout << c << endl;
X
X    cout << " C " << endl;
X    cout << C << endl;
X
X    cout << "Testing passing subvectors to functions: calling foo(&c) " 
X        << endl << "  where foo zeros out a matrix " << endl;
X    foo(&c);
X    cout << "C" << endl << C << endl;
#endif
X
X    VECTOR_int F(N, 9);
X    cout << endl << "Test constructors from exisitng memory : " << endl;
X    cout <<  " VECTOR_int E(&F(0),N) " << endl;
X
X    VECTOR_int E(&F[0], N);
X    cout << "E : " << endl << E << endl;
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (int) 999;
X    cout << "E should not be changed:" << endl;
X    cout << E << endl;
X
X    cout << "Test reference constructors from exisitng memory : " << endl;
X    cout <<  " VECTOR_int G(&F(0),N, MV_Vector_::ref) " << endl;
X
X    VECTOR_int G(&F[0], N, MV_Vector_::ref);
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (int) 999;
X    cout << "G " << endl;
X    cout << G << endl;
X
X    cout << "Now set G = 5, F should change also " << endl;
X    //
X    G = (int) 5;
X    //
X    cout << " F: " << endl << F << endl;
X
X
X    cout << "Testing returning subvectors from functions:  " 
X        << endl << "   VECTOR_int K = fexample(A,1.0); " << endl;
X    //
X    VECTOR_int K = fexample(A,1);
X    //
X    cout << "A" << endl << A << endl;
X    cout << "K" << endl << K << endl;
X
X
X    VECTOR_int Q( &A(0), A.size(), MV_Vector_::ref);
X    A() = B;
X    //
X    cout << "Q points to A;  A() = B " << endl;
X    cout << "Q  "<< endl;
X    cout << Q << endl;
X
X    A(MV_VecIndex()) = B;
X    //
X    cout << "Q points to A;  A(MV_VecIndex()) = B " << endl;
X    cout << "Q  "<< endl;
X    cout << Q << endl;
X
X    cout << "Test A(B(I)) constructor " << endl;
X    VECTOR_int Z = A(I);
X    cout << "A(I) " << endl;
X    cout << A(I) << endl;
X    Z = (int) 0;
X    cout << "After Z=A(I); Z=0;, A should remian unchanged " << endl;
X    cout << A << endl;
X
X    return 0;
}
X
SHAR_EOF
chmod 0660 mv/testing/tvec_int.cc ||
echo 'restore of mv/testing/tvec_int.cc failed'
Wc_c="`wc -c < 'mv/testing/tvec_int.cc'`"
test 6311 -eq "$Wc_c" ||
	echo 'mv/testing/tvec_int.cc: original size 6311, current size' "$Wc_c"
fi
# ============= mv/testing/tvec_type.cc ==============
if test -f 'mv/testing/tvec_type.cc' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/tvec_type.cc (File already exists)'
else
echo 'x - extracting mv/testing/tvec_type.cc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/tvec_type.cc' &&
//      MV++  (V. 1.2b Beta)
//      Numerical Matrix/MV_Vector Class Library
//      (c) 1994  Roldan Pozo
//
X
//
//      tvec.cc        Testing routine for MV++ vector class
//
//      Usage:  <length> <block-index start>  <block-index end>
//
//      (Suggest these to be relatively small positive numbers, as  
//      output is proportional to "length".)
//
//      This test program is self-explanatory (there are diagnostics
//      output message of what each step is performing)and excercise 
//      most of the MV_Vector methods, thus providing examples of how 
//      these are used.
//
X
X
#include <iostream.h>
#include <stdlib.h>
X
#include "vector_defs.h"
#include VECTOR_H
X
X
// example function to zero-out a vector:  illustrates how to pass
// vectors by "reference" (modifiable), as opposed to by "value"
//
void foo(VECTOR_TYPE *Aptr)
{
X    VECTOR_TYPE &A = *Aptr;
X
X    A = (TYPE) 0;
}
X
// example funciton to return MV_Vectors:  (returns vector + scalar)
//
VECTOR_TYPE fexample(const VECTOR_TYPE A, TYPE s)
{
X    int N = A.size();
X    VECTOR_TYPE B(N);
X
X    for (int i=0; i<N; i++)
X        B(i) = A(i) + s;
X
X    return B;
}
X
X
main(int argc, char *argv[])
{
X    if (argc<4)
X    {
X        cout << "Usage " << argv[0] << " N start end" << endl;
X        exit(1);
X    }
X
X    int N = atoi(argv[1]);
X    int start = atoi(argv[2]);
X    int end = atoi(argv[3]);
X    int i;
X    cout << "Using N = " << N << "   start = " << start << "   end = "
X        << end << endl;
X
X
X
X    VECTOR_TYPE C;
X    cout << " Test null constructor:  MV_Vector C() " << endl;
X    cout << C << endl;
X
X
X    VECTOR_TYPE A(N);
X    cout << " Test MV_Vector(int) constructor:  MV_Vector A(N) " << endl;
X    cout << " values should be uninitalized.. " << endl;
X    cout << A << endl;
X
X    VECTOR_TYPE B(N, 3);
X    cout << " Test MV_Vector(int, val) constructor:  MV_Vector B(N, 3.0) " << endl;
X    cout << "   all values should be 3.0:  " << endl;
X    cout << B << endl;
X
X    cout << " Test A(i) indexing, set A(i) = i, and B(i) = -i " << endl;
X    for (i=0; i<N; i++)
X        {
X            A(i) = i;
X            B(i) =  -i;
X        }
X
X    cout << " A " << endl;
X    cout << A << endl;
X    cout << " B " << endl;
X    cout <<  B << endl;
X
X
X    cout  << "Test opeator= :  C = A " << endl;
X    cout <<  "  C is a new copy of A " << endl;
X
X    C = A;                      
X
X    cout  << "  C : " << endl;
X    cout << C << endl;
X
X
X    cout << "Testing MV_VecIndexI(start, end) " << endl;
X    //
X    MV_VecIndex I(start, end);
X    //
X    cout << "I = (" << start << ":"<< end <<") " << endl;
X
X    cout << "Test A(I) = B(I) " <<  endl ;
X    A(I) = B(I);
X    cout << A << endl;
X
X    cout << "Testing A(I) = 11 " << endl;
X    A(I) =  (TYPE) 11;
X    cout << "A" << endl << A << endl;
X
X    cout << "Testing MV_VecIndex + operators: " << endl;
X    cout << " A = 0.0; A(I+1) = 1.0; " << endl;
X    //
X    A = (TYPE) 0; 
X    A(I+1) =  (TYPE) 1;
X    //
X    cout << " A " << endl << A << endl;
X
X    MV_VecIndex J( N/4,  (3*N)/4);
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/4,  (3*N)/4  );" << endl;
X    cout << " J = MV_VecIndex(" <<  N/4  << "," << (3*N)/4 << ");" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A =  (TYPE) 0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X    J = MV_VecIndex( N/2 , N/2  );
X    cout << "Testing MV_VecIndex +/- operators: " << endl;
X    cout << " J = MV_VecIndex( N/2 , N/2   );" << endl;
X    cout << " J = MV_VecIndex(" << N/2  << "," << N/2 << ");" << endl;
X    cout << " A = 0.0; A(J+1) = B(J-1); " << endl;
X    //
X    A = (TYPE) 0; 
X    A(J+1) = B(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << " A = 0.0; A(J-1) = B(J+1); " << endl;
X    //
X    A = (TYPE) 0; 
X    A(J-1) = B(J+1);
X    //
X    cout << " A " << endl << A << endl;
X
X    cout << "Test = when matrices are overlapping  " << endl;
X    cout << " A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); " << endl;
X    //
X    A(MV_VecIndex(0, N-1)) = B; 
X    A(J+1) = A(J-1);
X    //
X    cout << " A " << endl << A << endl;
X
X
X
X    cout << "Testing VECTOR_TYPE &c = C(I)" << endl;
X
#if 0
// The following seciton attemps to take the address of a temporary
// result and hence not compilable on all C++ platforms.
X
X    VECTOR_TYPE &c = C(I);
X    cout << " c " << endl;
X    cout << c << endl;
X
X    cout << "Testing c = B(I) " << endl;
X    c  = B(I);
X    cout << "c " << endl;
X    cout << c << endl;
X
X    cout << " C " << endl;
X    cout << C << endl;
X
X    cout << "Testing passing subvectors to functions: calling foo(&c) " 
X        << endl << "  where foo zeros out a matrix " << endl;
X    foo(&c);
X    cout << "C" << endl << C << endl;
#endif
X
X    VECTOR_TYPE F(N, 9);
X    cout << endl << "Test constructors from exisitng memory : " << endl;
X    cout <<  " VECTOR_TYPE E(&F(0),N) " << endl;
X
X    VECTOR_TYPE E(&F[0], N);
X    cout << "E : " << endl << E << endl;
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (TYPE) 999;
X    cout << "E should not be changed:" << endl;
X    cout << E << endl;
X
X    cout << "Test reference constructors from exisitng memory : " << endl;
X    cout <<  " VECTOR_TYPE G(&F(0),N, MV_Vector_::ref) " << endl;
X
X    VECTOR_TYPE G(&F[0], N, MV_Vector_::ref);
X
X    cout << " Now modify F(0) = 999 " << endl;
X    F(0) = (TYPE) 999;
X    cout << "G " << endl;
X    cout << G << endl;
X
X    cout << "Now set G = 5, F should change also " << endl;
X    //
X    G = (TYPE) 5;
X    //
X    cout << " F: " << endl << F << endl;
X
X
X    cout << "Testing returning subvectors from functions:  " 
X        << endl << "   VECTOR_TYPE K = fexample(A,1.0); " << endl;
X    //
X    VECTOR_TYPE K = fexample(A,1);
X    //
X    cout << "A" << endl << A << endl;
X    cout << "K" << endl << K << endl;
X
X
X    VECTOR_TYPE Q( &A(0), A.size(), MV_Vector_::ref);
X    A() = B;
X    //
X    cout << "Q points to A;  A() = B " << endl;
X    cout << "Q  "<< endl;
X    cout << Q << endl;
X
X    A(MV_VecIndex()) = B;
X    //
X    cout << "Q points to A;  A(MV_VecIndex()) = B " << endl;
X    cout << "Q  "<< endl;
X    cout << Q << endl;
X
X    cout << "Test A(B(I)) constructor " << endl;
X    VECTOR_TYPE Z = A(I);
X    cout << "A(I) " << endl;
X    cout << A(I) << endl;
X    Z = (TYPE) 0;
X    cout << "After Z=A(I); Z=0;, A should remian unchanged " << endl;
X    cout << A << endl;
X
X    return 0;
}
X
SHAR_EOF
chmod 0660 mv/testing/tvec_type.cc ||
echo 'restore of mv/testing/tvec_type.cc failed'
Wc_c="`wc -c < 'mv/testing/tvec_type.cc'`"
test 6342 -eq "$Wc_c" ||
	echo 'mv/testing/tvec_type.cc: original size 6342, current size' "$Wc_c"
fi
# ============= mv/testing/makefile ==============
if test -f 'mv/testing/makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/makefile (File already exists)'
else
echo 'x - extracting mv/testing/makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/makefile' &&
X
include ../makefile.def
X
X
X
MV_INCLUDE_DIR = ../include
INCLUDES 	= -I$(MV_INCLUDE_DIR)
X
X
VECTOR_H		= "mv_vector_all.h"
VECTOR_DOUBLE 	= MV_Vector_double
VECTOR_FLOAT   	= MV_Vector_float
VECTOR_INT		= MV_Vector_int
VECTOR_COMPLEX	= MV_Vector_complex
MATRIX_H		= "mv_matrix_all.h"
MATRIX_DOUBLE	= MV_ColMat_double
MATRIX_FLOAT	= MV_ColMat_float
MATRIX_INT		= MV_ColMat_int
MATRIX_COMPLEX	= MV_ColMat_complex
X
X
X
#  Non-templated version
#
SRCS =	  tvec_double.cc 	\
X		  tmat_double.cc 	\
X		  tblas1_double.cc	\
X		  tvec_int.cc 		\
X		  tmat_int.cc 		\
X		  tvec_float.cc 	\
X		  tmat_float.cc 	\
X		  tblas1_float.cc 	\
X		  tvec_complex.cc 	\
X		  tmat_complex.cc 	\
X		  tblas1_complex.cc
X
X
all: progs
X
srcs: $(SRCS)
X
progs: $(EXECS)
X
X
tvec_double.o : tvec_double.cc  \
X  $(MV_INCLUDE_DIR)/mv_vector_double.h $(MV_INCLUDE_DIR)/mv_vecindex.h
X
tmat_double.o : tmat_double.cc  \
X  $(MV_INCLUDE_DIR)/mv_matrix_double.h $(MV_INCLUDE_DIR)/mv_vector_double.h \
X	$(MV_INCLUDE_DIR)/mv_vecindex.h
X
tblas1_double.o : tblas1_double.cc \
X  $(MV_INCLUDE_DIR)/mv_matrix_double.h $(MV_INCLUDE_DIR)/mv_vector_double.h \
X	$(MV_INCLUDE_DIR)/mv_vecindex.h
X
X
tvec_float.o : tvec_float.cc  \
X  $(MV_INCLUDE_DIR)/mv_vector_float.h $(MV_INCLUDE_DIR)/mv_vecindex.h
X
tmat_float.o : tmat_float.cc  \
X  $(MV_INCLUDE_DIR)/mv_matrix_float.h $(MV_INCLUDE_DIR)/mv_vector_float.h \
X	$(MV_INCLUDE_DIR)/mv_vecindex.h
X
tblas1_float.o : tblas1_float.cc \
X  $(MV_INCLUDE_DIR)/mv_matrix_float.h $(MV_INCLUDE_DIR)/mv_vector_float.h \
X	$(MV_INCLUDE_DIR)/mv_vecindex.h
X
X
tvec_int.o : tvec_int.cc  \
X  $(MV_INCLUDE_DIR)/mv_vector_int.h $(MV_INCLUDE_DIR)/mv_vecindex.h
X
tmat_int.o : tmat_int.cc  \
X  $(MV_INCLUDE_DIR)/mv_matrix_int.h $(MV_INCLUDE_DIR)/mv_vector_int.h \
X	$(MV_INCLUDE_DIR)/mv_vecindex.h
X
X
tvec_complex.o : tvec_complex.cc  \
X  $(MV_INCLUDE_DIR)/mv_vector_complex.h $(MV_INCLUDE_DIR)/mv_vecindex.h
X
tmat_complex.o : tmat_complex.cc  \
X  $(MV_INCLUDE_DIR)/mv_matrix_complex.h $(MV_INCLUDE_DIR)/mv_vector_complex.h \
X	$(MV_INCLUDE_DIR)/mv_vecindex.h
X
tblas1_complex.o : tblas1_complex.cc \
X  $(MV_INCLUDE_DIR)/mv_matrix_complex.h $(MV_INCLUDE_DIR)/mv_vector_complex.h \
X	$(MV_INCLUDE_DIR)/mv_vecindex.h
X
wipe: clean
X
clean:
X	/bin/rm -f $(OBJS) $(EXECS) tmat tmat2 tvec tblas1;
X	/bin/rm -r -f ptrepository
X
SHAR_EOF
chmod 0640 mv/testing/makefile ||
echo 'restore of mv/testing/makefile failed'
Wc_c="`wc -c < 'mv/testing/makefile'`"
test 2269 -eq "$Wc_c" ||
	echo 'mv/testing/makefile: original size 2269, current size' "$Wc_c"
fi
# ============= mv/testing/makefile.templated ==============
if test -f 'mv/testing/makefile.templated' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/makefile.templated (File already exists)'
else
echo 'x - extracting mv/testing/makefile.templated (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/makefile.templated' &&
#
#		MV++ (V 1.0 Beta)
# 		(c) 1993-1994 Roldan Pozo All Rights Reserved.
#
X
X
X
INCLUDES 	= -I../include
X
X
# Templated version
#
TEMPLATE_SRCS	= tblas1.cc	\
X		  tmat.cc	\
X		  tmat2.cc	\
X		  tvec.cc
X
X
SRCS = $(TEMPLATE_SRCS)
X
EXECS = tblas1 tmat tmat2 tvec
X
all: $(EXECS)
X
X
tblas1 : tblas1.cc
X	$(CCC) -o tblas1 $(INCLUDES) tblas1.cc
X
tmat2: tmat2.cc
X	$(CCC) -o tmat2 $(INCLUDES) tmat2.cc
X
tvec: tvec.cc
X	$(CCC) -o tvec $(INCLUDES) tvec.cc
X
X
tmat: tmat.cc
X	$(CCC) -o tmat $(INCLUDES) tmat.cc
X
X
clean:
X	/bin/rm -f core  $(EXECS);
X	/bin/rm -r -f ptrepository
X
X
X
X
SHAR_EOF
chmod 0640 mv/testing/makefile.templated ||
echo 'restore of mv/testing/makefile.templated failed'
Wc_c="`wc -c < 'mv/testing/makefile.templated'`"
test 558 -eq "$Wc_c" ||
	echo 'mv/testing/makefile.templated: original size 558, current size' "$Wc_c"
fi
# ============= mv/testing/mv_test ==============
if test -f 'mv/testing/mv_test' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/mv_test (File already exists)'
else
echo 'x - extracting mv/testing/mv_test (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/mv_test' &&
tvec_double  7 1 3
tmat_double  8 9 2 4 6 7
tblas1_double 5
X
tvec_float  7 1 3
tmat_float  8 9 2 4 6 7
tblas1_float 5
X
tvec_int  7 1 3
tmat_int  8 9 2 4 6 7
X
tvec_complex  7 1 3
tmat_complex  8 9 2 4 6 7
tblas1_complex 5
X
SHAR_EOF
chmod 0550 mv/testing/mv_test ||
echo 'restore of mv/testing/mv_test failed'
Wc_c="`wc -c < 'mv/testing/mv_test'`"
test 222 -eq "$Wc_c" ||
	echo 'mv/testing/mv_test: original size 222, current size' "$Wc_c"
fi
# ============= mv/testing/templated_mv_test ==============
if test -f 'mv/testing/templated_mv_test' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/templated_mv_test (File already exists)'
else
echo 'x - extracting mv/testing/templated_mv_test (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/templated_mv_test' &&
tvec  7 1 3
tmat  8 9 2 4 6 7
tblas1 5
X
SHAR_EOF
chmod 0550 mv/testing/templated_mv_test ||
echo 'restore of mv/testing/templated_mv_test failed'
Wc_c="`wc -c < 'mv/testing/templated_mv_test'`"
test 40 -eq "$Wc_c" ||
	echo 'mv/testing/templated_mv_test: original size 40, current size' "$Wc_c"
fi
# ============= mv/testing/mv_test.out ==============
if test -f 'mv/testing/mv_test.out' -a X"$1" != X"-c"; then
	echo 'x - skipping mv/testing/mv_test.out (File already exists)'
else
echo 'x - extracting mv/testing/mv_test.out (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mv/testing/mv_test.out' &&
Using N = 7   start = 1   end = 3
X Test null constructor:  MV_Vector C() 
X
X Test MV_Vector(int) constructor:  MV_Vector A(N) 
X values should be uninitalized.. 
0
0
0
0
0
0
0
X
X Test MV_Vector(int, val) constructor:  MV_Vector B(N, 3.0) 
X   all values should be 3.0:  
3
3
3
3
3
3
3
X
X Test A(i) indexing, set A(i) = i, and B(i) = -i 
X A 
0
1
2
3
4
5
6
X
X B 
0
-1
-2
-3
-4
-5
-6
X
Test opeator= :  C = A 
X  C is a new copy of A 
X  C : 
0
1
2
3
4
5
6
X
Testing MV_VecIndexI(start, end) 
I = (1:3) 
Test A(I) = B(I) 
0
-1
-2
-3
4
5
6
X
Testing A(I) = 11 
A
0
11
11
11
4
5
6
X
Testing MV_VecIndex + operators: 
X A = 0.0; A(I+1) = 1.0; 
X A 
0
0
1
1
1
0
0
X
Testing MV_VecIndex +/- operators: 
X J = MV_VecIndex( N/4,  (3*N)/4  );
X J = MV_VecIndex(1,5);
X A = 0.0; A(J+1) = B(J-1); 
X A 
0
0
0
-1
-2
-3
-4
X
Testing MV_VecIndex +/- operators: 
X J = MV_VecIndex( N/2 , N/2   );
X J = MV_VecIndex(3,3);
X A = 0.0; A(J+1) = B(J-1); 
X A 
0
0
0
0
-2
0
0
X
X A = 0.0; A(J-1) = B(J+1); 
X A 
0
0
-4
0
0
0
0
X
Test = when matrices are overlapping  
X A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); 
X A 
0
-1
-2
-3
-2
-5
-6
X
Testing VECTOR_double &c = C(I)
X
Test constructors from exisitng memory : 
X VECTOR_double E(&F(0),N) 
E : 
9
9
9
9
9
9
9
X
X Now modify F(0) = 999 
E should not be changed:
9
9
9
9
9
9
9
X
Test reference constructors from exisitng memory : 
X VECTOR_double G(&F(0),N, MV_Vector_::ref) 
X Now modify F(0) = 999 
G 
999
9
9
9
9
9
9
X
Now set G = 5, F should change also 
X F: 
5
5
5
5
5
5
5
X
Testing returning subvectors from functions:  
X   VECTOR_double K = fexample(A,1.0); 
A
0
-1
-2
-3
-2
-5
-6
X
K
1
0
-1
-2
-1
-4
-5
X
Q points to A;  A() = B 
Q  
0
-1
-2
-3
-4
-5
-6
X
Q points to A;  A(MV_VecIndex()) = B 
Q  
0
-1
-2
-3
-4
-5
-6
X
Test A(B(I)) constructor 
A(I) 
-1
-2
-3
X
After Z=A(I); Z=0;, A should remian unchanged 
0
0
0
0
-4
-5
-6
X
Using M = 8 N = 9   Istart = 2   Iend = 6   Jstart = 4   Jend = 7
X Test null constructor:  MV_ColMat C() 
X
X Test MV_ColMat(int,int) constructor:  MV_ColMat A(M,N) 
X values should be uninitalized.. 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
X
X Test MV_ColMat(int, int, val) constructor:  MV_ColMat B(N, 3.0) 
X   all values should be 3:  
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
X
X Test A(i,j) indexing, set A(i,j) = 100*j + i, and B(i) = -A(i,j)
X A 
0 1 2 3 4 5 6 7 8 
100 101 102 103 104 105 106 107 108 
200 201 202 203 204 205 206 207 208 
300 301 302 303 304 305 306 307 308 
400 401 402 403 404 405 406 407 408 
500 501 502 503 504 505 506 507 508 
600 601 602 603 604 605 606 607 608 
700 701 702 703 704 705 706 707 708 
X
X B 
-0 -1 -2 -3 -4 -5 -6 -7 -8 
-100 -101 -102 -103 -104 -105 -106 -107 -108 
-200 -201 -202 -203 -204 -205 -206 -207 -208 
-300 -301 -302 -303 -304 -305 -306 -307 -308 
-400 -401 -402 -403 -404 -405 -406 -407 -408 
-500 -501 -502 -503 -504 -505 -506 -507 -508 
-600 -601 -602 -603 -604 -605 -606 -607 -608 
-700 -701 -702 -703 -704 -705 -706 -707 -708 
X
Testing MV_VecIndex I(Istart, Iend) 
I = (2:6) 
J = (4:7) 
Test A(I,J) = B(I,J) 
0 1 2 3 4 5 6 7 8 
100 101 102 103 104 105 106 107 108 
200 201 202 203 -204 -205 -206 -207 208 
300 301 302 303 -304 -305 -306 -307 308 
400 401 402 403 -404 -405 -406 -407 408 
500 501 502 503 -504 -505 -506 -507 508 
600 601 602 603 -604 -605 -606 -607 608 
700 701 702 703 704 705 706 707 708 
X
Testing A(I,J) = 1.1 
A
0 1 2 3 4 5 6 7 8 
100 101 102 103 104 105 106 107 108 
200 201 202 203 11 11 11 11 208 
300 301 302 303 11 11 11 11 308 
400 401 402 403 11 11 11 11 408 
500 501 502 503 11 11 11 11 508 
600 601 602 603 11 11 11 11 608 
700 701 702 703 704 705 706 707 708 
X
Testing MV_VecIndex + operators: 
X A = 0.0; A(I+1,J-1) = 1.0; 
X A 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 1 1 1 1 0 0 
0 0 0 1 1 1 1 0 0 
0 0 0 1 1 1 1 0 0 
0 0 0 1 1 1 1 0 0 
0 0 0 1 1 1 1 0 0 
X
Using N = 5 N = 5
X x 
0
1
2
3
4
X
Testing Vector * scalar:   
X z = x * 2 : 
0
2
4
6
8
X
X z = z * 2 : 
0
4
8
12
16
X
Testing Vector *= scalar:  
X (x *= 2) *= 2: 
0
4
8
12
16
X
Testing Vector += Vector:  
x=2, y=1; x += y: 
3
3
3
3
3
X
Testing Vector -= Vector:  
x=2, y=1; x -= y: 
1
1
1
1
1
X
Using N = 7   start = 1   end = 3
X Test null constructor:  MV_Vector C() 
X
X Test MV_Vector(int) constructor:  MV_Vector A(N) 
X values should be uninitalized.. 
0
0
0
0
0
0
0
X
X Test MV_Vector(int, val) constructor:  MV_Vector B(N, 3.0) 
X   all values should be 3.0:  
3
3
3
3
3
3
3
X
X Test A(i) indexing, set A(i) = i, and B(i) = -i 
X A 
0
1
2
3
4
5
6
X
X B 
0
-1
-2
-3
-4
-5
-6
X
Test opeator= :  C = A 
X  C is a new copy of A 
X  C : 
0
1
2
3
4
5
6
X
Testing MV_VecIndexI(start, end) 
I = (1:3) 
Test A(I) = B(I) 
0
-1
-2
-3
4
5
6
X
Testing A(I) = 11 
A
0
11
11
11
4
5
6
X
Testing MV_VecIndex + operators: 
X A = 0.0; A(I+1) = 1.0; 
X A 
0
0
1
1
1
0
0
X
Testing MV_VecIndex +/- operators: 
X J = MV_VecIndex( N/4,  (3*N)/4  );
X J = MV_VecIndex(1,5);
X A = 0.0; A(J+1) = B(J-1); 
X A 
0
0
0
-1
-2
-3
-4
X
Testing MV_VecIndex +/- operators: 
X J = MV_VecIndex( N/2 , N/2   );
X J = MV_VecIndex(3,3);
X A = 0.0; A(J+1) = B(J-1); 
X A 
0
0
0
0
-2
0
0
X
X A = 0.0; A(J-1) = B(J+1); 
X A 
0
0
-4
0
0
0
0
X
Test = when matrices are overlapping  
X A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); 
X A 
0
-1
-2
-3
-2
-5
-6
X
Testing VECTOR_float &c = C(I)
X
Test constructors from exisitng memory : 
X VECTOR_float E(&F(0),N) 
E : 
9
9
9
9
9
9
9
X
X Now modify F(0) = 999 
E should not be changed:
9
9
9
9
9
9
9
X
Test reference constructors from exisitng memory : 
X VECTOR_float G(&F(0),N, MV_Vector_::ref) 
X Now modify F(0) = 999 
G 
999
9
9
9
9
9
9
X
Now set G = 5, F should change also 
X F: 
5
5
5
5
5
5
5
X
Testing returning subvectors from functions:  
X   VECTOR_float K = fexample(A,1.0); 
A
0
-1
-2
-3
-2
-5
-6
X
K
1
0
-1
-2
-1
-4
-5
X
Q points to A;  A() = B 
Q  
0
-1
-2
-3
-4
-5
-6
X
Q points to A;  A(MV_VecIndex()) = B 
Q  
0
-1
-2
-3
-4
-5
-6
X
Test A(B(I)) constructor 
A(I) 
-1
-2
-3
X
After Z=A(I); Z=0;, A should remian unchanged 
0
0
0
0
-4
-5
-6
X
Using M = 8 N = 9   Istart = 2   Iend = 6   Jstart = 4   Jend = 7
X Test null constructor:  MV_ColMat C() 
X
X Test MV_ColMat(int,int) constructor:  MV_ColMat A(M,N) 
X values should be uninitalized.. 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
X
X Test MV_ColMat(int, int, val) constructor:  MV_ColMat B(N, 3.0) 
X   all values should be 3:  
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
X
X Test A(i,j) indexing, set A(i,j) = 100*j + i, and B(i) = -A(i,j)
X A 
0 1 2 3 4 5 6 7 8 
100 101 102 103 104 105 106 107 108 
200 201 202 203 204 205 206 207 208 
300 301 302 303 304 305 306 307 308 
400 401 402 403 404 405 406 407 408 
500 501 502 503 504 505 506 507 508 
600 601 602 603 604 605 606 607 608 
700 701 702 703 704 705 706 707 708 
X
X B 
-0 -1 -2 -3 -4 -5 -6 -7 -8 
-100 -101 -102 -103 -104 -105 -106 -107 -108 
-200 -201 -202 -203 -204 -205 -206 -207 -208 
-300 -301 -302 -303 -304 -305 -306 -307 -308 
-400 -401 -402 -403 -404 -405 -406 -407 -408 
-500 -501 -502 -503 -504 -505 -506 -507 -508 
-600 -601 -602 -603 -604 -605 -606 -607 -608 
-700 -701 -702 -703 -704 -705 -706 -707 -708 
X
Testing MV_VecIndex I(Istart, Iend) 
I = (2:6) 
J = (4:7) 
Test A(I,J) = B(I,J) 
0 1 2 3 4 5 6 7 8 
100 101 102 103 104 105 106 107 108 
200 201 202 203 -204 -205 -206 -207 208 
300 301 302 303 -304 -305 -306 -307 308 
400 401 402 403 -404 -405 -406 -407 408 
500 501 502 503 -504 -505 -506 -507 508 
600 601 602 603 -604 -605 -606 -607 608 
700 701 702 703 704 705 706 707 708 
X
Testing A(I,J) = 1.1 
A
0 1 2 3 4 5 6 7 8 
100 101 102 103 104 105 106 107 108 
200 201 202 203 11 11 11 11 208 
300 301 302 303 11 11 11 11 308 
400 401 402 403 11 11 11 11 408 
500 501 502 503 11 11 11 11 508 
600 601 602 603 11 11 11 11 608 
700 701 702 703 704 705 706 707 708 
X
Testing MV_VecIndex + operators: 
X A = 0.0; A(I+1,J-1) = 1.0; 
X A 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 1 1 1 1 0 0 
0 0 0 1 1 1 1 0 0 
0 0 0 1 1 1 1 0 0 
0 0 0 1 1 1 1 0 0 
0 0 0 1 1 1 1 0 0 
X
Using N = 5 N = 5
X x 
0
1
2
3
4
X
Testing Vector * scalar:   
X z = x * 2 : 
0
2
4
6
8
X
X z = z * 2 : 
0
4
8
12
16
X
Testing Vector *= scalar:  
X (x *= 2) *= 2: 
0
4
8
12
16
X
Testing Vector += Vector:  
x=2, y=1; x += y: 
3
3
3
3
3
X
Testing Vector -= Vector:  
x=2, y=1; x -= y: 
1
1
1
1
1
X
Using N = 7   start = 1   end = 3
X Test null constructor:  MV_Vector C() 
X
X Test MV_Vector(int) constructor:  MV_Vector A(N) 
X values should be uninitalized.. 
0
0
0
0
0
0
0
X
X Test MV_Vector(int, val) constructor:  MV_Vector B(N, 3.0) 
X   all values should be 3.0:  
3
3
3
3
3
3
3
X
X Test A(i) indexing, set A(i) = i, and B(i) = -i 
X A 
0
1
2
3
4
5
6
X
X B 
0
-1
-2
-3
-4
-5
-6
X
Test opeator= :  C = A 
X  C is a new copy of A 
X  C : 
0
1
2
3
4
5
6
X
Testing MV_VecIndexI(start, end) 
I = (1:3) 
Test A(I) = B(I) 
0
-1
-2
-3
4
5
6
X
Testing A(I) = 11 
A
0
11
11
11
4
5
6
X
Testing MV_VecIndex + operators: 
X A = 0.0; A(I+1) = 1.0; 
X A 
0
0
1
1
1
0
0
X
Testing MV_VecIndex +/- operators: 
X J = MV_VecIndex( N/4,  (3*N)/4  );
X J = MV_VecIndex(1,5);
X A = 0.0; A(J+1) = B(J-1); 
X A 
0
0
0
-1
-2
-3
-4
X
Testing MV_VecIndex +/- operators: 
X J = MV_VecIndex( N/2 , N/2   );
X J = MV_VecIndex(3,3);
X A = 0.0; A(J+1) = B(J-1); 
X A 
0
0
0
0
-2
0
0
X
X A = 0.0; A(J-1) = B(J+1); 
X A 
0
0
-4
0
0
0
0
X
Test = when matrices are overlapping  
X A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); 
X A 
0
-1
-2
-3
-2
-5
-6
X
Testing VECTOR_int &c = C(I)
X
Test constructors from exisitng memory : 
X VECTOR_int E(&F(0),N) 
E : 
9
9
9
9
9
9
9
X
X Now modify F(0) = 999 
E should not be changed:
9
9
9
9
9
9
9
X
Test reference constructors from exisitng memory : 
X VECTOR_int G(&F(0),N, MV_Vector_::ref) 
X Now modify F(0) = 999 
G 
999
9
9
9
9
9
9
X
Now set G = 5, F should change also 
X F: 
5
5
5
5
5
5
5
X
Testing returning subvectors from functions:  
X   VECTOR_int K = fexample(A,1.0); 
A
0
-1
-2
-3
-2
-5
-6
X
K
1
0
-1
-2
-1
-4
-5
X
Q points to A;  A() = B 
Q  
0
-1
-2
-3
-4
-5
-6
X
Q points to A;  A(MV_VecIndex()) = B 
Q  
0
-1
-2
-3
-4
-5
-6
X
Test A(B(I)) constructor 
A(I) 
-1
-2
-3
X
After Z=A(I); Z=0;, A should remian unchanged 
0
0
0
0
-4
-5
-6
X
Using M = 8 N = 9   Istart = 2   Iend = 6   Jstart = 4   Jend = 7
X Test null constructor:  MV_ColMat C() 
X
X Test MV_ColMat(int,int) constructor:  MV_ColMat A(M,N) 
X values should be uninitalized.. 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
X
X Test MV_ColMat(int, int, val) constructor:  MV_ColMat B(N, 3.0) 
X   all values should be 3:  
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
3 3 3 3 3 3 3 3 3 
X
X Test A(i,j) indexing, set A(i,j) = 100*j + i, and B(i) = -A(i,j)
X A 
0 1 2 3 4 5 6 7 8 
100 101 102 103 104 105 106 107 108 
200 201 202 203 204 205 206 207 208 
300 301 302 303 304 305 306 307 308 
400 401 402 403 404 405 406 407 408 
500 501 502 503 504 505 506 507 508 
600 601 602 603 604 605 606 607 608 
700 701 702 703 704 705 706 707 708 
X
X B 
0 -1 -2 -3 -4 -5 -6 -7 -8 
-100 -101 -102 -103 -104 -105 -106 -107 -108 
-200 -201 -202 -203 -204 -205 -206 -207 -208 
-300 -301 -302 -303 -304 -305 -306 -307 -308 
-400 -401 -402 -403 -404 -405 -406 -407 -408 
-500 -501 -502 -503 -504 -505 -506 -507 -508 
-600 -601 -602 -603 -604 -605 -606 -607 -608 
-700 -701 -702 -703 -704 -705 -706 -707 -708 
X
Testing MV_VecIndex I(Istart, Iend) 
I = (2:6) 
J = (4:7) 
Test A(I,J) = B(I,J) 
0 1 2 3 4 5 6 7 8 
100 101 102 103 104 105 106 107 108 
200 201 202 203 -204 -205 -206 -207 208 
300 301 302 303 -304 -305 -306 -307 308 
400 401 402 403 -404 -405 -406 -407 408 
500 501 502 503 -504 -505 -506 -507 508 
600 601 602 603 -604 -605 -606 -607 608 
700 701 702 703 704 705 706 707 708 
X
Testing A(I,J) = 1.1 
A
0 1 2 3 4 5 6 7 8 
100 101 102 103 104 105 106 107 108 
200 201 202 203 11 11 11 11 208 
300 301 302 303 11 11 11 11 308 
400 401 402 403 11 11 11 11 408 
500 501 502 503 11 11 11 11 508 
600 601 602 603 11 11 11 11 608 
700 701 702 703 704 705 706 707 708 
X
Testing MV_VecIndex + operators: 
X A = 0.0; A(I+1,J-1) = 1.0; 
X A 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 0 0 1 1 1 1 0 0 
0 0 0 1 1 1 1 0 0 
0 0 0 1 1 1 1 0 0 
0 0 0 1 1 1 1 0 0 
0 0 0 1 1 1 1 0 0 
X
Using N = 7   start = 1   end = 3
X Test null constructor:  MV_Vector C() 
X
X Test MV_Vector(int) constructor:  MV_Vector A(N) 
X values should be uninitalized.. 
(0, 0)
(0, 0)
(0, 0)
(0, 0)
(0, 0)
(0, 0)
(0, 0)
X
X Test MV_Vector(int, val) constructor:  MV_Vector B(N, 3.0) 
X   all values should be 3.0:  
(3, 0)
(3, 0)
(3, 0)
(3, 0)
(3, 0)
(3, 0)
(3, 0)
X
X Test A(i) indexing, set A(i) = i, and B(i) = -i 
X A 
(0, 0)
(1, 0)
(2, 0)
(3, 0)
(4, 0)
(5, 0)
(6, 0)
X
X B 
(0, 0)
(-1, 0)
(-2, 0)
(-3, 0)
(-4, 0)
(-5, 0)
(-6, 0)
X
Test opeator= :  C = A 
X  C is a new copy of A 
X  C : 
(0, 0)
(1, 0)
(2, 0)
(3, 0)
(4, 0)
(5, 0)
(6, 0)
X
Testing MV_VecIndexI(start, end) 
I = (1:3) 
Test A(I) = B(I) 
(0, 0)
(-1, 0)
(-2, 0)
(-3, 0)
(4, 0)
(5, 0)
(6, 0)
X
Testing A(I) = 11 
A
(0, 0)
(11, 0)
(11, 0)
(11, 0)
(4, 0)
(5, 0)
(6, 0)
X
Testing MV_VecIndex + operators: 
X A = 0.0; A(I+1) = 1.0; 
X A 
(0, 0)
(0, 0)
(1, 0)
(1, 0)
(1, 0)
(0, 0)
(0, 0)
X
Testing MV_VecIndex +/- operators: 
X J = MV_VecIndex( N/4,  (3*N)/4  );
X J = MV_VecIndex(1,5);
X A = 0.0; A(J+1) = B(J-1); 
X A 
(0, 0)
(0, 0)
(0, 0)
(-1, 0)
(-2, 0)
(-3, 0)
(-4, 0)
X
Testing MV_VecIndex +/- operators: 
X J = MV_VecIndex( N/2 , N/2   );
X J = MV_VecIndex(3,3);
X A = 0.0; A(J+1) = B(J-1); 
X A 
(0, 0)
(0, 0)
(0, 0)
(0, 0)
(-2, 0)
(0, 0)
(0, 0)
X
X A = 0.0; A(J-1) = B(J+1); 
X A 
(0, 0)
(0, 0)
(-4, 0)
(0, 0)
(0, 0)
(0, 0)
(0, 0)
X
Test = when matrices are overlapping  
X A(MV_VecIndex(0,N-1)) = B; A(J+1) = A(J-1); 
X A 
(0, 0)
(-1, 0)
(-2, 0)
(-3, 0)
(-2, 0)
(-5, 0)
(-6, 0)
X
Testing VECTOR_complex &c = C(I)
X
Test constructors from exisitng memory : 
X VECTOR_complex E(&F(0),N) 
E : 
(9, 0)
(9, 0)
(9, 0)
(9, 0)
(9, 0)
(9, 0)
(9, 0)
X
X Now modify F(0) = 999 
E should not be changed:
(9, 0)
(9, 0)
(9, 0)
(9, 0)
(9, 0)
(9, 0)
(9, 0)
X
Test reference constructors from exisitng memory : 
X VECTOR_complex G(&F(0),N, MV_Vector_::ref) 
X Now modify F(0) = 999 
G 
(999, 0)
(9, 0)
(9, 0)
(9, 0)
(9, 0)
(9, 0)
(9, 0)
X
Now set G = 5, F should change also 
X F: 
(5, 0)
(5, 0)
(5, 0)
(5, 0)
(5, 0)
(5, 0)
(5, 0)
X
Testing returning subvectors from functions:  
X   VECTOR_complex K = fexample(A,1.0); 
A
(0, 0)
(-1, 0)
(-2, 0)
(-3, 0)
(-2, 0)
(-5, 0)
(-6, 0)
X
K
(1, 0)
(0, 0)
(-1, 0)
(-2, 0)
(-1, 0)
(-4, 0)
(-5, 0)
X
Q points to A;  A() = B 
Q  
(0, 0)
(-1, 0)
(-2, 0)
(-3, 0)
(-4, 0)
(-5, 0)
(-6, 0)
X
Q points to A;  A(MV_VecIndex()) = B 
Q  
(0, 0)
(-1, 0)
(-2, 0)
(-3, 0)
(-4, 0)
(-5, 0)
(-6, 0)
X
Test A(B(I)) constructor 
A(I) 
(-1, 0)
(-2, 0)
(-3, 0)
X
After Z=A(I); Z=0;, A should remian unchanged 
(0, 0)
(0, 0)
(0, 0)
(0, 0)
(-4, 0)
(-5, 0)
(-6, 0)
X
Using M = 8 N = 9   Istart = 2   Iend = 6   Jstart = 4   Jend = 7
X Test null constructor:  MV_ColMat C() 
X
X Test MV_ColMat(int,int) constructor:  MV_ColMat A(M,N) 
X values should be uninitalized.. 
(0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) 
(0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) 
(0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) 
(0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) 
(0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) 
(0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) 
(0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) 
(0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) 
X
X Test MV_ColMat(int, int, val) constructor:  MV_ColMat B(N, 3.0) 
X   all values should be 3:  
(3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) 
(3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) 
(3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) 
(3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) 
(3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) 
(3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) 
(3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) 
(3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) (3, 0) 
X
X Test A(i,j) indexing, set A(i,j) = 100*j + i, and B(i) = -A(i,j)
X A 
(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) 
(100, 0) (101, 0) (102, 0) (103, 0) (104, 0) (105, 0) (106, 0) (107, 0) (108, 0) 
(200, 0) (201, 0) (202, 0) (203, 0) (204, 0) (205, 0) (206, 0) (207, 0) (208, 0) 
(300, 0) (301, 0) (302, 0) (303, 0) (304, 0) (305, 0) (306, 0) (307, 0) (308, 0) 
(400, 0) (401, 0) (402, 0) (403, 0) (404, 0) (405, 0) (406, 0) (407, 0) (408, 0) 
(500, 0) (501, 0) (502, 0) (503, 0) (504, 0) (505, 0) (506, 0) (507, 0) (508, 0) 
(600, 0) (601, 0) (602, 0) (603, 0) (604, 0) (605, 0) (606, 0) (607, 0) (608, 0) 
(700, 0) (701, 0) (702, 0) (703, 0) (704, 0) (705, 0) (706, 0) (707, 0) (708, 0) 
X
X B 
(-0, -0) (-1, -0) (-2, -0) (-3, -0) (-4, -0) (-5, -0) (-6, -0) (-7, -0) (-8, -0) 
(-100, -0) (-101, -0) (-102, -0) (-103, -0) (-104, -0) (-105, -0) (-106, -0) (-107, -0) (-108, -0) 
(-200, -0) (-201, -0) (-202, -0) (-203, -0) (-204, -0) (-205, -0) (-206, -0) (-207, -0) (-208, -0) 
(-300, -0) (-301, -0) (-302, -0) (-303, -0) (-304, -0) (-305, -0) (-306, -0) (-307, -0) (-308, -0) 
(-400, -0) (-401, -0) (-402, -0) (-403, -0) (-404, -0) (-405, -0) (-406, -0) (-407, -0) (-408, -0) 
(-500, -0) (-501, -0) (-502, -0) (-503, -0) (-504, -0) (-505, -0) (-506, -0) (-507, -0) (-508, -0) 
(-600, -0) (-601, -0) (-602, -0) (-603, -0) (-604, -0) (-605, -0) (-606, -0) (-607, -0) (-608, -0) 
(-700, -0) (-701, -0) (-702, -0) (-703, -0) (-704, -0) (-705, -0) (-706, -0) (-707, -0) (-708, -0) 
X
Testing MV_VecIndex I(Istart, Iend) 
I = (2:6) 
J = (4:7) 
Test A(I,J) = B(I,J) 
(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) 
(100, 0) (101, 0) (102, 0) (103, 0) (104, 0) (105, 0) (106, 0) (107, 0) (108, 0) 
(200, 0) (201, 0) (202, 0) (203, 0) (-204, -0) (-205, -0) (-206, -0) (-207, -0) (208, 0) 
(300, 0) (301, 0) (302, 0) (303, 0) (-304, -0) (-305, -0) (-306, -0) (-307, -0) (308, 0) 
(400, 0) (401, 0) (402, 0) (403, 0) (-404, -0) (-405, -0) (-406, -0) (-407, -0) (408, 0) 
(500, 0) (501, 0) (502, 0) (503, 0) (-504, -0) (-505, -0) (-506, -0) (-507, -0) (508, 0) 
(600, 0) (601, 0) (602, 0) (603, 0) (-604, -0) (-605, -0) (-606, -0) (-607, -0) (608, 0) 
(700, 0) (701, 0) (702, 0) (703, 0) (704, 0) (705, 0) (706, 0) (707, 0) (708, 0) 
X
Testing A(I,J) = 1.1 
A
(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) 
(100, 0) (101, 0) (102, 0) (103, 0) (104, 0) (105, 0) (106, 0) (107, 0) (108, 0) 
(200, 0) (201, 0) (202, 0) (203, 0) (11, 0) (11, 0) (11, 0) (11, 0) (208, 0) 
(300, 0) (301, 0) (302, 0) (303, 0) (11, 0) (11, 0) (11, 0) (11, 0) (308, 0) 
(400, 0) (401, 0) (402, 0) (403, 0) (11, 0) (11, 0) (11, 0) (11, 0) (408, 0) 
(500, 0) (501, 0) (502, 0) (503, 0) (11, 0) (11, 0) (11, 0) (11, 0) (508, 0) 
(600, 0) (601, 0) (602, 0) (603, 0) (11, 0) (11, 0) (11, 0) (11, 0) (608, 0) 
(700, 0) (701, 0) (702, 0) (703, 0) (704, 0) (705, 0) (706, 0) (707, 0) (708, 0) 
X
Testing MV_VecIndex + operators: 
X A = 0.0; A(I+1,J-1) = 1.0; 
X A 
(0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) 
(0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) 
(0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) (0, 0) 
(0, 0) (0, 0) (0, 0) (1, 0) (1, 0) (1, 0) (1, 0) (0, 0) (0, 0) 
(0, 0) (0, 0) (0, 0) (1, 0) (1, 0) (1, 0) (1, 0) (0, 0) (0, 0) 
(0, 0) (0, 0) (0, 0) (1, 0) (1, 0) (1, 0) (1, 0) (0, 0) (0, 0) 
(0, 0) (0, 0) (0, 0) (1, 0) (1, 0) (1, 0) (1, 0) (0, 0) (0, 0) 
(0, 0) (0, 0) (0, 0) (1, 0) (1, 0) (1, 0) (1, 0) (0, 0) (0, 0) 
X
Using N = 5 N = 5
X x 
(0, 0)
(1, 0)
(2, 0)
(3, 0)
(4, 0)
X
Testing Vector * scalar:   
X z = x * 2 : 
(0, 0)
(2, 0)
(4, 0)
(6, 0)
(8, 0)
X
X z = z * 2 : 
(0, 0)
(4, 0)
(8, 0)
(12, 0)
(16, 0)
X
Testing Vector *= scalar:  
X (x *= 2) *= 2: 
(0, 0)
(4, 0)
(8, 0)
(12, 0)
(16, 0)
X
Testing Vector += Vector:  
x=2, y=1; x += y: 
(3, 0)
(3, 0)
(3, 0)
(3, 0)
(3, 0)
X
Testing Vector -= Vector:  
x=2, y=1; x -= y: 
(1, 0)
(1, 0)
(1, 0)
(1, 0)
(1, 0)
X
SHAR_EOF
chmod 0660 mv/testing/mv_test.out ||
echo 'restore of mv/testing/mv_test.out failed'
Wc_c="`wc -c < 'mv/testing/mv_test.out'`"
test 20392 -eq "$Wc_c" ||
	echo 'mv/testing/mv_test.out: original size 20392, current size' "$Wc_c"
fi
exit 0
